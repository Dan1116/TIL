# Pro Git_5
## 분산 환경에서의 Git 
* 프로젝트 기여자 또는 관리자로서 작업물을 프로젝트에 어떻게 포함시킬지와 수 많은 개발자가 수행한 일을 취합하고 프로젝트를 운영하는 방법을 배우는 챕터
* 대부분 Merge 하기 위해서는 우선 git fetch로 Fetch 한다

### 분산 환경에서의 Workflow
* 중앙집중형 버전 관리 시스템과는 달리 Git은 분산형이다
* Git 에서는 각 개발자의 저장소가 하나의 노드이기도 하고 중앙 저장소 같은 역할도 할 수 있다
* 모든 개발자는 다른 개발자의 저장소에 일한 내용을 전송하거나, 다른 개발자들이 참여할 수 있도록 자신이 운영하는 저장소 위치를 공개할 수 있다

### 중앙집중식 Workflow
* 중앙집중식 시스템에서는 보통 중앙집중식 협업 모델이라는 한 가지 방식 밖에 없다
* 중앙저장소는 딱 하나 있고 변경 사항은 모두 이 중앙 저장소에 집중된다
 ![](Pro%20Git_5/page142image13648080.png) 

* 중앙 저장소를 하나 만들고 개발자 모두에게 Push 권한을 부여한다
* 모두에게 Push 권한을 부여해도 Git은 한 개발자가 다른 개발자의 작업 내용을 덮어쓰도록 허용하지 않는다 

### Integration - Manager Workflow
* Git을 사용하면 리모트 저장소를 여러 개 운영할 수 있다, 다른 개발자는 읽기만 가능하고 자신은 쓰기도 가능한 공개 저장소를 만드는 Workflow도 된다
![](Pro%20Git_5/page143image13665088.png) 
	1. 프로젝트 Integration-Manager는 프로젝트 메인 저장소에 Push를 한다
	2. 프로젝트 기여자는 메인 저장소를 Clone하고 수정한다
	3. 기여자는 자신의 저장소에 Push 하고 Integration-Manager가 접근할 수 있도록 공개해 놓는다
	4. 기여자는 Integration-Manager에게 변경사항을 적용해 줄 것을 E-mail 같은 것으로 요청한다
	5. Integration-Manager는 기여자의 저장소를 리모트 저장소로 등록하고 수정사항을 Merge하여 테스트한다
	6. Integration-Manager는 Merge한 사항을 메인 저장소에 Push한다

* 이 방식의 장점은 기여자와 Integration - Manager가 각자의 사정에 맞춰 프로젝트를 유지할 수 있다는 점이다
* 기여자는 자신의 저장소와 브랜치에서 수정 작업을 계속해 나갈 수 있고 수정사항이 프로젝트에 반영되도록 기다릴 필요가 없다
* 관리자는 여유를 가지고 기여자가 Push 해 놓은 커밋을 적절한 시점에 Merge 한다

### Dictator and Lieutenants Workflow
* 여러명의 Integration-Manager가 저장소에서 자신이 맡은 부분만을 담당하는데 이들을 Lieutenants라고 부른다
* 모든 Lieutenant는 최종 관리자 아래에 있으며 이 최종 관리자를 Dictator라고 부른다 
* 최종 관리자가 관리하는 저장소를 공식 저장소로 하며 모든 프로젝트 참여자는 이 공식 저장소를 기준으로 작업한다 
![](Pro%20Git_5/page144image13652448.png) 
	1. 개발자는 코드를 수정하고 master 브랜치를 기준으로 자신의 토픽 브랜치를 Rebase 한다, 여기서 master 브랜치란 Dictator의 브랜치를 말한다 
	2. Lieutenant들은 개발자들의 수정사항을 자신이 관리하는 master 브랜치에 Merge 한다
	3. Dictator는 Lieutenant의 master 브랜치를 자신의 master 브랜치로 Merge 한다
	4. Dictator는 Merge한 자신의 master 브랜치를 Push 하며 다른 모든 개발자는 Dictator의 master 브랜치를 기준으로 Rebase 한다

### 커밋 가이드라인
* 무엇보다도 먼저 공백문자를 깨끗하게 정리하고 커밋해야 한다
* git diff - - check => 커밋을 하기 전에 이 명령으로 공백문자에 대한 오류를 확인할 수 있다
* 각 커밋은 논리적으로 구분되는 Changeset 이다
* 최대한 수정사항을 하나의 주제로 요약할 수 있어야 하고 여러가지 이슈에 대한 수정사항을 하나의 커밋에 담지 않아야 한다
* 여러번 나누어 커밋하는 것이 다른 동료가 수정한 부분을 확인할 때나 각 커밋의 시점으로 복원해서 검토할 때 이해하기 쉽다
* 메시지의 첫 라인에 50자가 넘지 않는 아주 간략한 메시지를 적어 해당 커밋을 요약한다
* 다음 한 라인은 비우고 그 다음 라인부터 커밋을 자세히 설명한다 

### 비공개 소규모 팀
* 이런 환경에서는 보통 Subversion 같은 중앙집중형 버전 관리 시스템에서 사용하던 방식을 사용한다
* 대게 서버가 아닌 클라이언트 쪽에서 Merge 한다
![](Pro%20Git_5/page154image13662640.png) 
* 토픽 브랜치에서 수정하고 로컬의 master 브랜치에 Merge 한다
* 작업한 내용을 프로젝트의 공유 저장소에 Push 하고자 할 때에는 우선 origin/master 브랜치를 Fetch하고 Merge 한다, 그리고 Merge한 결과를 다시 서버로 Push 한다 

### 비공개 대규모 팀
![](Pro%20Git_5/page160image14135280.png) 
* 수많은 팀의 작업을 동시에 진행하고 나중에 Merge하는 기능을 사용하려고 다른 버전 관리 시스템에서 Git으로 바꾸는 조직들이 많아지고 있다
* 팀은 자신의 브랜치로 작업하지만, 메인 브랜치에 영향을 끼치지 않는다는 점이 Git의 장점이다 

### 공개 프로젝트 Fork
* 공개 팀을 운영할 때에는 모든 개발자가 프로젝트의 공유 저장소에 직접적으로 쓰기 권한을 가지지는 않는다 
* 프로젝트 웹사이트로 가서 Fork 버튼을 누르면 원래 프로젝트 저장소에서 갈라져 나오면 쓰기 권한이 있는 저장소가 하나 만들어진다, 그러면 로컬에서 수정한 커밋을 원래 저장소에 Push 할 수 있다, 그 저장소를 로컬 저장소의 리모트 저장소로 등록한다
* Fork 한 저장소에 Push 하고 나면 프로젝트 관리자에게 이 내용을 알려야 한다, 이것을 Pull Request 라고 한다
* - - squash 옵션은 브랜치에 Merge 할 때 해당 브랜치의 커밋을 모두 하나의 커밋으로 합쳐서 Merge 하는 기능이다

### 대규모 공개 프로젝트와 이메일을 통환 관리
* Git에는 Patch 메일을 그대로 보낼 수 있는 도구가 있다, IMAP 프로토콜로 보낸다 

### 프로젝트 관리
* 프로젝트를 운영하는 것은 크게 두 가지로 이루어진다
	* 1. format-patch 명령으로 생성한 Patch를 이메일로 받아서 프로젝트에 Patch를 적용하는 법
	* 2. 프로젝트의 다른 리모트 저장소로부터 변경 내용을 Merge 하는 법

### 토픽 브랜치에서 일하기
* 메인 브랜치에 통합하기 전에 임시로 토픽 브랜치를 하나 만들고 거기에 통합해 보고 나서 다시 메인 브랜치에 통합하는 것이 좋다
* 이렇게 하면 Patch를 적용 할 때 이리저리 수정해 보기도하고 좀 더 고민해봐야하면Patch를 적용해둔 채로 나중으로 미룰 수도 있다
* 무슨 Patch인지 브랜치 이름에 간단히 적어주면 다른 작업을 하다가 나중에 이 브랜치로 돌아왔을 때 기억해내기 훨 씬 수월하다 
* 이렇게 토픽 브랜치를 만들고 Patch를 적용해보고 적용한 내용을 다시 Long-Running 브랜치로 Merge 한다

### 이메일로 받은 Patch를 적용하기
* 이메일로 받은 Patch를 프로젝트에 적용하기 전에 우선 토픽 브랜치에 Patch를 적용한다 
* Patch를 적용하는 방법은 git apply 명령을 사용하는 것과 git am명령을 사용하는 것 두 가지가 있다 ->

	* 1. APPLY 명령을 사용하는 방법
		* git apply는 “모두 적용, 아니면 모두 취소” 모델을 사용하기 때문에 Patch를 적용하는 데 실패하면 Patch를 적용하기 이전 상태로 전부 되돌려 놓는다
		* Patch 명령은 여러 파일에 적용하다가 중간에 실패하면 거기서 그대로 중단하기 때문에 깔끔하지 못하다
		* git apply는 Patch보다 훨씬 결벽증적이다, 이 명령은 자동으로 커밋해 주지 않기 때문에 변경된 파일을 직접 Staging Area에 추가하고 커밋해야 한다

	* 2. AM 명령을 사용하는 방법
		* format-patch 명령으로 만든 Patch 파일은 기여자의 정보와 커밋 정보가 포함되어 있기 때문에 기여자가 diff보다 format-patch를 사용하도록 권해야 한다
		* git apply는 기존의 Patch 파일에만 사용한다, format-patch 명령으로 생성한 Patch 파일은 git am 명령으로 적용한다, git am은 메일 여러 통이 들어 있는 mbox파일을 읽어서 Patch 한다
		* Patch가 성공하면 자동으로 새로운 커밋이 하나 만들어진다. 이메일의 From과 Date에서 저자 정보가, 이메일의 제목과 메시지에서 커밋 메시지가 추출돼 사용된다 
		* Commit 부분의 커밋 정보는 누가 언제 Patch 했는지 알려 준다. Author 정 보는 실제로 누가 언제 Patch파일을 만들었는지 알려준다
		* Patch에 실패할 수도 있다. 보통 Patch가 생성된 시점보다 해당 브랜치가 너무 업데이트 됐을 때나 아직 적용되지 않은 다른 Patch가 필요한 경우에 일어난다
		* git am 명령은 Patch를 중단하고 사용자에게 어떻게 처리할 지 물어온다. 

### 리모트 브랜치로부터 통합하기
* 프로젝트 기여자가 자신의 저장소를 만들고 커밋을 몇 번 하고 저장소의 URL과 변경 내용을 메일로 보내왔다면 URL을 리모트 저장소로 등록하고 Merge 할 수 있다
* 리모트 저장소로 등록하면 커밋의 히스토리도 알 수 있다. Merge 할 때 어디서부터 커밋이 갈라졌는지 알 수 있기 때문에 -3옵션을 주지 않아도 자동으로 3-way Merge가 적용된다
* 리모트 저장소로 등록하지 않고도 Merge 할 수 있다. 계속 함께 일할 개발 자가 아닐 때 사용하면 좋다 

### 무슨 내용인지 확인하기
* git log 명령에 -p 옵션을 주면 각 커밋에서 실제로 무슨 내용이 변경됐는지 살펴볼 수 있다, 이 옵션은 각 commit의 뒤에 diff의 내용을 출력해준다 
* diff 명령을 사용할 때 두 브랜치 사이에 …를 쓰면, 두 브랜치의 공통 조상과 브랜치의 마 지막 커밋을 비교한다 -> “git diff master…contrib“

### 기여물 통합하기

#### MERGE 하는 WORKFLOW
	* 바로 master 브랜치에 Merge 하는 것이 가장 간단하다
	* 이 Workflow에서는 master 브랜치가 안전한 코드라고 가정한다
	* 토픽 브랜치를 검증하고 master 브랜치로 Merge 할 때마다 토픽 브랜치를 삭제한다 
	* 이 Workflow을 사용하면 프로젝트 저장소를 Clone 하고 나서 개발자가 안정 버전이 필요하면 master 브랜치를 빌드하고 안정적이지 않더라도 좀 더 최신 버전이 필요하면 develop 브랜치를 Checkout 하여 빌드한다
	* 토픽 브랜치를 검증하기 위한 integrate 브랜치를 만들어 Merge 하고 토픽 브랜치가 검증되면 develop 브랜치에 머지한다, 그리고 develop 브랜치에서 충분히 안정하다는 것이 증명되면 그때 master 브랜치에 Merge 한다

#### 대규모 MERGE WORKFLOW
	* Git을 개발하는 프로젝트는 Long-Running의 브랜치를 4개 운영한다
	* 각 브랜치 이름은 master, next, pu (Proposed Updates), maint 이다
	* maint는 마지막으로 릴리즈한 버전을 지원하는 브랜치다
	* 토픽 브랜치가 좀 더 개선돼야 하면 next가 아니라 pu에 Merge 한다, 그 후에 충분히 검증을 마치면 pu에서 next로 옮기고 next를 기반으로 pu를 다시 만든다
	* next에는 아직 master에 넣기에 모자라 보이는 것들이 들어있다, 즉 next 브랜치는 정말 가끔 Rebase 하고 pu는 자주 Rebase 하지만 master는 항상 Fast-forward 한다
	* 토픽 브랜치가 결국 master 브랜치로 Merge 되면 저장소에서 삭제한다. 그리고 이전 릴리즈 버전에 Patch가 필요하면 maint 브랜치를 이용해 대응한다

#### REBASE와 CHERRY-PICK WORKFLOW
	* 히스토리를 평평하게 관리하려고 Merge 보다 Rebase 나 Cherry-Pick을 더 선호하는 관리자들도 있다
	* 토픽 브랜치에서 작업을 마친 후 master에 통합할 때 master 브랜치를 기반으로 Rebase 한다, 그러면 커밋이 다시 만들어진다, master 대신 develop 등의 브랜치에도 가능하다, 문제가 없으면 master 브랜치를 Fast-forward시킨다
	* 한 브랜치에서 다른 브랜치로 작업한 내용을 옮기는 또 다른 방식으로 Cherry-pick이란 것도 있다, Git의 Cherry-pick은 커밋 하나만 Rebase 하는 것이다
	* 커밋 하나로 Patch 내용을 만들어 현재 브랜치에 적용을 하는 것이다, 토픽 브랜치에 있는 커밋중에서 하나만 고르거나 토픽 브랜치에 커밋이 하나밖에 없을 때 Rebase 보다 유용하다 
	* Rebase 나 Cherry-pick 방식으로 토픽 브랜치를 합치고 나면 필요없는 토픽 브랜치나 커밋은 삭제한다

#### RERERE
	* 수시로 Merge 나 Rebase를 한다거나 오랫동안 유지되는 토픽브랜치를 쓰는 사람에게 유용한 “rerere” 기능이 있다
	* Rerere의 뜻은 “reuse recorded reolution”(충돌 해결방법 재사용)으로 수작업으로 충돌 해결하던 것을 쉽게 해준다. rerere 기능이 활성화 돼 있으면 Merge가 성공할 때 마다 그 이전과 이후 상태를 저장해둔다. 나중에 충돌이 발생하면 비슷한 상황에서 Merge가 성공한 적이 있었는지 찾아보고 해결이 가능하다면 자동으로 해결한다
	* Rerere 기능의 동작은 두 부분으로 나누어 볼 수 있다. Rerere 기능을 설정하는 부분과 Rerere 기능을 명령으로 사용하는 부분이다. 설정은 rerere.en- abled 값을 설정하면 되는데 글로벌 설정에 저장해 두고 사용하면 편하다 => git config —global rerere.enabled true 
	* 이 명령어를 사용하면 Merge가 성공할 때 마다 전후 상황을 기록해두고 나중에 충돌이 나면 사용할 수 있게됐다. 
	* 필요하다면 git rerere 명령을 사용하여 저장된 캐시를 바탕으로 대화형 인터페이스를 통해 충돌을 다룰 수도 있다. git rerere 명령을 직접 실행하면 현재 Merge 과정에서 발생한 충돌을 해결하는데 참고할 만한 이전 Merge 기록을 찾아준다(사실 rerere.enabled 옵션이 켜져 있다면 자동)

### 릴리즈 버전에 태그 달기
* 태그에 서명하면 서명에 사용한 PGP 공개키도 배포해야 한다. Git 개발 프로젝트는 관리자의 PGP 공개키를 Blob 형식으로 Git 저장소에 함께 배포한다. gpg —list-keys 명령으로 어떤 PGP 공개키를 포함할지 확인한다. 
* git hash-object라는 명령으로 공개키를 바로 Git 저장소에 넣을 수 있다. 이 명령은 Git 저장소 안에 Blob 형식으로 공개키를 저장해주고 그 Blob의 SHA-1 값을 알려준다
* hash-object 명령으로 구한 SHA-1 해시값으로 PGP 공개키를 가리키는 태그를 만든다

### 빌드넘버 만들기
* git describe 명령으로 좀 더 사람이 기억하기 쉬운 이름을 얻을 수 있다. Git은 가장 가까운 태그의 이름과, 태그에서 얼마나 더 커밋이 쌓였는지, 그리고 해당 커밋의 SHA-1 값을 조금 가져다가 이름을 만든다 

### 릴리즈 준비하기
* ZIP 형식으로 압축파일을 만들어서 배포할 수 있다
* git archive master —prefix=‘project/‘ —format=zip > `git describe master`.zip 

### Shortlog 보기
* 이메일로 프로젝트의 변경 사항을 사람들에게 알려야 할 때, git short- log명령을 사용하면 지난 릴리즈 이후의 변경사항 목록을 쉽게 얻어올 수 있다 
* git shortlog 명령은 주어진 범위에 있는 커밋을 요약해준다 
