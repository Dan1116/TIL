#  Pro Git_3
## 브랜치
* 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있게 만드는 것이 브랜치이다 

### 브랜치란 무엇인가
* Git은 데이터를 Change Set이나 변경사항 (Diff)로 기록하지 않고 스냅샷으로 기록한다
* 커밋하면 Git은 현 Staging Area에 있는 데이터의 스냅샷에 대한 포인터, 저자나 커밋 메시지 같은 메타데이터, 이전 커밋에 대한 포인터 등을 포함하는 커밋 개체(커밋 Object)를 저장한다
* 이전 커밋 포인터가 있어서 현재 커밋이 무엇을 기준으로 바뀌었는지를 알 수 있다
* git commit으로 커밋하면 먼저 루트 디렉토리와 각 하위 디렉토리의 트리 개체를 체크섬과 함께 저장소에 저장한다
* 그다음에 커밋 개체를 만들고 메타데이터와 루트 디렉토리 트리 개체를 가리키는 포인터 정보를 커밋 개체에 넣어 저장한다. 그래서 필요하면 언제든지 스냅샷을 다시 만들 수 있다 
* 이 작업을 마치고 나면 Git저장소에는 다섯개의 데이터 개체가 생긴다, 각 파일에 대한Blob 세개, 파일과 디렉토리 구조가 들어있는 트리 개체 하나,메타데이터와 루트 트리를 가리키는 포인터가 담긴 커밋 개체 하나이다
* Git의 브랜치는 커밋 사이를 가볍게 이동할 수 있는 어떤 포인터 같은 것이다

### 새 브랜치 생성하기
* git branch testing
* HEAD = > 지금 작업중인 브랜치가 무엇인지 알게 하는 포인터
* git log - - decorate => 브랜치가 어떤 커밋을 가리키는지 확인할 수 있다

### 브랜치 이동하기
* git checkout 명령으로 다른 브랜치로 이동할 수 있다
* 브랜치를 이동하면 워킹 디렉토리의 파일이 변경된다
* git log - - oneline - - decorate - - graph - - all => 히스토리를 출력

### 브랜치와 Merge 의 기초
* git checkout -b => 브랜치를 만들면서 Checkout까지 한번에 하는 명령어
* 브랜치를 이동하려면 워킹 디렉토리를 정리하는 것이 좋다, 아직 커밋하지 않은 파일이 Checkout 할 브랜치와 충돌 나면 브랜치를 변경할 수 없다 
* Merge 할 브랜치가 가리키는 커밋이 현 브랜치 커밋의 Upstream 브랜치이기 때문에 master 브랜치 포인터는 최신 커밋으로 이동한다. 이런 Merge 방식을  Fast forward라고 부른다. 다시 말해서 A 브랜치에서 다른 B 브랜치를 Merge 할 때 B가 A 이후의 커밋을 가리 키고있으면 그저 A가 B의 커밋을 가리키게 할 뿐이다

### 충돌의 기초
* 가끔씩 3-way Merge가 실패할 때도 있다, Merge 하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 Merge 하면 Git은 해당 부분을 Merge 하지 못한다
* Git은 자동으로 Merge 하지 못해서 새 커밋이 생기지 않는다, 변경사항의 충돌을 개발자가 해결하지 않는 한 Merge 과정을 진행할 수 없다
* git status 를 통해 상태를 확인하고 원인을 분석하여 충돌을 해결해야 한다

### 브랜치 관리
* git branch 명령은 단순히 브랜치를 만들고 삭제하는 것이 아니다. 아무런 옵션 없이 실행하면 브랜치의 목록을 보여준다
* * 기호가 붙어 있는 master브랜치는 현재 Checkout 해서 작업하는 브랜치를 나타낸다,즉, 지금 수정한 내용을 커밋하면 master 브랜치에 커밋되고 포인터가 앞으로 한 단계 나아간다
* git branch -v 명령을 실행하면 브랜치 마다 마지막 커밋 메시지도 함께 보여준다
* 현재 Checkout 한 브랜치를 기준으로 - - merged와  - -no-merged 옵션을 사용하여 Merge 된 브랜치인지 그렇지 않은지 필터링해 볼 수 있다. git branch - -merged 명령으로 이미 Merge 한 브랜치 목록을 확인할 수 있다

## 브랜치 Workflow
### Long-Running 브랜치
* Git은 꼼꼼하게  3-Way-Merge 를 사용하기 때문에 장기간에 걸쳐서 한 브랜치를 다른 브랜치와 여러 번 Merge 하는 것이 쉬운 편이다
* 배포했거나 배포할 코드만 master 브랜치에 Merge 해서 안정 버전의 코드만 master 브랜치에 둔다
* Long-Running 브랜치를 이용해 여러 단계에 걸쳐서 안정화해 나아가면서 충분히 안정화가 됐을 때 안정 브랜치로 Merge한다는 점이 중요한 포인트

### 토픽 브랜치
* 토픽 브랜치는 어떤 한 가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치이다

### 리모트 브랜치
* 리모트 저장소에 있는 브랜치, 태그 등등을 의미한다
* 리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 브랜치이다, 이 브랜치는 로컬에 있지만 움직일 수 없다 (리모트 서버에 연결할 때마다 리모트 브랜치에 따라서 자동으로 움직일 뿐)

### Push 하기
* 로컬의 브랜치를 서버로 전송하려면 쓰기 권한이 있는 리모트 저장소에 Push 해야 한다. 로컬 저장소의 브랜치는 자동으로 리모트 저장소로 전송되지 않는다. 명시적으로 브랜치를 Push 해야 정보가 전송된다. 

### 브랜치 추적
* 리모트 트래킹 브랜치를 로컬 브랜치로 Checkout 하면 자동으로 “트래킹 (Tracking) 브랜치”가 만들어진다 (종종 “Upstream 브랜치” 라고 부른다) 
* 트래킹 브랜치는 리모트 브랜치와 직접적인 연결고리가 있는 로컬 브랜치이다
* 이미 로컬에 존재하는 브랜치가 리모트의 특정 브랜치를 추적하게 하려면 git branch 명령에 -u나 - -set-upstream-to 옵션을 붙여서 설정한다

### Pull 하기
*  git fetch 명령을 실행하면 서버에는 존재하지만, 로컬에는 아직 없는 데이터를 받아와서 저정한다. 이때 워킹 디렉토리의 파일 내용은 변경되지 않고 그대로 남는다. 서버로부터 데이터를 가져와서 저장해두고 사용자가 Merge 하도록 준비만 해둔다. 간단히 말하면 git pull 명령은 대부분 git fetch 명령을 실행하고 나서 자동으로 git merge 명령을 수행하는 것 뿐이다

### 리모트 브랜치 삭제
* git push 명령에 - -delete 옵션을 사용하여 리모트 브랜치를 삭제할 수 있다 
* 서버에서 가비지 컬렉터가 동작하지 않는 한 데이터는 사라지지 않기때문에 종종 의도치않게 삭제한 경우에도 커밋한 데이터를 살릴 수 있다

## Rebase 하기
* Git에서 한 브랜치에서 다른 브랜치로 합치는 방법으로는 두 가지가 있다. 하나는 Merge 이고 다른 하나는 Rebase이다 

### Rebase의 기초
* 두 브랜치가 나뉘기 전인 공통 커밋으로 이동하고 나서 그 커밋부터 지금 Checkout 한 브랜치가 가리키는 커밋까지 diff를 차례로 만들어 어딘가에 임시로 저장해 놓는다
* Rebase 할 브랜치 (역주 - experiment)가 합칠 브랜치(역주 - master)가 가리키는 커밋을 가리키게 하고 아까 저장해 놓았던 변경사항을 차례대로 적용한다
* 마지막으로 master 브랜치를 Fast-forward 시킨다

### Rebase의 위험성
* 이미 공개 저장소에 Push 한 커밋을 Rebase 하지 마라

### Rebase 한 것을 다시 Rebase 하기
* 커밋 SHA 체크섬 외에도 Git은 커밋에 Patch 할 내용으로 SHA 체크섬을 한 번 더 구한다. 이 값은 “patch-id”라고 한다
* 덮어 쓴 커밋을 받아서 그 커밋을 기준으로 Rebase 할 때 Git은 원래 누가 작성한 코드인지 잘 찾아낸다. 그래서 Patch가 원래대로 잘 적용된다

### Rebase Vs Merge
* 히스토리를 보는 관점 중에 하나는 작업한 내용의 기록으로 보는 것이다
* 히스토리를 프로젝트가 어떻게 진행되었나에 대한 이야기로도 볼 수 있다 
* 일반적인 해답을 굳이 드리자면 로컬 브랜치에서 작업할 때는 히스토리를 정리하기 위해서 Rebase 할 수도 있지만, Push로 리모트 밖으로 내보낸 커밋에 대해서는 절대 Rebase 하지 말아야 한다
* Rebase가 Merge 보다 좀 더 깨끗한 히스토리를 만든다, Rebase 한 브랜치의 Log를 살펴보면 히스토리가 선형이다