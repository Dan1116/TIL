# SWIFT_21~22
## 익스텐션
* 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있다
* 기능을 추가하려는 타입을 구현한 소스 코드를 알지 못해도 타입만 안다면 그 타입의 기능을 확장할 수 있다
* 스위프트의 익스텐션은 이름이 없다
* 익스텐션은 타입에 새로운 기능을 추가할 수는 있지만, 기존에 존재하는 기능을 재정의할 수는 없다
* 클래스의 상속은 클래스 타입에서만 가능하지만 익스텐션은 구조체, 클래스, 프로토콜 등에 적용이 가능하다
* 클래스의 상속은 특정 타입을 물려받아 하나의 새로운 타입을 정의하고 추가 기능을 구현하는 수직 확장이지만, 익스텐션은 기존의 타입에 기능을 추가하는 수평 확장이다

* 스위프트의 익스텐션이 타입에 추가할 수 있는 기능은 다음과 같다 ->
	* 1. 연산 타입 프로퍼티 / 연산 인스턴스 프로퍼티
	* 2. 타입 메서드 / 인스턴스 메서드
	* 3. 이니셜라이저
	* 4. 서브스크립트
	* 5. 중첩 타입
	* 6. 특정 프로토콜을 준수할 수 있도록 기능 추가

### 익스텐션 문법
* extension 키워드 사용
* 익스텐션은 기존에 존재하는 타입이 추가로 다른 프로토콜을 채택할 수 있도록 확장할 수 있다

### 연산 프로퍼티
* 익스텐션으로 연산 프로퍼티를 추가할 수는 있지만, 저장 프로퍼티는 추가할 수 없다
* 타입에 정의되어 있는 기존의 프로퍼티에 프로퍼티 감시자를 추가할 수도 없다

### 이니셜라이저
* 인스턴스를 초기화 할 때 인스턴스 초기화에 필요한 다양한 데이터를 전달 받을 수 있도록 여러 종류의 이니셜라이저를 만들 수 있다
* 타입 정의 부분에 이니셜라이저를 추가하지 않더라도 익스텐션을 통해 이니셜라이저를 추가할 수 있다
* 익스텐션으로 클래스 타입에 편의 이니셜라이저는 추가할 수 있지만, 지정 이니셜라이저는 추가할 수 없다
* 지정 이니셜라이저와 디이니셜라이저는 반드시 클래스 타입의 구현부에 위치해야 한다 (값 타입은 상관없다)
* 익스텐션으로 값 타입 (열거형, 구조체 등)에 이니셜라이저를 추가했을 때, 해당 값 타입이 모든 저장 프로퍼티에 기본값이 있고, 타입에 기본 이니셜라이저와 멤버와이즈 이니셜라이저 외에 추가 사용자정의 이니셜라이저가 없으면 익스텐션으로 사용자정의 이니셜라이저를 추가한 이후에도 해당 타입의 기본 이니셜라이저와 멤버와이즈 이니셜라이저를 호출할 수 있다
* 익스텐션을 통해 추가하는 이니셜라이저는 타입의 기존 이니셜라이저가 갖는 책무를 동일하게 수행해야 한다, 이니셜라이저 호출이 종료되는 시점까지 인스턴스가 정상적으로 완벽하게 초기화되는 것을 책임져야 한다

## 제네릭
* 제네릭으로 구현한 기능과 타입은 재사용하기 쉽고, 코드의 중복을 줄일 수 있기에 깔끔하고 추상적인 표현이 가능하다
* 제네릭을 사용하고자 할 때는 제네릭이 필요한 타입 또는 메서드의 이름 뒤의 <> 사이에 제네릭을 위한 타입 매개변수를 써주어 제네릭을 사용할 것임을 표시한다

### 제네릭 함수
* 제네릭 함수는 실제 타입 이름 (Int, String 등) 을 써주는 대신에 플레이스홀더를 사용한다
* 플레이스홀더는 타입의 종류를 알려주지 않지만 말 그대로 어떤 타입이라는 것은 알려준다
* T (플레이스홀더) 의 실제 타입은 함수가 호출되는 그 순간 결정된다
* 제네릭 함수의 플레이스홀더를 지정하는 방법은 함수 이름 오른쪽의 <> 안 쪽에 플레이스홀더 이름들을 나열하는 것이다
* 플레이스홀더 타입 T는 타입 매개변수의 한 예로 들 수 있다
* 타입 매개변수는 플레이스홀더 타입의 이름을 지정하고 명시하는 역할을 하며, 함수의 이름 뒤 <> 안쪽에 위치한다
* 타입 매개변수를 지정해주면 이를 함수의 매개변수의 타입으로, 함수의 반환 타입으로, 함수 내부 변수의 타입 지정을 위해 사용할 수도 있다, 각각의 경우 타입 매개변수는 함수를 호출할 때마다 실제 타입으로 치환된다

### 제네릭 타입
* 제네릭 타입을 구현하면 사용자정의 타입인 구조체, 클래스, 열거형 등이 어떤 타입과도 연관되어 동작할 수 있다
* 스택은 배열과 유사하게 순서가 있는 값들의 모음이다
* 배열은 중간 중간 요소를 삽입하거나 삭제할 수 있지만, 스택은 컬렉션의 끝 부분에서만 요소를 추가하고 삭제할 수 있다 (추가는 푸시 삭제는 팝)

### 제네릭 타입 확장
* 익스텐션을 통해 제네릭을 사용하는 타입에 기능을 추가하고자 한다면 익스텐션 정의에 타입 매개변수를 명시하지 않아야 한다, 원래의 제네릭 정의에 명시한 타입 매개변수를 익스텐션에 사용할 수 있다

### 타입 제약
* 타입 제약은 클래스 타입 또는 프로토콜로만 줄 수 있다, 열거형, 구조체 등의 타입은 타입 제약의 타입으로 사용할 수 없다
* 타입 매개변수 뒤에 콜론을 붙이고 제약조건으로 주어질 타입을 명시해주면 된다, 여러 제약을 추가하고 싶다면 콤마로 구분해주는 것이 아니라 where절을 이용해야 한다

### 프로토콜의 연관 타입
* 연관 타입은 프로토콜에서 사용할 수 있는 플레이스홀더 이름이다
* 제네릭에서는 어떤 타입이 들어올지 모를 때 타입 매개변수를 통해 종류는 알 수 없지만, 어떤 타입이 여기에 쓰일 것이다 라고 표현해주었다면 연관 타입은 타입 매개변수의 그 역할을 프로토콜에서 실행할 수 있도록 만들어진 기능이다
* 프로토콜의 연관 타입에 대응하여 실제 타입을 사용할 수도 있지만, 제네릭 타입에서는 연관 타입과 타입 매개변수를 대응시킬 수도 있다

### 제네릭 서브스크립트
* 서브스크립트도 제네릭을 활용하여 타입에 큰 제한 없이 유연하게 구현할 수 있다