# Kotlin In Action_2
## 코틀린 기초
* 변수
* 함수
* 클래스
* 프로퍼티
* 스마트 캐스트 : 타입 겁사와 타입 캐스트, 타입 강제 변환을 하나로 엮은 기능이다
* 예외처리

## 기본 요소 : 함수와 변수
* 함수를 선언할 때 fun 키워드를 사용한다
* 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다, 변수를 선언할 때도 마찬가지 방식으로 타입을 지정한다
* 함수를 최상위 수준에 정의할 수 있다, 꼭 클래스 안에 함수를 넣어야 할 필요가 없다
* 배열도 일반적인 클래스와 마찬가지다, 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다
* println을 사용한다, 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공한다
* 세미클론을 붙이지 않아도 된다

### 함수
* 함수 선언은 fun 키워드로 시작한다, fun 다음에는 함수 이름이 온다, 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다
* 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론 : 으로 구분해야 한다
* 코틀린에서 if는 식이지 문이 아니다, 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다
* 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다
* 대입문은 자바에서는 식이었으나 코틀린에서는 문이 됐다
* 블록이 본문인 함수 : 본문이 중괄호로 둘러싸인 함수
* 식이 본문인 함수 : 등호와 식으로 이뤄진 함수
* 코틀린에서는 식이 본문인 함수가 자주 쓰인다
* 타입 추론 : 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능
* 식이 본문인 함수의 반환 타입만 생략 가능하다, 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return 문을 사용해 반환 값을 명시해야 한다

### 변수
* 자바에서는 변수를 선언할 때 타입이 맨 앞에 온다, 코틀린에서는 타입 지정을 생략하는 경우가 흔하다
* 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없다
* 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다
* 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다
* val : 변경 불가능한 참조를 저장하는 변수, 한번 초기화하고 나면 재대입이 불가능하다
* var : 변경 가능한 참조, 변수의 값은 바뀔 수 있다
* val 변수는 블록을 실행할 때 한 번만 초기화돼야 한다
* 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다
* val 참조 객체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다는 사실을 기억해야 한다

### 문자열 형식 지정: 문자열 템플릿
* 코틀린에서도 변수를 문자열 안에 사용할 수 있다, 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다
* 컴파일러는 각 식을 정적으로 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다
* $ 문자를 문자열에 넣고 싶으면 \를 사용해 $를 이스케이프 시켜야 한다
* 변수 이름은 {}로 감싸는 습관을 들이면 좋다

## 클래스와 프로퍼티
* 코틀린의 기본 가시성은 public 이다
* 클래스를 값 객체라 부른다

### 프로퍼티
* 클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다
* 자바에서 데이터를 필드에 저장하며, 멤버 필드의 가시성은 보통 비공개이다
* 클래스는 자신을 사용하는 클라이언트가 그 데이터에 접근하는 통로로 쓸 수 있는 접근자 메소드를 제공한다
* 필드를 읽기 위한 게터를 제공하고 필드를 변경하게 허용해야하는 경우에는 세터를 추가 제공한다
* 세터는 자신이 받은 값을 검증하거나 필드 변경을 다른 곳에 통지하는 등의 로직을 더 가질 수 있다
* 자바에서는 필드와 접근자를 한데 묶어 프로퍼티라고 부르며  프로퍼티라는 개념을 활용하는 프레임워크가 많다
* 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다
* 클래스에서 프로퍼티를 선언할 때는 val이나 var를 사용한다, val 은 읽기 전용 , var은 변경 가능하다
* 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것이다
* 코틀린은 값을 저장하기 위한 비공개 필드와 그 필드에 값을 저장하기 위한 세터, 필드의 값을 읽기 위한 게터로 이뤄진 간단한 디폴트 접근자 구현을 제공한다
* 이름이 is로 시작하는 프로퍼티의 게터에는 get이 붙지 않고 원래 이름을 그대로 사용하며, 세터에는 is 를 set 으로 바꾼 이름을 사용한다
* 프로퍼티를 뒷받침하는 필드 : 그 프로퍼티의 값을 저장하기 위한 필드
* 클래스의 특성을 정의하고 싶다면 프로퍼티로 그 특성을 정의해야 한다

### 디렉터리와 패키지
* 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다
* 다른 패키지에 정의한 선언을 사용하려면 임포트해야한다
* 코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다
* 코틀린에서는 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 상관없다

### enum과 when
* when은 자바의 switch를 대치하되 더 강력하다
* 코틀린에서는 enum class를 사용하지만 자바에서는 enum을 사용한다
* 코틀린에서 enum 은 소프트 키워드라 부르는 존재다
* enum은 class 앞에 있을 대는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다, 반면 class는 키워드이다
* enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다
* enum 클래스 안에 메소드를 정의하는 경우 반드시 enum 상수 목록과 메소드 정의 사이에 세미콜론을 넣어야 한다
* 자바와 다르게 분기의 끝에 break 를 넣지 않아도 된다
* 성공적으로 매치되는 분기를 찾으면 switch 는 그 분기를 실행한다
* 한 분기 안에서 여러 값을 매치 패턴으로 사용할 수 있다, 그럴 경우 값 사이를 콤마로 분리한다
* 코틀린에서 when 은 자바의 swtich보다 강력하다
* 분기 조건에 상수만을 사용할 수 있는 자바 switch와 달리 코틀린 when의 분기 조건은 임의의 객체를 허용한다
* when 식은 인자 값과 매치하는 조건 값을 찾을 때까지 각 분기를 검사한다
* when의 분기 조건 부분에 식을 넣을 수 있기 때문에 많은 경우 코드를 더 간결하고 아름답게 작성할 수 있다
* 인자가 없는 when을 사용하는 경우도 있다 -> 불필요한 객체 생성을 막을 수 있다

### 스마트 캐스트 : 타입 검사와 타입 캐스트를 조합
* 코틀린에서는 프로그래머 대신 컴파일러가 캐스팅을 해준다, 어떤 변수가 원하는 타입인지 일단 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 사용할 수 있다 -> 스마트 캐스트
* 스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다
* 원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용해야 한다

### while과 for 루프
* 코틀린 while은 자바와 동일하다
* for는 자바의 for-each 루프에 해당하는 형태만 존재한다
* 코틀린에는 자바의 for루프에 해당하는 요소가 없다 코틀린에서는 range를 사용한다
* 범위는 기본적으로 두 값으로 이뤄진 구간이다, 보통은 그 두 값은 정수 등의 숫자 타입의 값이며, .. 연산자로 시작 값과 끝을 연결해서 범위를 만든다
* 코틀린의 범위는 폐구간 또는 양끝을 포함하는 구간이다, 이는 두 번째 값이 항상 범위에 포함된다는 뜻이다
* 정수 범위로 수행할 수 있는 가장 단순한 작업은 범위에 속한 모든 값에 대한 이터레이션이다
* 이런 식으로 어떤 범위에 속한 값을 일정한 순서로 이터레이션하는 경우를 수열이라 부른다

### in으로 컬렉션이나 범위의 원소 검사
* 어떤 값이 범위나 컬렉션에 들어있는지 알고 싶을 때도 in을 사용한다
* 범위는 문자에만 국한되지 않고 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다

## 코틀린의 예외 처리
* 예외 인스턴스를 만들 때도 new 를 붙일 필요가 없다
* 자바와 달리 코틀린의 throw 는 식이므로 다른 식에 포함 될 수 있다
* 자바와 마찬가지로 try, catch , finally 절을 함께 사용한다
* 코틀린에서는 함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다
* try의 값을 변수에 대입할 수 있다
* if 와 달리 try의 본문을 반드시 중괄호 {}로 둘러싸야 한다

## 요약
* 함수를 정의할 때 fun 키워드를 사용한다, val과 var은 각각 읽기 전용 변수와 변경 가능한 변수를 선언할 때 쓰인다
* 문자열 템플릿을 사용하면 문자열을 연결하지 않아도 되므로 코드가 간결해진다, 변수 이름 앞에 $를 붙이거나, 식을 {}로 둘러싸면 변수나 식의 값을 문자열 안에 넣을 수 있다
* 코틀린에서는 값 객체 클래스를 아주 간결하게 표현할 수 있다
* if는 코틀린에서 식이며, 값을 만들어 낸다
* 어떤 변수의 타입을 검사하고 나면 굳이 그 변수를 캐스팅하지 않아도 검사한 타입의 변수처럼 사용할 수 있다, 컴파일러가 스마트 캐스트를 활용해 자동으로 타입을 바꿔준다
* 1..5 와 같은 식의 범위를 만들어내며 for 루프에 대해 같은 추상화를 제공한다
* 코틀린에서는 함수가 던질 수 있는 예외를 선언하지 않아도 된다