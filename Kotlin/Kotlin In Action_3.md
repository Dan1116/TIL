# Kotlin In Action_3
## 함수 정의와 호출
* 컬렉션, 문자열, 정규식을 다루기 위한 함수
* 이름 붙인 인자, 디폴트 파라미터 값, 중위 호출 문법 사용
* 확장 함수와 확장 프로퍼티를 사용해 자바 라이브러리 적용
* 최상위 및 로컬 함수와 프로퍼티를 사용해 코드 구조화

* 확장을 통해 자바 라이브러리를 활용하면 코틀린과 자바를 함께 쓰는 프로젝트에서 코틀린의 장점을 최대한 살릴 수 있다

### 코틀린에서 컬렉션 만들기
* 코틀린은 자신만의 컬렉션 기능을 제공하지 않는다
* 자바 개발자가 기존 자바 컬렉션을 활용할 수 있다
* 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스이다, 하지만 코틀린에서는 더 많은 기능을 사용할 수 있다

### 함수를 호출하기 쉽게 만들기
* 제네릭 함수의 문법은 자바와 비슷하다
* 코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부의 이름을 명시할 수 있다
* 호출 시 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름을 꼭 명시해야 한다
* 불행히도 자바로 작성한 코드를 호출할 때는 이름 붙인 인자를 사용할 수 없다

### 디폴트 파라미터 값
* 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있으므로 이런 오버로드 중 상당수를 피할 수 있다
* 일반 호출 문법을 사용하려면 함수를 선언할 때와 같은 순서로 인자를 지정해야 한다
* 함수의 디폴트 파라미터 값은 함수를 호출하는 쪽이 아니라 함수 선언 쪽에서 지정된다는 사실을 기억해야 한다
* 어떤 클래스 안에 정의된 함수의 디폴트 값을 바꾸고 그 클래스가 포함된 파일을 재컴파일하면 그 함수를 호출하는 코드 중에 값을 지정하지 않은 모든 인자는 자동으로 바뀐 디폴트 값을 적용 받는다

### 최상위 프로퍼티
* 함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다
* 기본적으로 최상위 프로퍼티도 다른 모든 프로퍼티처럼 접근자 메소드를 통해 자바 코드에 노출된다

## 메소드를 다른 클래스에 추가 : 확장 함수와 확장 프로퍼티
* 확장 함수는 기존 자바 API를 재작성하지 않고도 코틀린이 제공하는 여러 편리한 기능을 사용하게 해준다
* 확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 된다
* 클래스 이름을 수신 객체 타입이라 부르며, 확장 함수가 호출되는 대상이 되는 값을 수신 객체라고 부른다
* 수신 객체 타입은 확장이 정의될 클래스의 타입이며, 수신 객체는 그 클래스에 속한 인스턴스 객체이다
* 확장 함수 내부에서는 일반적인 인스턴스 메소드의 내부에서와 마찬가지로 수신 객체의 메소드나 프로퍼티를 바로 사용할 수 있다, 하지만 함수가 캡슐화를 깨지는 않는다
* 클래스 안에서 정의한 메소드와 달리 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 비공개 멤버나 보호된 멤버를 사용할 수 없다
* 클래스의 멤버 메소드와 확장 함수를 모두 메소드라고 부른다

### 임포트와 확장 함수
* 코틀린에서는 클래스를 임포트할 때와 동일한 구문을 사용해 개별 함수를 임포트 할 수 있다
* as 키워드를 사용하면 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다
* 한 파일 안에서 다른 여러 패키지에 속해있는 이름이 같은 함수를 가져와 사용해야 하는 경우 이름을 바꿔서 임포트하면 이름 충돌을 막을 수 있다
* 코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야 한다

### 자바에서 확장 함수 호출
* 내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드이다
* 확장 함수를 호출해도 다른 어댑터 객체나 실행 시점에 부가 비용이 들지 않는다

### 확장 함수로 유틸리티 함수 정의
* 확장 함수는 단지 정적 메소드 호출에 대한 문법적인 편의일 뿐이다
* 클래스가 아닌 더 구체적인 타입을 수신 객체 타입으로 지정할 수 있다
* 확장 함수가 정적 메소드와 같은 특징을 가지므로, 확장 함수를 하위 클래스에서 오버라이드 할 수는 없다

### 확장 함수는 오버라이드할 수 없다
* 코틀린의 메소드 오버라이드도 일반적인 객체지향의 메소드 오버라이드와 마찬가지이다, 하지만 확장 함수는 오버라이드할 수 없다 
* 동적 디스패치 : 실행 시점에 객체 타입에 따라 동적으로 호출될 대상 메소드를 결정하는 방식
* 정적 디스패치 : 컴파일 시점에 알려진 변수 타입에 따라 정해진 메소드를 호출하는 방식
* 확장 함수는 클래스의 일부가 아니다, 확장 함수는 클래스 밖에 선언된다
* 이름과 파라미터가 완전히 같은 확장 함수를 기반 클래스와 하위 클래스에 대해 정의해도 실제로는 확장 함수를 호출할 때 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출될지 결정될지, 그 변수에 저장된 객체의 동적인 타입에 의해 확장 함수가 결정되지 않는다
* 확장 함수를 첫 번째 인자가 수신 객체인 정적 자바 메소드로 컴파일한다는 사실을 기억해야 한다
* 어떤 클래스를 확장한 함수와 그 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 멤버 함수가 호출된다

### 확장 프로퍼티
* 확장 프로퍼티를 사용하면 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API를 추가할 수 있다
* 확장 프로퍼티는 아무 상태도 가질 수 없다, 하지만 프로퍼티 문법으로 더 짧게 코드를 작성할 수 있다
* 뒷받침하는 필드가 없어서 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의를 해야한다
* 초기화 코드에서 계산한 값을 담을 장소가 전혀 없으므로 초기화 코드도 쓸 수 없다

## 컬레션 처리 : 가변 길이 인자, 중위 함수 호출, 라이브러리 지원
* varargs 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다
* 중위 함수 호출 구문을 사용하면 인자가 하나뿐인 메소드를 간편하게 호출할 수 있다
* 구조 분해 선언을 사용하면 복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있다

### 자바 컬렉션 API 확장
* 코틀린 표준 라이블리는 수많은 확장 함수를 포함한다

### 가변 인자 함수 : 인자의 개수가 달라질 수 있는 함수 정의
* 리스트를 생성하는 함수를 호출할 때 원하는 만큼 많이 원소를 전달할 수 있다
* 가변 길이 인자는 메소드를 호출할 때 원하는 개수만큼 값을 인자로 넘기면 자바 컴파일러가 배열에 그 값들을 넣어주는 기능이다
* 코틀린에서는 파라미터 앞에 vararg 변경자를 붙이면 된다
* 자바에서는 배열을 그냥 넘기면 되지만 코틀린에서는 배열을 명시적으로 풀어서 배열의 각 원소가 인자로 전달되게 해야 한다 (기술적으로는 스프레드 연산자가 그런 작업을 해준다) 하지만 실제로는 전달하려는 배열 앞에 *를 붙이기만 하면 된다

### 값의 쌍 다루기 : 중위 호출과 구조 분해 선언
* to 라는 단어는 중위 호출이라는 특별한 방식으로 to라는 일반 메소드를 호출한 것이다, 인자가 하나뿐인 일반 메소드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다
* 함수를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수 선언 앞에 추가해야 한다
* 변수를 즉시 초기화하는 기능을 구조 분해 선언이라 한다
* to를 사용하면 타입과 관계없이 임의의 순서쌍을 만들 수 있다 (to 함수는 확장 함수다)

## 문자열과 정규식 다루기
* 코틀린 문자열은 자바 문자열과 같다

### 문자열 나누기
* 자바의 split 메소드는 빈 배열을 반환한다, split의 구분 문자열은 실제로는 정규식이다, 따라서 .는 모든 문자를 나타내는 정규식으로 해석된다
* 코틀린에서는 자바의 split 대신에 여러 가지 다른 조합의 파라미터를 받는 split 확장 함수를 제공함으로써 혼동을 야기하는 메소드를 감춘다
* 정규식을 파라미터로 받는 함수는 String 이 아닌 Regex 타입의 값을 받는다 (. 대신 -로 문자열을 분리한다)

### 정규식과 3중 따옴표로 묶은 문자열
* 경로 파싱을 구현하는 정규식 -> “디렉터리/파일 이름.확장자”
* 코틀린에서는 정규식을 사용하지 않고도 문자열을 쉽게 파싱할 수 있다
* “”” 디렉터리/파일 이름 \. 확장자 “””

### 여러 줄 3중 따옴표 문자열
* 줄 바꿈을 \n 과 같은 특수 문자를 사용해 넣을 수는 없다, 반면에 \를 문자열에 넣고 싶으면 이스케이프할 필요가 없다
* 3중 따옴표 문자열 안에 문자열 템플릿을 사용할 수도 있다
* 그러나 3중 따옴표 문자열 안에서는 이스케이프를 할 수 없기 때문에 문자열 템플릿의 시작을 표현하는 $를 3중 따옴표 문자열 안에 넣을 수 없다는 문제가 생긴다 (넣어야 한다면 {‘$’} 이런 형식으로 넣어야 한다)

## 코드 다듬기 : 로컬 함수와 확장
* 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다
* 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용할 수 있다
* 확장 함수를 로컬 함수로 정의할 수도 있다, 일반적으로는 한 단계만 함수를 중첩시키는 것을 권장한다

## 요약
* 코틀린은 자체 컬렉션 클래스를 정의하지 않지만 자바 클래스를 확장해서 더 풍부한 API를 제공한다
* 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의할 필요성이 줄어든다, 이름 붙인 인자를 사용하면 함수의 인자가 많을 때 함수 호출의 가독성을 더 향상시킬 수 있다
* 코틀린 파일에서 클래스 멤버가 아닌 최상위 함수와 프로퍼티를 직접 선언할 수 있다
* 확장 함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 호함해 모든 클래스의 API를 그 클래스의 소스코드를 바꿀 필요 없이 확장할 수 있다
* 중위 호출을 통해 인자가 하나 밖에 없는 메소드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다
* 코틀린은 정규식과 일반 문자열을 처리할 때 유용한 다양한 문자열 처리 함수를 제공한다
* 자바 문자열로 표현하려면 수많은 이스케이프가 필요한 문자열의 경우 3중 따옴표 문자열을 사용하면 더 깔끔하게 표현할 수 있다
* 로컬 함수를 써서 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있다