# Kotlin In Action_5
## 람다로 프로그래밍
* 람다 식과 멤버 참조
* 함수형 스타일로 컬렉션 다루기
* 시퀀스 : 지연 컬렉션 연산
* 자바 함수형 인터페이스를 코틀린에서 사용
* 수신 객체 지정 람다 사용

* 람다 식 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다
* 람다를 사용하면 쉽게 공통 코드 구조를 라이브러리 함수로 뽑아낼 수 있다
* 컬렉션을 처리할 때 람다를 자주 사용한다
* 수신 객체 지정 람다란 람다 선언을 둘러싸고 있는 환경과는 다른 상황에서 람다 본문을 실행할 수 있다

## 람다 식과 멤버 참조
### 람다 소개 : 코드 블록을 함수 인자로 넘기기
* 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택한다
* 클래스를 선언하고 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접 다른 함수에 전달할 수 있다
* 람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달할 수 있다

### 람다와 컬렉션
* 라이브러리 함수를 사용해야 한다
* 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있다
* 자바 컬렉션에 대해 수행하던 대부분의 작업은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선할 수 있다

### 람다 식의 문법
* 람다를 따로 선언해서 변수에 저장할 수도 있다 , 하지만 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다
* 코틀린 람다 식은 항상 중괄호로 둘러싸여 있다, 인자 목록 주변에 괄호가 없다는 사실을 기억해야한다 -> 가 인자 목록과 람다 본문을 구분해준다
* 람다 식을 변수에 저장할 수 있다, 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다
* run은 인자로 받은 람다를 실행해주는 라이브러리 함수다
* 실행 시점에 코틀린 람다 호출에는 아무 부가 비용이 들지 않으며, 프로그램의 기본 구성 요소와 비슷한 성능을 낸다
* 로컬 변수처럼 컴파일러는 람다 파라미터의 타입도 추론할 수 있다, 따라서 파라미터 타입을 명시할 필요가 없다
* 파라미터 중 일부의 타입은 지정하고 나머지 파라미터는 타입을 지정하지 않고 이름만 남겨둬도 된다
* 람다의 파라미터 이름을 디폴트 이름인 it으로 바꾸면 람다 식을 더 간단하게 만들 수 있다
* 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it을 바로 쓸 수 있다
* 람다 파라미터 이름을 따로 지정하지 않은 경우에만 it이라는 이름이 자동으로 만들어진다
* 람다 안에 람다가 중첩되는 경우 각 람다의 파라미터를 명시하는 편이 좋다, 또한 문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에도 파라미터를 명시적으로 선언하면 도움이 된다
* 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않는다, 따라서 파라미터 타입을 명시해야 한다
* 본문이 여러 줄로 이뤄진 경우 본문의 맨 마지막에 있는 식이 람다의 결과 값이 된다

### 현재 영역에 있는 변수에 접근
* 자바 메소드 안에서 무명 내부 클래스를 정의할 때 메소드의 로컬 변수를 무명 내부 클래스에서 사용할 수 있다, 람다 안에서도 같은 일을 할 수 있다
* 람다를 함수 안에서 정의하면 함수의 파라미터 뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다
* forEach는 컬렉션의 모든 원소에 대해 람다를 호출해준다
* 자바와 다른 점 중 중요한 한 가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다는 점이다
* 또한 람다 안에서 바깥의 변수를 변경해도 된다
* 코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있다
* 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다
* 기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다
* 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다
* 파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장하기 때문에 가능하다
* 람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다

### 멤버 참조
* 코틀린에서는 함수를 값으로 바꿀 수 있다 이때 이중 콜론을 사용한다 ::
* ::를 사용하는 식을 멤버 참조라고 부른다
* 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다
* ::는 클래스 이름과 참조하려는 멤버 이름 사이에 위치한다
* 참조 대상이 함수인지 프로퍼티인지와는 관계 없이 멤버 참조 뒤에는 괄호를 넣으면 안 된다
* 최상위에 선언된 함수나 프로퍼티를 참조할 수도 있다
* 람다가 인자가 여럿인 다른 함수한테 작업을 위임하는 경우 람다를 정의하지 않고 직접 위임 함수에 대한 참조를 제공하면 편리하다
* 생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다 :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다

### 컬렉션 함수형 API
* 함수형 프로그래밍 스타일을 사용하면 컬렉션을 다룰 때 편리하다, 대부분의 작업에 라이브러리 함수를 활용할 수 있고 그로 인해 코드를 아주 간결하게 만들 수 있다

### 필수적인 함수 : filter와 map
* filter 와 map 은 컬렉션을 활용할 때 기반이 되는 함수다, 대부분의 컬렉션 연산을 이 두 함수를 통해 표현할 수 있다
* filter 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다
* filter 함수는 컬렉션에서 원치 않는 원소를 제거한다
* map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다

### all, any, count, find : 컬렉션에 술어 적용
* 컬렉션에 대해 자주 수행하는 연산으로 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하는 연산이 all과 any이다
* count 함수는 조건을 만족하는 원소의 개수를 반환하며, find 함수는 조건을 만족하는 첫 번째 원소를 반환한다
* 술어를 만족하는 원소를 하나 찾고 싶으면 find 함수를 사용한다

### groupBy : 리스트를 여러 그룹으로 이뤄진 맵으로 변경
* groupBy : 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해주는 함수

### flatMap 과 flatten : 중첩된 컬렉션 안의 원소 처리
* flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다
* toList 함수를 문저열에 적용하면 그 문자열에 속한 모든 문자로 이뤄진 리스트가 만들어진다

## 지연 계산 컬렉션 연산
* filter 나 map은 결과 컬렉션을 즉시 생성한다
* 시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다
* 한 리스트는 filter의 결과를 담고, 다른 하나는 map의 결과를 담는다, 이를 더 효율적으로 만들기 위해서는 각 연산이 컬랙션을 직접 사용하는 대신 시퀀스를 사용하게 만들어야 한다
* 코틀린 지연 계산 스퀀스는 Sequence 인터페이스에서 시작한다
* Sequence 인터페이스의 강점은 필요할 때 비로소 계산되서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다
* asSequence 확장 함수를 호출하면 어떤 컬렉션이든 시퀀스로 바꿀 수 있다, 시퀀스를 리스트로 만들 때는 toList를 사용한다
* 시퀀스 원소를 인덱스를 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스트로 변환해야 한다
* 큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아야 한다

### 시퀀스 연산 실행 : 중간 연산과 최종 연산
* 시퀀스에 대한 연산은 중간 연산과 최종 연산으로 나눈다
* 증간 연산은 다른 시퀀스를 반환한다, 그 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 안다, 최종 연산은 결과를 반환한다
* 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다
* 중간 연산은 항상 지연 계산된다
* 시퀀스의 경우 모든 연산은 각 원소에 대해 순차적으로 적용된다
* 시퀀스를 사용하면 지연 계산으로 인해 원소 중 일부의 계산은 이뤄지지 않는다
* map을 먼저 하면 모든 원소를 반환한다, 하지만 filter 를 먼저 하면 부적절한 원소를 먼저 제외한다
* 시퀀스를 사용하면 find 호출이 원소를 하나씩 처리하기 시작한다

### 시퀀스 만들기
* 시퀀스를 사용하는 일반적인 용례 중 하나는 객체의 조상으로 이뤄진 시퀀스를 만들어내는 것이다
* 어떤 객체의 조상이 자신과 같은 타입이고 모든 조상의 시퀀스에서 어떤 특성을 알고 싶을 때 사용한다

## 자바 함수형 인터페이스 활용
* 코틀린 람다를 자바 API에 사용해도 아무 문제가 없다
* 코틀린에서는 무명 클래스 인스턴스 대신 람다를 넘길 수 있다
* 추상 메소드가 하나만 있는 메소드를 함수형 인터페이스 또는 SAM 인터페이스라고 한다
* SAM은 단일 추상 메소드 라는 뜻이다
* 코틀린은 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해준다

### 자바 메소드에 람다를 인자로 전달
* 함수형 인터페이스를 인자로 원하는 자바 메소드에 코틀린 람다를 전달할 수 있다
* 람다는 정의가 들어있는 함수의 변수에 접근하지 않는 람다에 대응하는 무명 객체를 모스드를 호출할 때마다 반복 사용한다
* 람다가 변수를 포획하면 무명 클래스 안에 포획한 변수를 저장하는 필드가 생기며, 매 호출마다 그 무명 클래스의 인스턴스를 새로 만든다

### SAM 생성자 : 람다를 함수형 인터페이스로 명시적으로 변경
* SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다
* 컴파일러가 자동으로 람다를 함수형 인터페이스 무명 클래스로 바꾸지 못하는 경우 SAM 생성자를 사용할 수 있다
* 함수형 인터페이스의 인스턴스를 반환하는 메소드가 있다면 람다를 직접 반환할 수 없고, 반환하고픈 람다를 SAM 생성자로 감싸야 한다
* SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다
* SAM 생성자는 그 함수형 인터페이스의 유일한 추상 메소드의 본문에 사용할 람다만을 인자로 받아서 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다
* 람다로 생성한 함수형 인터페이스 인스턴스를 변수에 저장해야 하는 경우에도 SAM 생성자를 사용할 수 있다
* 람다에는 무명 객체와 달리 인스턴스 자신을 가리키는 this가 없다
* 람다를 변환한 무명 클래스의 인스턴스를 참조할 방법이 없다
* 람다 안에서 this는 그 람다를 둘러싼 클래스의 인스턴스를 가리킨다
* 이벤트 리스너가 이벤트를 처리하다가 자기 자신의 리스너 등록을 해제해야 한다면 람다를 사용할 수 없다

## 수신 객체 지정 람다 : with 와 apply
### with 함수
* 어떤 객체의 이름을 반복하지 않고도 그 객체에 대해 다양한 연산을 수행할 수 있다면 좋다
* 파라미터가 2개 있는 함수다
* with 함수는 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다
* 인자로 받은 람다 본문에서는 this를 사용해 그 수신 객체에 접근할 수 있다
* 확장 함수 안에서 this는 그 함수가 확장하는 타입의 인스턴스이다 그리고 그 수신 객체 this의 멤버를 호출할 때는 this.를 생략할 수 있다

### apply 함수
* with와 비슷하다, 차이점은 항상 자신에게 전달된 객체를 반환한다는 것이다
* apply의 수신 객체가 전달받은 람다의 수신 객체가 된다
* apply 함수는 객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우 유용하다
* 자바에서는 보통 별도의 Builder 객체가 이런 역할을 담당한다

## 요약
* 람다를 사용하면 코드 조각을 다른 함수에게 인자로 넘길 수 있다
* 코틀린에서는 람다가 함수 인자인 경우 괄호 밖으로 람다를 빼낼 수 있고, 람다의 인자가 단 하나뿐인 경우 인자 이름을 지정하지 않고 it이라는 디폴트 이름으로 부를 수 있다
* 람다 안에 있는 코드는 그 람다가 들어있는 바깥 함수의 변수를 읽거나 쓸 수 있다
* 메소드, 생성자, 프로퍼티의 이름 앞에 :: 을 붙이면 각각의 대한 참조를 만들 수 있다, 그런 참조를 람다 대신 다른 함수에게 넘길 수 있다
* 시퀀스를 사용하면 중간 결과를 담는 컬렉션을 생성하지 않고도 컬렉션에 대한 여러 연산을 조합할 수 있다
* 함수형 인터페이스를 인자로 받는 자바 함수를 호출할 경우 람다를 함수형 인터페이스 인자 대신 넘길 수 있다
* 수신 객체 지정 람다를 사용하면 람다 안에서 미리 정해둔 수신 객체의 메소드를 직접 호출할 수 있다
* 표준 라이브러리의 with 함수를 사용하면 어떤 객체에 대한 참조를 반복해서 언급하지 않으면서 그 객체의 메소드를 호출할 수 있다, apply를 사용하면 어떤 객체라도 빌더 스타일의 API를 사용해 생성하고 초기화할 수 있다