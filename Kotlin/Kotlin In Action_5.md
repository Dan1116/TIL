# Kotlin In Action_5
## 람다로 프로그래밍
* 람다 식과 멤버 참조
* 함수형 스타일로 컬렉션 다루기
* 시퀀스 : 지연 컬렉션 연산
* 자바 함수형 인터페이스를 코틀린에서 사용
* 수신 객체 지정 람다 사용

* 람다 식 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다
* 람다를 사용하면 쉽게 공통 코드 구조를 라이브러리 함수로 뽑아낼 수 있다
* 컬렉션을 처리할 때 람다를 자주 사용한다
* 수신 객체 지정 람다란 람다 선언을 둘러싸고 있는 환경과는 다른 상황에서 람다 본문을 실행할 수 있다

## 람다 식과 멤버 참조
### 람다 소개 : 코드 블록을 함수 인자로 넘기기
* 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택한다
* 클래스를 선언하고 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접 다른 함수에 전달할 수 있다
* 람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달할 수 있다

### 람다와 컬렉션
* 라이브러리 함수를 사용해야 한다
* 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있다
* 자바 컬렉션에 대해 수행하던 대부분의 작업은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선할 수 있다

### 람다 식의 문법
* 람다를 따로 선언해서 변수에 저장할 수도 있다 , 하지만 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다
* 코틀린 람다 식은 항상 중괄호로 둘러싸여 있다, 인자 목록 주변에 괄호가 없다는 사실을 기억해야한다 -> 가 인자 목록과 람다 본문을 구분해준다
* 람다 식을 변수에 저장할 수 있다, 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다
* run은 인자로 받은 람다를 실행해주는 라이브러리 함수다
* 실행 시점에 코틀린 람다 호출에는 아무 부가 비용이 들지 않으며, 프로그램의 기본 구성 요소와 비슷한 성능을 낸다
* 로컬 변수처럼 컴파일러는 람다 파라미터의 타입도 추론할 수 있다, 따라서 파라미터 타입을 명시할 필요가 없다
* 파라미터 중 일부의 타입은 지정하고 나머지 파라미터는 타입을 지정하지 않고 이름만 남겨둬도 된다
* 람다의 파라미터 이름을 디폴트 이름인 it으로 바꾸면 람다 식을 더 간단하게 만들 수 있다
* 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it을 바로 쓸 수 있다
* 람다 파라미터 이름을 따로 지정하지 않은 경우에만 it이라는 이름이 자동으로 만들어진다
* 람다 안에 람다가 중첩되는 경우 각 람다의 파라미터를 명시하는 편이 좋다, 또한 문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에도 파라미터를 명시적으로 선언하면 도움이 된다
* 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않는다, 따라서 파라미터 타입을 명시해야 한다
* 본문이 여러 줄로 이뤄진 경우 본문의 맨 마지막에 있는 식이 람다의 결과 값이 된다

### 현재 영역에 있는 변수에 접근
* 자바 메소드 안에서 무명 내부 클래스를 정의할 때 메소드의 로컬 변수를 무명 내부 클래스에서 사용할 수 있다, 람다 안에서도 같은 일을 할 수 있다
* 람다를 함수 안에서 정의하면 함수의 파라미터 뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다
* forEach는 컬렉션의 모든 원소에 대해 람다를 호출해준다
* 자바와 다른 점 중 중요한 한 가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다는 점이다
* 또한 람다 안에서 바깥의 변수를 변경해도 된다
* 코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있다
* 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다
* 기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다
* 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다
* 파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장하기 때문에 가능하다
* 람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다

### 멤버 참조
* 코틀린에서는 함수를 값으로 바꿀 수 있다 이때 이중 콜론을 사용한다 ::
* ::를 사용하는 식을 멤버 참조라고 부른다
* 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다
* ::는 클래스 이름과 참조하려는 멤버 이름 사이에 위치한다
* 참조 대상이 함수인지 프로퍼티인지와는 관계 없이 멤버 참조 뒤에는 괄호를 넣으면 안 된다
* 최상위에 선언된 함수나 프로퍼티를 참조할 수도 있다
* 람다가 인자가 여럿인 다른 함수한테 작업을 위임하는 경우 람다를 정의하지 않고 직접 위임 함수에 대한 참조를 제공하면 편리하다
* 생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다 :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다

### 컬렉션 함수형 API
* 함수형 프로그래밍 스타일을 사용하면 컬렉션을 다룰 때 편리하다, 대부분의 작업에 라이브러리 함수를 활용할 수 있고 그로 인해 코드를 아주 간결하게 만들 수 있다

### 필수적인 함수 : filter와 map
* filter 와 map 은 컬렉션을 활용할 때 기반이 되는 함수다, 대부분의 컬렉션 연산을 이 두 함수를 통해 표현할 수 있다
* filter 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다
* filter 함수는 컬렉션에서 원치 않는 원소를 제거한다
* map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다

### all, any, count, find : 컬렉션에 술어 적용
* 컬렉션에 대해 자주 수행하는 연산으로 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하는 연산이 all과 any이다
* count 함수는 조건을 만족하는 원소의 개수를 반환하며, find 함수는 조건을 만족하는 첫 번째 원소를 반환한다
* 술어를 만족하는 원소를 하나 찾고 싶으면 find 함수를 사용한다

### groupBy : 리스트를 여러 그룹으로 이뤄진 맵으로 변경
* groupBy : 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해주는 함수

### flatMap 과 flatten : 중첩된 컬렉션 안의 원소 처리
* flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다
* toList 함수를 문저열에 적용하면 그 문자열에 속한 모든 문자로 이뤄진 리스트가 만들어진다

## 지연 계산 컬렉션 연산
* filter 나 map은 결과 컬렉션을 즉시 생성한다
* 시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다
* 한 리스트는 filter의 결과를 담고, 다른 하나는 map의 결과를 담는다, 이를 더 효율적으로 만들기 위해서는 각 연산이 컬랙션을 직접 사용하는 대신 시퀀스를 사용하게 만들어야 한다
* 