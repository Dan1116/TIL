# Kotlin In Action_4
## 클래스, 객체, 인터페이스
* 클래스와 인터페이스
* 뻔하지 않은 생성자와 프로퍼티
* 데이터 클래스
* 클래스 위임
* object 키워드 사용

* 코틀린의 인터페이스에 프로퍼티 선언이 들어갈 수 있다
* 코틀린의 선언은 기본적으로 final이며 public이다
* 중첩 클래스는 기본적으로는 내부 클래스가 아니다, 즉 코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다
* 짧은 주 생성자 구문으로도 거의 모든 경우를 잘 처리할 수 있다
* 간결한 프로퍼티 구문으로도 충분히 제 몫을 하지만, 필요하면 접근자를 직접 정의할 수 있다
* 코틀린 컴파일러는 번잡스러움을 피하기 위해 유용한 메소드를 자동으로 만들어준다
* 클래스를 data로 선언하면 컴파일러가 일부 표준 메소드를 생성해준다
* 코틀린 언어가 제공하는 위임을 사용하면 위임을 처리하기 위한 준비 메소드를 직접 작성할 필요가 없다

## 클래스 계층 정의
* 코틀린 가시성/접근 변경자는 자바와 비슷하지만 아무것도 지정하지 않은 경우 기본 가시성은 다르다
*  sealed는 클래스 상속을 제한한다

### 코틀린 인터페이스
* 코틀린 인터페이스 안에는 추상 메소드뿐 아니라 구현이 있는 메소드도 정의할 수 있다
* 인터페이스는 아무런 상태도 들어갈 수 없다
* 코틀린에서 클래스는 class로 정의하지만 인터페이스는 interface를 사용한다
* 코틀린에서는 클래스 이름 뒤에 콜론 : 을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다
* 인터페이스는 원하는 만큼 개수 제한 없이 마음대로 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다
* 코틀린에서는 override 변경자를 꼭 사용해야 한다
* override 변경자는 실수로 상위 클래스의 메소드를 오버라이드하는 경우를 방지해준다
* 인터페이스 메소드도 디폴트 구현을 제공할 수 있다

### open, final, abstract 변경자 : 기본적으로 final
* 취약한 기반 클래스라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 발생한다
* 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도나 다른 방식으로 메소드를 오버라이드할 위험이 있다
* 어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다
* 오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙여야 한다
* 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메소드는 기본적으로 열려있다
* 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final을 명시해야 한다
* 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용이 가능하다
* 클래스 프로퍼티의 경우 이는 val이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 쓸 수 있다는 의미이다 (프로퍼티가 final이어야만 한다)
* 코틀린에서도 클래스를 abstract로 선언할 수 있다, 이 추상 클래스는 인스턴스화할 수 없다
* 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드해야만 하는 게 보통이다
* 인터페이스 멤버의 경우 final, open, abstract를 사용하지 않는다
* 인터페이스 멤버는 항상 렬려 있으며 final로 변경할 수 없다
* 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 되지만, 그렇더라도 따로 멤버 선언 앞에 abstract 키워드를 덧붙일 필요가 없다
* abstract 은 반드시 오버라이드 해야한다

### 가시성 변경자 : 기본적으로 공개
* 가시성 변경자는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다
* 어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다
* 코틀린의 기본 가시성은 아무 변경자도 없는 경우 선언은 모두 공개 (public) 된다
* 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다
* 패키지 전용 가시성에 대한 대안으로 코틀린에는 internal 이라는 새로운 가시성 변경자를 도입했다
* internal은 모듈 내부에서만 볼 수 있음이라는 뜻이다, 모듈은 한 번에 한꺼번에 컴파일 되는 코틀린 파일들을 의미한다
* 모듈 내부 가시성은 여러분의 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다
* 코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다
* 최상위 선언에는 클래스, 함수, 프로퍼티 등이 포함된다

* public - 모든 곳에서 볼 수 있다
* internal - 같은 모듈 안에서만 볼 수 있다
* protected - 하위 클래스 안에서만 볼 수 있다
* private - 같은 클래스 안에서만 볼 수 있다 (같은 파일 안에서만 볼 수 있다)

* 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 하고, 메소드의 시그니처에 사용된 모든 타입의 가시성은 그 메소드의 가시성과 같거나 더 높아야 한다는 더 일반적인 규칙에 해당한다 (이런 규칙은 어떤 함수를 호출하거나 어떤 클래스를 확장할 때 필요한 모든 타입에 접근할 수 있게 보장해준다)
* 코틀린의 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다
* 클래스를 확장한 함수는 그 클래스의 private 나 protected 멤버에 접근할 수 없다
* 코틀린의 public, protected, private 변경자는 컴파일된 자바 바이트코드 안에서도 그대로 유지된다
* 코틀린은 private 클래스를 패키지-전용 클래스로 컴파일한다
* internal 변경자는 바이트코드상에서는 public 이 된다
* 코틀린과 자바 가시성 규칙의 또 다른 차이는 코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다는 점이다

### 내부 클래스와 중첩된 클래스 : 기본적으로 중첩 클래스
* 코틀린에서도 클래스 안에 다른 클래스를 선언할 수 있다
* 클래스 안에 다른 클래스를 선언하면 도우미 클래스를 캡슐화하거나 코드 정의를 그 코드를 사용하는 곳 가까이에 두고 싶을 때 유용하다
* 자바와의 차이점은 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다는 점이다
* 자바에서 중첩 클래스를 static 으로 선언하면 그 클래스를 둘러싼 바깥쪽 클래스에 대한 묵시적인 참조가 사라진다
* 코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다
* 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 inner 변경자를 붙이면 된다

### 봉인된 클래스 : 클래스 계층 정의 시 계층 확장 제한
* 코틀린 컴파일러는 when을 사용해 Expr 타입의 값을 검사할 때 꼭 디폴트 분기인 else 분기를 덧붙이도록 강제한다
* 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다
* sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다
* when 식에서 sealed 클래스의 모든 하위 클래스를 처리한다면 디폴트 분기가 필요 없다
* sealed로 표기된 클래스는 자동으로 open임을 기억하라
* sealed 클래스에 속한 값에 대해 디폴트 분기를 사용하지 않고 when 식을 사용하면 나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 when 식이 컴파일되지 않는다
* 내부적으로 Expr 클래스는 private 생성자를 가진다, 그 생성자는 클래스 내부에서만 호출이 가능하다 (sealed 인터페이스를 정의할 수 없다) 

## 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언
* 코틀린은 주 생성자와 부 생성자를 구분한다
* 코틀린에서는 초기화 블록을 통해 초기화로직을 추가할 수 있다

### 클래스 초기화 : 주 생성자와 초기화 블록
* 보통 클래스의 모든 선언은 중괄호 {} 사이에 들어간다, 하지만 이 클래스 선언에는 중괄호가 없고 괄호 사이에 val 선언만 존재한다
* 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 주 생성자라고 부른다
* 주 생성자는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다
* constructor 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용한다
* init 키워드는 초기화 블록을 시작한다
* 초기화 블록은 주 생성자와 함께 사용된다, 주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록이 필요하다, 클래스 안에 여러개의 초기화 블록을 생성할 수도 있다
* 주 생성자 앞에 별다른 애노테이션이나 가시성 변경자가 없다면 constructor를 생략해도 된다
* 프로퍼티를 초기화하는 식이나 초기화 블록 안에서만 주 생성자의 파라미터를 참조할 수 있다
* 함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 정의할 수 있다
* 클래스의 인스턴스를 만들려면 new 키워드 없이 생성자를 직접 호출하면 된다
* 모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다
* 자동으로 만들어진 파라미터 없는 생성자는 디폴트 값을 사용해 클래스를 초기화한다
* 기반 클래스를 초기화하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다
* 클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다
* 인터페이스는 생성자가 없기 때문에 어떤 클래스가 인터페이스를 구현하는 경우 그 클래스의 상위 클래스 목록에 있는 인터페이스 이름 뒤에는 아무 괄호도 없다
* 클래스 정의에 있는 상위 클래스 및 인터페이스 목록에서 이름 뒤에 괄호가 붙었는지 살펴보면 쉽게 기반 클래스와 인터페이스를 구별할 수 있다
* 어떤 클래스를 클래스외부에서 인스턴스화하지 못하게 막고싶다면 모든 생성자를 private으로 만들면 된다
* 유틸리티 함수를 담아두는 역할만을 하는 클래스는 인스턴스화할 필요가 없고, 싱글턴인 클래스는 미리 정한 팩토리 메소드 등의 생성 방법을 통해서만 객체를 생성해야 한다

### 부 생성자 : 상위 클래스를 다른 방식으로 초기화
* 인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말라, 대신 파라미터의 디폴트 값을 생성자 시그니처에 직접 명시하라
* 클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다
* 부 생성자가 필요한 주된 이유는 자바 상호운용성이다
* 클래스 인스턴스를 생성할 때 파라미터 목록이 다른 생성 방법이 여럿 존재하는 경우에는 부 생성자를 여럿 둘 수밖에 없다

### 인터페이스에 선언된 프로퍼티 구현
* 코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다
* 인터페이스는 아무 상태도 포함할 수 없으므로 상태를 저장할 필요가 있다면 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 한다
* 인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수 있다, 물론 그런 게터와 세터는 뒷받침하는 필드를 참조할 수 없다

### 게터와 세터에서 뒷받침하는 필드에 접근
* 접근자의 본문에서는 field 라는 특별한 식별자를 통해 뒷받침하는 필드에 접근할 수 있다
* 게터에서는 field 값을 읽을 수만 있고 세터에서는 값을 읽거나 쓸 수 있다
* 변경 가능 프로퍼티의 게터와 세터 중 한 쪽만 직접 정의해도 된다

### 접근자의 가시성 변경
* 접근자의 가시성은 기본적으로는 프로퍼티의 가시성과 같다
* latent = 변경자를 널이 될 수 없는 프로퍼티에 지정하면 프로퍼티를 생성자가 호출된 다음에 초기화한다는 뜻이다
* 요청이 들어오면 비로소 초기화되는 지연 초기화 프로퍼티는 더 일반적인 위임 프로퍼티의 일종이다

## 컴파일러가 생성한 메소드 : 데이터 클래스와 클래스 위임
* 자바에서는 클래스가 equals, hashCode, toString 등의 메소드를 구현해야 한다
* 코틀린은 이런 메소드를 기계적으로 생성하는 작업을 보이지 않는 곳에서 해준다

### 모든 클래스가 정의해야 하는 메소드
* 코틀린 클래스도 equals, hashCode, toString 등을 오버라이드할 수 있다

### 문자열 표현 : toString()
* 인스턴스의 문자열 표현을 얻을 방법을 제공한다
* 주로 디버깅과 로깅 시 이 메소드를 사용한다

### 객체의 동등성 : equals()
* Client 클래스를 사용하는 모든 계산은 클래스 밖에서 이뤄진다, Client는 단지 데이터를 저장할 뿐이며, 그에 따라 구조도 단순하고 내부 정보를 투명하게 외부에 노출하게 설계됐다
* 동등성 연산에 ==를 사용함, 코틀린에서 ==는 내부적으로 equals 를 호출해서 객체를 비교한다, 따라서 클래스가 equals 를 오버라이드하면 ==를 통해 안전하게 그 클래스의 인스턴스를 비교할 수 있다, 참조 비교를 위해서는  == 연산자를 사용할 수 있다
* 코틀린의 is 검사는 자바의 instanceof 와 같다, 어떤 값의 타입을 검사한다

### hashCode()
* 자바에서는 equals 를 오버라이드할 때 반드시 hashCode도 함께 오버라이드해야한다

### 데이터 클래스 : 모든 클래스가 정의해야 하는 메소드 자동 생성
* data라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다

### 데이터 클래스와 불변성 : copy() 메소드
* 객체를 메모리상에서 직접 바꾸는 대신 복사본을 만든는 편이 더 좋다

### 클래스 위임 : by 키워드 사용
* 데코레이터 패턴의 핵싱은 상속을 허용하지 않는 클래스 대신 사용할 수 있는 새로운 클래스를 만들되 기존 클래스와 같은 인터페이스를 데코레이터가 제공하게 만들고, 기존 클래스를 데코레이터 내부에 필드로 유지하는 것이다, 이때 새로 정의해야 하는 기능은 데코레이터의 메소드에 새로 정의하고 기존 기능이 그대로 필요한 부분은 데코레이터의 메소드가 기존 클래스의 메소드에게 요청을 전달한다
* 데코레이터 패턴의 단점은 준비 코드가 상당히 많이 필요하다는 것이다
* 인터페이스를 구현할 때 by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다
* 메소드 중 일부의 동작을 변경하고 싶은 경우 메소드를 오버라이드하면 컴파일러가 생성한 메소드 대신 오버라이드한 메소드가 쓰인다, 기존 클래스의 메소드에 위임하는 기본 구현으로 충분한 메소드는 따로 오버라이드할 필요가 없다

## object 키워드 : 클래스 선언과 인스턴스 생성
* object 키워드는 클래스를 정의하면서 동시에 인스턴스를 생성한다
* 객체 선언은 싱글턴을 정의하는 방법 중 하나이다
* 동반 객체는 인스턴스 메소드는 아니지만 어떤 클래스와 관련 있는 메소드와 팩토리 메소드를 담을 때 쓰인다, 동반 객체 메소드에 접근할 때는 동반 객체가 포함된 클래스의 이름을 사용할 수 있다
* 객체 식은 자바의 무명 내부 클래스 대신 쓰인다

### 객체 선언 : 싱글턴을 쉽게 만들기
* 코틀린은 객체 선언 기능을 통해 싱글턴을 언어에서 기본 지원한다, 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다
* 객체 선언은 object 키워드로 시작한다, 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한문장으로 처리한다
* 클래스와 마찬가지로 객체 선언 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어갈 수 있지만, 생성자는 객체 선언에 쓸 수 없다
* 일반 클래스 인스턴스와 달리 싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어 짐으로 생성자 정의가 필요 없다
* 변수와 마찬가지로 객체 선언에 사용한 이름 뒤에 마침표를 붙이면 객체에 속한 메소드나 프로퍼티에 접근할 수 있다
* 객체 선언도 클래스나 인스턴스를 상속할 수 있다, 프레임워크를 사용하기 위해 특정 인터페이스를 구현해야 하는데, 그 구현 내부에 다른 상태가 필요하지 않은 경우에 이런 기능이 유용하다
* 대규모 컴포넌트에는 싱글턴이 적합하지 않다 객체 생성을 제어할 방법이 없고 생성자 파라미터를 지정할 수 없기 때문이다
* 클래스 안에서 객체를 선언할 수도 있다 , 그런 객체도 인스턴스는 단 하나뿐이다
* 코틀린 객체 선언은 유일한 인스턴스에 대한 정적인 필드가 있는 자바 클래스로 컴파일된다, 이때 인스턴스 필드의 이름은 항상 INSTANCE 이다

### 동반 객체 : 팩토리 메소드와 정적 멤버가 들어갈 장소
* 코틀린 클래스 안에는 정적인 멤버가 없다, 코틀린 언어는 자바 static 키워드를 지원하지 않는다, 대신 코틀린에서는 패키지 수준의 최상위 함수와 객체 선언을 활용한다
* 클래스 안에 정의된 객체 중 하나에 companion 이라는 특별한 표시를 붙이면 그 클래스의 동반 객체로 만들 수 있다
* 동반 객체의 프로퍼티나 메소드에 접근하려면 그 동반 객체가 정의된 클래스 이름을 사용한다, 이때 객체의 이름을 따로 지정할 필요가 없다
* 동반 객체의 멤버를 사용하는 구문은 자바의 정적 메소드 호출이나 정적 필드 사용 구문과 같아진다
* 동반 객체는 자신을 둘러싼 클래스의  모든 private 멤버에 접근할 수 있다
* 따라서 동반 객체는 바깥쪽 클래스의 private 생성자도 호출할 수 있다, 그러므로 동반 객체는 팩토리 패턴을 구현하기 가장 적합한 위치다
* 클래스 이름을 사용해 그 클래스에 속한 동반 객체의 메소드를 호출할 수 있다
* 팩토리 메소드는 그 팩토리 메소드가 선언된 클래스의 하위 클래스 객체를 반환할 수도 있다
* 클래스를 확장해야만 하는 경우에는 동반 객체 멤버를 하위 클래스에서 오버라이드 할 수 없으므로 여러 생성자를 사용하는 편이 더 나은 해법이다

### 동반 객체를 일반 객체처럼 사용
* 동반 객체는 클래스 안에 정의된 일반 객체다, 따라서 동반 객체에 이름을 붙이거나, 동반 객체가 인터페이스를 상속하거나, 동반 객체 안에 확장 함수와 프로퍼티를 정의할 수 있다
* 클래스 이름을 통해 객체에 속한 멤버를 참조할 수 있으므로 객체의 이름을 짓느라 고심할 필요가 없다

### 동반 객체에서 인터페이스 구현
* 다른 객체 선언과 마찬가지로 동반 객체도 인터페이스를 구현할 수 있다
* 클래스의 동반 객체는 일반 객체와 비슷한 방식으로 클래스에 정의된 인스턴스를 가리키는 정적 필드로 컴파일 된다
* 동반 객체에 이름을 붙이지 않았다면 자바 쪽에서 Companion이라는 이름으로 그 참조에 접근할 수 있다, 동반 객체에게 일므을 붙였다면 Companion 대신 그 이름을 쓴다
* 자바에서 사용하기 위해 코틀린 클래스의 멤버를 정적인 멤버로 만들어야 할 필요가 있다, @JvmStatic 애노테이션을 코틀린 멤버에 붙이면 된다
* 정적 필드가 필요하다면 @JvmField 애노테이션을 최상위 프로퍼티나 객체에서 선언된 프로퍼티 앞에 붙인다

### 동반 객체 확장
* 클래스에 동반 객체가 있으면 그 객체 안에 함수를 정의함으로써 클래스에 대해 호출할 수 있는 확장 함수를 만들 수 있다
* 동반 객체에 대한 확장 함수를 작성할 수 있으려면 원래 클래스에 동반 객체를 꼭 선언해야 한다

### 객체 식 : 무명 내부 클래스를 다른 방식으로 작성
* 무명 객체를 정의할 때도 object 키워드를 쓴다, 무명 객체는 자바의 무명 내부 클래스를 대신한다
* 객체 식은 클래스를 정의하고 그 클래스에 속한 인스턴스를 생성하지만, 그 클래스나 인스턴스에 이름을 붙이지는 않는다, 이런 경우 보통 함수를 호출하면서 인자로 무명 객체를 넘기기 떄문에 클래스와 인스턴스 모두 이름이 필요하지 않다
* 이름을 붙여야 한다면 변수에 무명 객체를 대입하면 된다
* 한 인터페이스만 구현하거나 한 클래스만 확장할 수 있는 자바의 무명 내부 클래스와 달리 코틀린 무명 클래스는 여러 인터페이스를 구현하거나 클래스를 확장하면서 인터페이스를 구현할 수 있다
* 객체 선언과 달리 무명 객체는 싱글턴이 아니다, 객체 식이 쓰일 때 마다 새로운 인스턴스가 생성된다
* 자바의 무명 클래스와 같이 객체 식 안의 코드는 그 식이 포함된 함수의 변수에 접근할 수 있다, 하지만 자바와 달리 final이 아닌 변수도 객체 식 안에서 사용할 수 있다
* 객체 식 안에서 그 변수의 값을 변경할 수 있고 어떤 윈도우가 호출된 횟수를 리스너에서 누적하게 만들 수 있다
* 객체 식은 무명 객체 안에서 여러 메소드를 오버라이드해야 하는 경우에 유용하다
* 메소드가 하나뿐인 인터페이스를 구현해야 한다면 코틀린의 SAM 변환 지원을 활용하는 편이 좋다
* SAM 변환을 사용하려면 무명 객체 대신 함수 리터럴을 사용해야 한다

## 요약
* 코틀린의 인터페이스는 자바 인터페이스와 비슷하지만 디폴트 구현을 포함할 수 있고 프로퍼티도 포함할 수 있다
* 모든 코틀린 선언은 기본적으로 final이며 public 이다
* 선언이 final이 되지 않게 만들려면 앞에 open을 붙여야한다
* internal 선언은 같은 모듈 안에서만 볼 수 있다
* 중첩 클래스는 기본적으로 내부 클래스가 아니다, 바깥쪽 클래스에 대한 참조를 중첩 클래스 안에 포함시키려면 inner 키워드를 중첩 클래스 선언 앞에 붙여서 내부 클래스로 만들어야 한다
* sealed 클래스를 상속하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩 클래스로 정의해야 한다
* 초기화 블록과 부 생성자를 활용해 클래스 인스턴스를 더 유연하게 초기화할 수 있다
* field 식별자를 통해 프로퍼티 접근자 안에서 프로퍼티의 데이터를 저장하는 데 쓰이는 뒷받침하는 필드를 참조할 수 있다
* 데이터 클래스를 사용하면 컴파일러가 equals, hashCode, toString, copy 등의 메소드를 자동으로 생성해준다
* 클래스 위임을 사용하면 코틀린답게 싱글턴 클래스를 정의할 수 있다
* 동반 객체는 자바의 정적 메소드와 필드 정의를 대신한다
* 동반 객체도 다른 객체와 마찬가지로 인터페이스를 구현할 수 있다, 외부에서 동반 객체에 대한 확장 함수와 프로퍼티를 정의할 수 있다
* 코틀린의 객체 식은 자바의 무명 내부 클래스를 대신한다, 하지만 코틀린 객체식은 여러 인스턴스를 구현하거나 객체가 포함된 영역에 있는 변수의 값을 변경할 수 있는 등 자바 무명 내부 클래스보다 더 많은 기능을 제공한다