# Kotlin In Action_6
# 코틀린 타입 시스템
* 널이 될 수 있는 타입과 널을 처리하는 구문의 문법
* 코틀린 원시 타입 소개와 자바 타입과 코틀린 원시 타입의 관계
* 코틀린 컬렉션 소개와 자바 컬렉션과 코틀린 컬렉션의 관계
* 자바와 비교하면 코틀린의 타입 시스템은 코드의 가독성을 향상시키는 데 도움이 되는 몇 가지 특성을 새로 제공한다

## 널 가능성
* 널 가능성은 NullPointerException 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다
* 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다
* 널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다

### 널이 될 수 있는 타입
* 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다
* 코틀린은 변수나 식의 값이 실행 시점에 null이 될 수 있는 경우를 모두 포함한다
* 함수가 널과 문자열을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표를 명시해야 한다
* 어떤 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다
* 물음표가 없는 타입은 그 변수가 null 참조를 저장할 수 없다는 뜻이다
* 널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다
* 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다
* 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다

### 타입의 의미
* 타입은 분류로 어떤 값들이 가능한지와 그 탕비에 대해 수행할 수 있는 연산의 종류를 결정한다
* 자바에서는 애노테이션을 사용해 값이 널이 될 수 있는지 여부를 표시하거나, Optional을 사용해서 NullPointerException 오류를 다루지만 코드가 더 지저분해지고 래퍼가 추가됨에 따라 실행 시점에 성능이 저하되며 전체 에코시크템에서 일관성 있게 활용하기 어렵다
* 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다
* 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다, 모든 검사는 컴파일 시점에 수행된다
* 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다

### 안전한 호출 연산자 : ?.
* 코틀린이 제공하는 가장 유용한 도구 중 하나가 안전한 호출 연사자인 ?. 이다
* ?.은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다
* 호출하려는 값이 null이 아니라면 ?. 은 일반 메소드 호출처럼 작동한다
* 호출하려는 값이 null이면 이 호출은 무시되고 null이 결과 값이 된다
* 안전한 호출의 결과 타입도 널이 될 수 있는 타입이다
* 메소드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다
* 객체 그래프에서 널이 될 수 있는 중간 객체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편할 때가 자주 있다

### 엘비스 연산자 : ?:
* 코틀린은 null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공한다
* 이 연산자는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다
* 엘비스 연산자를 객체가 널인 경우 널을 반환하는 안전한 호출 연산자와 함께 사용해서 객체가 널인 경우에 대비한 값을 지정하는 경우도 많다
* 코틀린에서는 return이나 throw 등의 연산도 식이다

### 안전한 캐스트 : as?
* as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다
* as?는 값을 대상 타입으로 변환할 수 없으면 null을 반환한다
* 안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다

### 널 아님 단언: !!
* 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구다
* 느낌표를 이중으로 사용하면 어떤 값이든 널이 될 수 없는 타입으로 바꿀 수 있다
* !!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다
* 어떤 값이 널이었는지 확실히 하기 위해 여러 !! 단언문을 한 줄에 함께 쓰는 일을 피하라

### let 함수
* let 함수를 사용하면 널이 될 수 있는 식을 쉽게 다룰 수 있다
* let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사요여해 한꺼번에 처리할 수 있다
* let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘기는 경우다
* let 함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다, 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 let을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let에 전달한다
* 아주 긴 식이 있고 그 값이 널이 아닐 때 수행해야 하는 로직이 있을 때 let을 쓰면 좋다
* 여러 값이 널인지 검사해야 한다면 let 호출을 중첩시켜서 처리할 수 있다, 하지만 코드가 복잡해 질 수 있으므로, if를 사용해 모든 값을 한번에 검사하는 편이 좋다

### 나중에 초기화할 프로퍼티
* 코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메소드 안에서 초기화할 수는 없다
* 코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다
* lateinit 변경자를 사용하면 프로퍼티를 나중에 초기화할 수 있다
* 나중에 초기화하는 프로퍼티는 항상 var이여야 한다
* val 프로퍼티는 final 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야 한다
* 나중에 초기화하는 프로퍼티는 널이 될 수 없는 타입이라 해도 더 이상 생성자 안에서 초기화할 필요가 없다

### 널이 될 수 있는 타입 확장
* 널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다
* 메소드를 호출하기 전에 수신 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신, 직접 변수에 대해 메소드를 호출해도 확장 함수인 메소드가 알아서 널 처리를 해준다, 이런 처리는 확장 함수에서만 가능하다
* 안전한 호출 없이도 널이 될 수 있는 수신 객체 타입에 대해 선언된 확장 함수를 호출 가능하다
* 널이 될 수 있는 타입에 대한 확장을 정의하면 널이 될 수 있는 값에 대해 그 확장 함수를 호출 할 수 있다, 그 함수의 내부에서 this는 널이 될 수 있다
* 자바에서는 메소드 안의 this는 그 메소드가 호출된 수신 객체를 가리키므로 항상 널이 아니다
* let 은 this 가 널인지 검사하지 않는다, 널이 될 수 있는 타입의 값에 대해 안전한 호출을 사용하지 않고 let을 호출하면 람다의 인자는 널이 될 수 있는 타입으로 추론된다
* let을 사용할 때 수신 객체가 널이 아닌지 검사하고 싶다면 ?.을 사용해야 한다
* 널이 될 수 없는 타입에 대한 확장 함수를 정의하고, 나중에 대부분 널이 될 수 있는 타입에 대해 함수를 호출했다면 안전하게 그 확장 함수를 널이 될 수 있는 타입에 대한 확장 함수로 바꿀 수 있다

### 타입 파라미터의 널 가능성
* 코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다
* 널이 될 수 있는 타입을 포함하는 어떤 타입이라도 타입 파라미터를 대신할 수 있다
* 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다
* 타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야 한다
* 널이 될 수 없는 타입 상한을 지정하면 널이 될 수 있는 값을 거부하게 된다
* 타입 파라미터는 널이 될 수 있는 타입을 표시하려면 반드시 물음표를 타입 이름 뒤에 붙여야 한다는 규칙의 유일한 예외이다

### 널 가능성과 자바
* 코틀린은 여러 널 가능성 애노테이션을 알아본다

### 플랫폼 타입
* 플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다
* 그 타입을 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다
* 컴파일러는 모든 연산을 허용한다 그러므로 모든 연산에 대한 책임은 나에게 있다
* 어떤 플랫폼 타입의 값이 널이 될 수도 있음을 알고 있다면 그 값을 사용하기 전에 널인지 검사할 수 있다
* 실제로 코틀린 컴파일러는 공개 가시성인 코틀린 함수의 널이 아닌 타입인 파라미터와 수신 객체에 대한 널 검사를 추가해준다, 따라서 공개 가시성 함수에 널 값을 사용하면 즉시 예외가 발생한다
* 이런 파라미터 값 검사는 함수 내부에서 파라미터를 사용하는 시점이 아니라 함수 호출 시점에 이뤄진다, 따라서 가능한 빨리 예외가 발생하기 때문에 예외가 발생해도 더 원인을 파악할 수 있다
* 자바 API를 사용할 때는 조심해야 한다
* 코틀린에서 플랫폼 타입을 선언할 수는 없다, 자바 코드에서 가져온 타입만 플랫폼 타입이 된다
* 플랫폼 타입을 널이 될 수 있는 타입이나 널이 될 수 없는 타입 어느 쪽으로든 사용할 수 있다

### 상속
* 코틀린에서 자바 메소드를 오버라이드할 때 그 메소드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야 한다
* 구현 메소드를 다른 코틀린 코드가 호출할 수 있으므로 코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어준다

## 코틀린의 원시 타입
* Int, Boolean, Any 등의 원시 타입
* 코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다

### 원시 타입 : Int, Boolean 등
* 원시 타입의 변수에는 그 값이 직접 들어가지만, 참조 타입의 변수에는 메모리상의 객체 위치가 들어간다
* 원시 타입의 값을 더 효율적으로 저장하고 여기저기 전달할 수 있다, 하지만 그런 값에 대해 메소드를 호출하거나 컬렉션에 원시 타입 값을 담을 수는 없다
* 코틀린은 원시 타입과 래퍼 타입을 구분하지 않으므로 항상 같은 타입을 사용한다

### 널이 될 수 있는 원시 타입 : Int? , Boolean? 등
* null 참조를 자바의 참조 타입의 변수에만 대입할 수 있기 때문에 널이 될 수 있는 코틀린 타입은 자바 원시 타입으로 표현할 수 없다
* 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일된다
* 컴파일러는 널 검사를 마친 다음에야 일반적인 값처럼 다루게 허용한다
* 제네릭 클래스의 경우 래퍼 타입을 사용한다
* 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용해야 한다
* 원시 타입으로 이뤄진 대규모 컬렉션을 효율적으로 저장해야 한다면 원시 타입으로 이뤄진 효율적인 컬렉션을 제공하는 서드파티 라이브러리를 사용하거나 배열을 사용해야 한다

### 숫자 변환
* 코틀린은 한 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다
* 결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다
* 코틀린은 모든 원시 타입에 대한 변환 함수를 제공한다
* 숫자 리터럴을 사용할 때는 보통 변환 함수를 호출할 필요가 없다

### Any, Any? : 최상위 타입
* 자바에서 Object가 클래스 계층의 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입이다
* 코틀린에서는 Any가 Int 등의 원시 타입을 포함한 모든 타입의 조상 타입이다
* 원시 타입 값을 Any 타입의 변수에 대입하면 자동으로 값을 객체로 감싼다
* Any 타입의 변수에는 null이 들어갈 수 없다
* 코틀린에서 널을 포함하는 모든 값을 대입할 변수를 선언할려면 Any? 타입을 사용해야 한다
* 내부에서 Any 타입은 java.lang.Object 에 대응한다
* 자바 메소드에서 Object 를 인자로 받거나 반환하면 코틀린에서는 Any 로 그 타입을 취급한다
* 코틀린 함수가 Any를 사용하면 자바 바이트코드의 Object 로 컴파일된다

### Unit 타입 : 코틀린의 void
* 코틀린 Unit 타입은 자바 void와 같은 기능을 한다
* 전혀 반환하지 않는 함수의 반환 타입으로 Unit을 쓸 수 있다
* 코틀린 함수의 반환 타입이 Unit 이고 그 함수가 제네릭 함수를 오버라이드하지 않는다면 그 함수는 내부에서 자바 void 함수로 컴파일된다
* Unit은 모든 기능을 갖는 일반적인 타입이며, void 와 달리 Unit 을 타입 인자로 쓸 수 있다
* Unit 타입에 속한 값은 단 하나뿐이며, 그 이름도 Unit이다
* Unit 타입의 함수는 Unit 값을 묵시적으로 반환한다
* 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit 을 쓸 때 유용하다
* 함수형 프로그래밍에서 전통적으로 Unit 은 단 하나의 인스턴스만 갖는 타입을 의미해 왔고 바로 그 유일한 인스턴스의 유무가 자바 void 와 코틀린 Unit 을 구분하는 가장 큰 차이다

### Nothing 타입 : 이 함수는 결코 정상적으로 끝나지 않는다
* 코틀린에는 결코 성공적으로 값을 돌려주는 일이 없으므로 반환 값이라는 개념 자체가 의미 없는 함수가 존재한다
* Nothing 타입은 아무 값도 포함하지 않는다
* Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다
* Nothing 을 반환하는 함수를 엘비스 연산자의 우항에 사용해서 전제 조건을 검사할 수 있다

## 컬렉션과 배열
* 코틀린 컬렉션이 자바 라이브러리를 바탕으로 만들어졌고 확장 함수를 통해 기능을 추가한다

### 널 가능성과 컬렉션
* 컬렉션 안에 널 값을 넣을 수 있는지 여부는 어떤 션수의 값이 널이 될 수 있는지 여부와 마찬가지로 중요하다
* 변수 타입 뒤에 ?를 붙이면 그 변수에 널을 저장할 수 있다는 뜻인 것 처럼 타입 인자로 쓰인 타입에도 같은 표시를 사용할 수 있다

### 읽기 전용과 변경 가능한 컬렉션
* 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다
* Collection에는 원소를 추가하거나 제거하는 메소드가 없 ₩다
* 컬렉션의 데이터를 수정하려면 kotlin.colections.MutableCollection 인터페이스를 사용해야 한다
* MutableCollection은 일반 인터페이스인 kotlin.collections.Collection을 확장하면서 원소를 추가하거나, 삭제하거나, 컬렉션 안의 원소를 모두 지우는 등의 메소드를 더 제공한다
* var 과 val 의 구별과 마찬가지로 컬렉션의 읽기 전용 인터페이스와 변경 가능 인터페이스를 구별한 이유는 프로그램에서 데이터에 어떤 일이 벌어지는지를 더 쉽게 이해하기 위함이다
* 컬렉션 인터페이스를 사용할 때 항상 염두에 둬야 할 핵심은 읽기 전용 컬렉션이라고 해서 꼭 변경 불가능한 컬렉션일 필요는 없다는 점이다
* 읽기 전용 인터페이스 타입인 변수를 사용할 때 그 인터페이스는 실제로는 어떤 컬렉션 인스턴스를 가리키는 수많은 참조 중 하나일 수 있다
* 읽기 전용 컬렉션이 항상 스레드 안전하지는 않다는 점을 명심해야 한다
* 다중 스레드 환경에서 데이터를 다루는 경우 그 데이터를 적절히 동기화 하거나 동시 접근을 허용하는 데이터 구조를 활용해야 한다

### 코틀린 컬렉션과 자바
* 모든 코틀린 컬렉션은 그에 상응하는 자바 컬렉션 인터페이스의 인스턴스라는 점은 사실이다
* 코틀린은 모든 자바 컬렉션 인터페이스마다 읽기 전용 인터페이스와 변경 가능한 인터페이스라는 두 가지 표현을 제공한다
* 코틀린은 자바 호환성을 제공하는 한편 읽기 전용 인터페이스와 변경 가능 인터페이스를 분리한다
* 자바 메소드를 호출하되 컬렉션을 인자로 넘겨야 한다면 따로 변환하거나 복사하는 등의 추가 작업 없이 직접 컬렉션을 넘기면 된다
* 자바는 읽기 전용 컬렉션과 변경 가능 컬렉션을 구분하지 않으므로, 코틀린에서 읽기 전용 Collection으로 선언된 객체라도 자바 코드에서는 그 컬렉션 객체의 내용을 변경할 수 있다
* 코틀린 컴파일러는 자바 코드가 컬렉션에 대해 어떤 일을 하는지 완전히 분석할 수 없다
* 컬렉션을 자바로 넘기는 코틀린 프로그램을 작성한다면 호출하려는 자바 코드가 컬렉션을 변경할지 여부에 따라 올바른 파라미터 타입을 사용해야 한다

### 컬렉션을 플랫폼 타입으로 다루기
* 플랫폼 타입의 경우 코틀린 쪽에는 널 관련 정보가 없다
* 컴파일러는 코틀린 코드가 그 타입을 널이 될 수 있는 타입이나 널이 될 수 없는 타입 어느 쪽으로든 사용할 수 있게 해준다
* 자바쪽에서 선언한 컬렉션 타입의 변수를 코틀린에서는 플랫폼 타입으로 본다
* 플랫폼 타입인 컬렉션은 기본적으로 변경 가능성에 대해 알 수 없다
* 코틀린 코드는 그 타입을 읽기 전용 컬렉션이나 변경 가능한 컬렉션 어느 쪽으로든 다룰 수 있다
* 플랫폼 타입에서 널 가능성을 다룰 때처럼 이런 경우에도 오버라이드하려는 메소드의 자바 컬렉션 타입을 어떤 코틀린 컬렉션 타입으로 표현할지 결정해야 한다
* 컬렉션이 널이 될 수 있는지 컬렉션의 원소가 널이 될 수 있는지 오버라이드하는 메소드가 컬렉션을 변경할 수 있는지 항상 생각해야 한다

### 객체의 배열과 원시 타입의 배열
* 코틀린 배열은 타입 파라미터를 받는 클래스이다
* 배열의 원소 타입은 바로 그 타입 파라미터에 의해 정해진다
* arrayOf 함수에 원소를 넘기면 배열을 만들 수 있다
* arrayOfNulls 함수에 정수 값을 인자로 넘기면 모든 원소가 null이고 인자로 넘긴 값과 크기가 같은 배열을 만들 수 있다, 물론 원소 타입이 널이 될 수 있는 타입인 경우에만 이 함수를 쓸 수 있다
* Array 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화해준다, arrayOf 를 쓰지 않고 각 원소가 널이 아닌 배열을 만들어야 하는 경우 이 생성자를 사용한다
* 코틀린에서는 배열을 인자로 받는 자바 함수를 호출하거나 varargs 파라미터를 받는 코틀린 함수를 호출하기 위해 가장 자주 배열을 만든다, 하지만 이때 데이터가 이미 컬렉션에 들어 있다면 컬렉션을 배열로 변환해야 한다
* 다른 제네릭 타입에서처럼 배열 타입의 타입 인자도 항상 객체 타입이 된다

#### 원시 타입의 배열을 만드는 방법
1. 각 배열 타입의 생성자는 size 인자를 받아서 해당 원시 타입의 디폴트 값으로 초기화된 size 크기의 배열을 반환한다
