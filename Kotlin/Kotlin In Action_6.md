# Kotlin In Action_6
# 코틀린 타입 시스템
* 널이 될 수 있는 타입과 널을 처리하는 구문의 문법
* 코틀린 원시 타입 소개와 자바 타입과 코틀린 원시 타입의 관계
* 코틀린 컬렉션 소개와 자바 컬렉션과 코틀린 컬렉션의 관계
* 자바와 비교하면 코틀린의 타입 시스템은 코드의 가독성을 향상시키는 데 도움이 되는 몇 가지 특성을 새로 제공한다

## 널 가능성
* 널 가능성은 NullPointerException 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다
* 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다
* 널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다

### 널이 될 수 있는 타입
* 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다
* 코틀린은 변수나 식의 값이 실행 시점에 null이 될 수 있는 경우를 모두 포함한다
* 함수가 널과 문자열을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표를 명시해야 한다
* 어떤 타입이든 타입 이름  뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다
* 물음표가 없는 타입은 그 변수가 null 참조를 저장할 수 없다는 뜻이다
* 널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다
* 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다
* 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다

### 타입의 의미
* 타입은 분류로 어떤 값들이 가능한지와 그 탕비에 대해 수행할 수 있는 연산의 종류를 결정한다
* 자바에서는 애노테이션을 사용해 값이 널이 될 수 있는지 여부를 표시하거나, Optional을 사용해서 NullPointerException 오류를 다루지만 코드가 더 지저분해지고 래퍼가 추가됨에 따라 실행 시점에 성능이 저하되며 전체 에코시크템에서 일관성 있게 활용하기 어렵다
* 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다
* 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다, 모든 검사는 컴파일 시점에 수행된다
* 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다

### 안전한 호출 연산자 : ?.
* 코틀린이 제공하는 가장 유용한 도구 중 하나가 안전한 호출 연사자인 ?. 이다
* ?.은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다
* 호출하려는 값이 null이 아니라면 ?. 은 일반 메소드 호출처럼 작동한다
* 호출하려는 값이 null이면 이 호출은 무시되고 null이 결과 값이 된다
* 안전한 호출의 결과 타입도 널이 될 수 있는 타입이다
* 메소드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다
* 객체 그래프에서 널이 될 수 있는 중간 객체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편할 때가 자주 있다

### 엘비스 연산자 : ?:
* 코틀린은 null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공한다
* 이 연산자는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다
* 엘비스 연산자를 객체가 널인 경우 널을 반환하는 안전한 호출 연산자와 함께 사용해서 객체가 널인 경우에 대비한 값을 지정하는 경우도 많다
* 코틀린에서는 return이나 throw 등의 연산도 식이다

### 안전한 캐스트 : as?
* as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다
* as?는 값을 대상 타입으로 변환할 수 없으면 null을 반환한다
* 안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다


