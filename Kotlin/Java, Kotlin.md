# Java, Kotlin
## 블록
* 장점 : 불필요한 CPU를 점유하지 않는다 
* 단점: 이벤트가 발생하기 전까지 아무것도 수행할 수 없다
* 블록 논 블록의 차이는 이벤트에 대해 스레드나 프로세스가 잠을 자는지 안 자는지의 차이이다

## 동기  
* 자신이 직접 수행한다
* 함수의 반환 값이나 완료를 통해 그 시점을 알 수 있다 
* 순서 제어가 쉽다

## 비동기
* 별도의 스레드나 프로세스를 통해 일을 처리한다
* 완료 시점을 알 수 없다 그러므로 콜백을 사용해야한다
* 단점 : 실행 시점을 알 수 없고 순서를 제어하기 어렵다
* 장점 : 병행성

* 대부분의 코드는 call by value 로 변경해야 한다
* detach : 사용하지 않으면 누수가 발생할 수 있다
* 스레드가 관여하는 것들은 mutex 를 꼭 해줘야한다
* DTO : Data Transfer Object
* DO : Data Object
* VO : Value Object
* DAO : Database Access Object

* 데이터를 교환하거나 저장하기 위한 목적의 클래스
* OR Mapping : Object R, elational - DAO
* 오버헤드가 있어서 사용할 수 없었다

### 결합
* 인터페이스나 추상 클래스에 의존 하는 것이 약한 결합이다
* 특정한 객체에 의존 하는 것이 강한 결합이다

### 데이터를 담고 있는 클래스의 3가지 특징
1. toString()
2. 비교 (equals)
3. Map (HashMap) - HashCode

### Heap 에 해시코드 값이 저장된다
* 해시 : 버킷의 크기가 무한정하지 않다, 다른 값이여도 동일한 해시 값이 나올 수 있다, 충돌 
* 해시코드를 사용할려면 해시코드와 이퀄스를 둘다 오버라이드 해줘야한다

### 해결 방법
* 선형 탐색법
* 이중 해시법
* 연결법 (가장 많이 사용된다) 

### 타입 체크 하는 2가지 방법
* instanceOf - is - a 관계
* class 타입 비교 - 오로지 타입만 비교

* 레퍼런스 비교 (객체 동등성) : equals
* 프리미티브 비교 (참조 동등성) : ==

* null point exception 을 항상 고려해야한다

* Objects.equals ( ) : null을 체크하는 메소드

* Treemap : comparable , compare 을 사용해야 한다

* Json : 문자열 형식의 데이터, 로깅하기가 좋다, 하지만 비효율적인 측면이 있다

### 프로토콜버퍼 : Protocol Buffers (Google)
* 다양한 언어를 지원한다
* gRPC  (Remote Procedure Call) : 모든 언어
* RMI (Remote Method Invoke) : 자바에서만 쓸 수 있다

* inline : 함수 호출 시 별도로 분리된 위치의 레이블로 점프하여 실행되는 일반 함수와는 달리 호출 부분을 함수 전체 코드로 치환하여 컴파일한다, 전처리기의 매크로와 달리 언어 차원에서 지원하기에 일반 함수와 별 다르지 않게 사용할 수 있다
* proxy <-> stub (실제 기능을 가지고 있는)

## 코틀린의 3가지 장점
1. 간결성 : 자바 언어의 보일러플레이트를 효과적으로 제거한다
2. 안전성 : Null 참조로 인한 문제 , Nullable : Null 체크를 컴파일러가 체크한다
3. 상호운용성 : Java의 모든 기능을 코틀린에서 아무런 설정없이 사용할 수 있다

* 코틀린은 전역 함수를 지원한다
* 코틀린은 함수형 언어이다
* 순수 함수 : 입력이 동일하면 결과도 동일하다
* 암묵적으로 타입을 지정해준다
* 모든 타입은 객체이다
* is 는 스마트 캐스트를 허용하지만, reflection 은 불가능하다
* private - internal - protected - public
* 코틀린의 모든 클래스와 메소드는 final이다 (오버라이딩이 불가능하다)
* open 클래스만 상속과 오버라이딩을 가능하게 만들어 준다
* 상속을 할 때는 부모의 인자를 그대로 받아야 한다
* interface 는 동작적인 부분에 포커스를 맞춘다, 하지만 새로운 기능을 추가하기는 어렵다
* abstract 는 공통적인 속성이나 동작을 미리 정해놓는다
* field 를 사용하려면 초기화 부분을 신경 써야 한다
* 캐스팅 할 때는 as 키워드를 사용해야 한다
* 코틀린은 중첩 클래스가 기본이다
* inner 클래스를 만들기 위해서는 inner 키워드를 반드시 사용해야 한다
* Nested Class : static class Memento : Inner Class 보다는 Nested Class를 만들어야 한다
* Inner Class : class Memento : 외부 클래스의 모든 필드와 메소드에 접근할 수 있다, 외부 클래스(외부 객체)의 참조가 암묵적으로 존재한다
* when 은 자바의 switch 를 대체한다
* 봉인된 클래스 : 라이브러리 설계자 이외에 상속을 사용할 수 없도록 하고 싶을 때 사용한다
* sealed : 봉인된 클래스, 같은 파일에서만 상속을 허용한다, 소프트 키워드(혼자서 사용할 수 없는 키워드)
* 객체를 생성하는 것은 비용이 크다, 참조를 비교하는 것은 비교적 훨씬 쉽다
* Buffer 와 build 의 차이점 : 동기화는 개발자가 하게 만들어야 한다
* when 의 특징은 break; 를 넣지 않아도 된다는 점이다
* when 에 인자가 없다면, 조건부분은 반드시 Boolean을 반환하는 expression 이어야 한다

### 상수
* Runtime 상수 : 메모리가 존재하지만 runtime 시에 다른 것을 가리키지 못하도록 하는것 (변수가 잡혀있다) readonly (C#), const (C++), cal (Kotlin)
* Compile 상수 : const (C#), const, constexpr (C++), const val (Kotlin)

### when 과 switch 의 차이점
* Statment (문) vs Expression (식)
* 문 : 결과가 존재하지 않는다
* 식 : 결과가 존재한다
* if 나 when을 코틀린에서는 식으로 표현한다
* if 보다는 when 을 사용하는게 좋다

### 확장 함수
* 상속은 깨지기 쉬운 기반 클래스의 문제가 있다. 부모의 구현을 물려받기 때문에 부모구현 변경이 자식 클래스에도 영향을 끼친다. 그래서 설계를 제대로 하거나 상속을 금지해야 한다 
* 수직 확장: 상속을 통한 확장
* 수평 확장: 확장 함수, 프로퍼티
* 확장 함수는 코틀린의 라이브러리를 이루는 핵심이다. C#, Swift, Obj-c 에도 있다
* 확장 함수는 철저한 팀 간의 합의에 의해서 되어야 한다. 전체적인 영향을 미치기 때문에확장 함수를 프라이빗으로 만들어야 한다,그 파일에서만 접근 가능하도록 하기 위해서이다

* 전역 함수는 전역의 네임스페이스를 더럽힌다. (심볼이 전역적으로 하나만 존재해야 하기 때문에) 그래서 자바는 없다
* 자바는 컴파일 타임에 타입 체크만 한다. 컬렉션 자체가 Any 타입으로 되어 있다. 코드를 생성하는 것이 아니다, 그래서 자바에서는 제네릭을 추상적으로 사용했을 때의 이점 (라이브러리로서 누리는)을 쓸 수 없었다. 코틀린에서는 레이파이드 문법을 만들어서 이걸 할 수 있게 한다

* 함수의 이름 앞에 on이라는게 붙으면 콜백의 의미를 가진다
* 콜백 함수 : 자동으로 메소드를 호출하는 함수
* Nullable 타입은 사용하기 전에 반드시 null 체크를 해야한다
* 간결한 널 참조 연산을 제공한다 (ex)  activity?.close () )
* 트렌스 파일링 : 자바로 번역 하는 것
* 항상 호출에 대한 순서는 위에서부터 아래로 작동 한다
* 프로퍼티 : 필드와, 접근자 메소드를 자동으로 생성하는 기능
* 프로퍼티의 위임 getter setter 다른 객체가 대신 처리해 준다
* val : getter만 생성
* var : getter, setter 둘 다 생성
* 배킹 필드 : 값을 저장하면 생성된다
* 알고리즘은 동일한 타입만 다를경우 제네릭으로 만들어야 한다
* 제네릭 : 타입을 인자로 받는 함수, 타입 파라미터
* 옵저버 : 관찰자 , 값에 대한 정보를 통보 받을 때 사용한다
* pull 모델 : 데이터를 능동적으로 꺼내 간다, 계속해서 주기적으로 확인한다 (불필요한 리소스, CPU를 사용한다)
* 옵저버, 관찰자 패턴 (push) : 내 값이 변경되면 변경되었다고 알려주는 형식 
* wildcard 문법 : *
* operator : 연산자 오버로딩에 대한 키워드 (자바는 존재하지 않는다), 사용하기 어렵지만 잘 사용하면 훨씬 더 직관적인 코드를 만들 수 있다
* 연산자 오버로딩 : 약속된 연산자를 객체에 대해서 수행하였을 경우, 호출되는 메소드를 정의하는 방법 -> [ ] 
* 구조 분해 선언 문법
* 함수를 인자로 받는 함수를 사용하는 이유 -> 변하지 않는 알고리즘에서 변해야 하는 정책을 인자로 분리하는 설계 방식
* 다른 함수의 인자 (변수)를 암묵적으로 사용할 수 있는 것 : 클로저

### 위임
* 재사용 
* 1. 상속 : 편하다, 부모의 것들을  자유롭게 사용할 수 있다, 단점은 부모가 변경 될 경우 자식이 영향을 받을 수 있다
* 2. 포함 (위임) : by 키워드로 위임이 가능하다
* 재사용은 상속보다 포함이 좋다

### 일급 시민
* 함수를 변수에 담을 수 있어야 한다
* 함수를 인자로 전달할 수 있어야 한다
* 함수를 반환할 수 있어야 한다
* 함수를 실행 시간에 생성할 수 있어야 한다
* 익명으로 함수를 생성할 수 있어야 한다

### 확장 함수
* 문법 설탕 : 편리하게 만드는 기능, 더 직관적인 표현이 가능하게 만들어 주는 것
* 기존 클래스의 코드를 수정하지 않고 새로운 기능을 추가하는 기능
* 동일한 시그니처를 가진 동일한 함수는 공존이 불가능하다 (이름 충돌) -> 패키지가 분리되면 상관이 없다
* 일반 함수를 메소드처럼 사용하게 만들어 주는 방법
* 가독성을 높히기 위해 사용한다
* 코틀린 라이브러리의 핵심 , 모든 라이브러리는 확장함수로 되어있다
* 상속을 통해 기능을 확장하는 것이 아니라 인터페이스의 부분을 확장하는 기법

* 수직 확장 : 상속을 이용한 기능의 확장, 상속에 대한 문제점을 가지고 있다 상속을 위해 만든게 아니라면 잘 작동하지 않는다, 부모의 문제가 자식한테도 연결이 될 수도 있어서 문제가 발생 할 수 있다
* 수평 확장 : extension, 범용적이지 않은 기능도 포함한다면 좋지 않다, 범용적인 기능만 포함해야 한다

### 함수와 메소드의 차이점
* 메소드 : 특정한 객체의 첫번째 this를 암묵적으로 전달한다
* 내가 원하는 타입을 하나로 묶어둔 타입 : 캡슐화
* C ++ 은 메소드 부분을 thiscall이라 부른다

* 문자열에 관해서 트림(trim)이라는 부분을 체크해줘야한다

### 중위 함수
* 인자가 하나인 메소드에 대해서, 중위 표현을 허용하는 문법
* infix function

### 커링
* 다중 인수를 받는 함수를 단일 인수를 갖는 함수들을 함수열로 바꾸는 것을 의미한다
* 함수 실행을 지연할 수 있다
* 부분 적용 : 특정 인자를 특정 값으로 고정할 수 있다
* 연산자는 오른쪽 부터 연산이 되므로 ()를 생략할 수 있다

### 로깅
* 기록하는 것
* 링 버퍼 = 버퍼의 용량이 초과되면 처음부터 다시 쓰는 것

### 함수 합성
* 기존 함수를 합성해서 새로운 함수를 만드는 기법
* bind : 어떠한 타입이 될지 이미 결정된 것