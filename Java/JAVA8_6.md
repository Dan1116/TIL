# JAVA8_6
## 스트림으로 데이터 수집
* 스트림이란 데이터 집합을 멋지게 처리하는 게으른 반복자라고 생각할 수 있다
* 중간 연산은 한 스트림을 다른 스트림으로 반환하는 연산으로서, 여러 연산을 연결할 수 있다, 파이프라인을 구성하며, 스트림의 요소를 소비하지 않는다
* 최종 연산은 스트림의 요소를 소비해서 최종 결과를 도출한다, 스트림 파이프라인을 최적화하면서 계산 과정을 짧게 생략하기도 한다
* collect는 스트림의 요소를 요약 결과로 누적하는 다양한 방법을 인수로 갖는 최종 연산이다
* 스트림의 요소를 하나의 값으로 리듀스하고 요약하는 컬렉터 뿐 아니라 최솟 값, 최댓 값, 평균 값을 계산하는 컬렉터 등이 미리 정의되어 있다
* 미리 정의된 컬렉터인 groupingBy로 스트림의 요소를 그룹화하거나 partitioningBy 로 스트림의 요소를 분할할 수 있다
* 컬렉터는 다수준의 그룹화 분할, 리듀싱 연산에 적합하게 설계되어 있다
* Collector 인터페이스에 정의된 메서드를 구현해서 커스텀 컬렉터를 개발할 수 있다

## 컬렉터란 무엇인가
* Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다
* 다수준(multilevel)으로 그룹화를 수행할 때 명령형 프로그래밍과 함수형 프로그래밍의 차이점이 더욱 두드러진다
* 명령형 코드에서는 문제를 해결하는 과정에서 다중 루프와 조건문을 추가하며 가독성과 유지보수성이 크게 떨어진다
* 함수형 프로그래밍에서는 필요한 컬렉터를 쉽게 추가할 수 있다

### 고급 리듀싱 기능을 수행하는 컬렉터
* 훌륭하게 설계된 함수형 API의 또 다른 장점으로는 높은 수준의 조합성과 재사용성을 꼽을 수 있다
* collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다
* 스트림에 collect를 호출하면 스트림의 요소에 리듀싱 연산이 수행된다
* 보통 함수를 요소로 변환 할 때는 컬렉터를 적용하며 최종 결과를 저장하는 자료구조에 값을 누적한다

### 미리 정의된 컬렉터
* Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분 할 수 있다
	1. 스트림 요소를 하나의 값으로 리듀스하고 요약
	2. 요소 그룹화
	3. 요소 분할

* 리듀싱과 요약은 트랜젝션 리스트에서 트랜젝션 총합을 찾는 등의 다양한 계산을 수행할 때 컬렉터를 유용하게 활용할 수 있다
* 스트림 요소를 그룹화하는 방법은 다수준으로 그룹화하거나 각각의 결과 서브그룹에 추가로 리듀싱 연산을 적용할 수 있도록 다양한 컬렉터를 조합하는 방법이 있다
* 그룹화의 특별한 연산인 분할, 분할은 한 개의 인수를 받아 불린을 반환하는 함수, 즉 프레디케이트를 그룹화 함수로 사용한다

## 리듀싱과 요약
* 컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있다
* 트리를 구성하는 다수준 맵, 단순한 정수 등 다양한 형식으로 결과가 도출 될 수 있다

### 스트림 값에서 최댓값과 최솟값 검색
* Collectors.maxBy 와 Collectors.minBy 두 개의 메서드를 이용해서 스트림의 최댓값과 최솟값을 계산할 수 있다

### 요약 연산
* Collectors.summingInt 라는 특별한 요약 팩토리 메서드를 제공한다
* Collectors.averagingInt 는 숫자 집합의 평균을 계산하는 메서드이다
* 두 개 이상의 연산을 한 번에 수행해야 할 때는 팩토리 메서드 summarizingInt가 반환하는 컬렉터를 사용할 수 있다

### 문자열 연결
* 컬렉터에 joining 팩토리 메서드를 이용하면 스트림의 각 객체의 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다
* joining 메서드는 내부적으로 StringBuilder를 이용해서 문자열을 하나로 만든다

### 컬렉션 프레임워크 유연성: 같은 연산도 다양한 방식이 있다
* reducing 컬렉터를 사용하지 않고 Integer 클래스의 sum 메서드 레퍼런스를 이용하면 코드를 좀 더 단순화 할 수도 있다
* IntStream 덕분에 자동 언박싱 연산을 수행하거나 Integer를 int 로 변환하는 과정을 피할 수 있으므로 성능도 좋다

## 그룹화
* 데이터 집합을 하나 이상의 특성으로 분류해서 그룹화하는 연산도 데이터베이스에서 많이 수행되는 작업이다
* 함수형을 이용하면 가독성 있는 한 줄의 코드로 그룹화를 구현할 수 있다
* 함수를 기준으로 스트림이 그룹화되면 이를 분류 함수라고 부른다

### 다수준 그룹화
* 두 인수를 받는 팩토리 메서드 Collectors.groupingBy 를 이용해서 항목을 다수준으로 그룹화 할 수 있다, Collectors.groupingBy는 일반적인 분류 함수와 컬렉터를 인수로 받는다
* 즉 바깥 쪽 groupingBy 메서드에 스트림의 항목을 분류할 두 번째 기준을 정의하는 내부 groupingBy를 전달해서 두 수준으로 스트림의 항목을 그룹화 할 수 있다
* 다수준 그룹화 연산은 다양한 수준으로 확장할 수 있다, 즉 n 수준 그룹화의 결과는 n 수준 트리 구조로 표현되는 n 수준 맵이 되는 것이다

### groupingBy 와 함께 사용하는 다른 컬렉터 
* mapping 메서드는 스트림의 인수를 변환하는 함수와 변환 함수의 결과 객체를 누적하는 컬렉터를 인수로 받는다
* mapping 은 입력 요소를 누적하기 전에 매핑 함수를 적용해서 다양한 형식의 객체를 주어진 형식의 컬렉터에 맞게 변환하는 역할을 한다

## 분할
* 분할은 분할 함수라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다
* 분할 함수는 불린을 반환하므로 맵의 키 형식은 Boolean 이다, 결과적으로 그룹화 맵은 최대 두 개의 그룹으로 분류된다

### 분할의 장점
* 분할 함수가 반환하는 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점이다

## Collector 인터페이스
* Collector 인터페이스는 리듀싱 연산을 어떻게 구현할지 제공하는 메서드 집합으로 구성된다

### supplier 메서드 : 새로운 결과 컨테이너 만들기
* supplier 메서드는 빈 결과로 이루어진 Supplier 를 반환해야 한다, 즉 supplier는 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수다

### accumulator 메서드 : 결과 컨테이터에 요소 추가하기
* accumulator 메서드는 리듀싱 연산을 수행하는 함수를 반환한다, 스트림에서 n 번째 요소를 탐색할 때 두 인수, 즉 누적자와 n번째 요소를 함수에 적용한다
* 함수의 반환 값은 void, 즉 요소를 탐색하면서 적용하는 함수에 의해 누적자 내부 상태가 바뀌므로 누적자가 어떤 값일지 단정할 수 없다

### finisher 메서드 : 최종 변환값을 결과 컨테이너로 적용하기
* finisher 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 한다

### combiner 메서드 : 두 결과 컨테이너 병합
* combiner는 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의한다
* toList의 combiner는 비교적 쉽게 구현할 수 있다, 즉 스트림의 두 번째 서브파트에서 수집한 항목 리스트를 첫 번째 서브파트 결과 리스트의 뒤에 추가하면 된다

### Characteristics 메서드
* characteristics 메서드는 컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환한다

* 먼저 살펴본 네 개의 메서드는 collect 메서드에서 실행하는 함수를 반환하는 반면, 다섯 번째 메서드 characteristics는 collect 메서드가 어떤 최적화를 이용해서 리듀싱 연산을 수행할 것인지 결정하도록 돕는 힌트 특성 집합을 제공한다