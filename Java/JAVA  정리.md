# JAVA  정리
## 기본 내용
* 덕 타이핑 = 동적 타이핑의 한 종류로, 객체의 변수 및 메소드의 집합이 객체의 타입을 결정하는 것을 말한다
* DRY = Do not repeat yourself
* 자바는 class를 통해서 인스턴스를 생성한다
* 업케스팅 후 재정의 된 메소드를 호출해야 한다
* String은 불변 객체 이다 (상태가 변경 되어야 한다면 그 상태를 가지는 새로운 객체를 생성한다)
* 자식의 공통된 기능은 반드시 부모로부터 비롯되어야 한다 (부모의 레퍼런스를 통해서 자식의 기능을 온전히 이용할 수 있다)
* 자식은 반드시 기능을 제공해야 하고 부모가 구현을 제공할 필요가 없다면, 추상 메소드가 좋다
* 리팩토링 (Refactoring) : 기존 코드의 동작을 변경하지 않고 구조를 개선하는 작업이다 (마틴 파울러) -> 코드의 유지보수성을 떨어트리는 요소 - 냄새 (smells) -> Replace type code with polymorphism
* AOP (관점 지향 프로그래밍) = Aspect Oriented Programming, 어노테이션을 사용하는 두 번째 이유 (반복적으로 생기는 보일러플레이트를 제거할 수 있다), 좀 더 선언적으로 표현이 가능하게 만들어 준다
* 동일한 내용의 객체를 공유할 수 있다 -> Flyweight pattern
* COW (copy on write ) = 방어적 복사 
* 동일한 내용의 경우 공유할 수 있으므로, 객체를 비교할 때, == 연산을 통해 비교할 수 있다
* == : 참조 동등성을 판단한다
* equals : 객체 동등성을 판단한다
* interface는 클래스 간 느슨한 결합 관계를 만들기 위해 사용한다, 완벽한 추상 클래스라고 할 수 있다, 그러나 불완전한 메서드로만 이루어져 있다, 따라서 인스턴스화 할 수 없다
* interface는 객체가 없어도 미리 쓸 수 있게 만들어 준다
* protected 를 사용하면 안 되는 이유 -> 재사용이 불가능하다
* 오버헤드 (Overhead)란 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등을 말한다
* 상태에 따라 다르게 만들려면 enum 을 사용해야 한다
* FileInputStream, FileOutputStream(바이트스트림) 은 바이트(Byte) 형식의 데이터를 읽고 쓴다
* FileReader, FileWriter(문자스트림)은 문자단위(char 배열 or String) 형태의 문자를 읽거나 쓴다
* Vector는 무조건 동기화이기 때문에 단일 스레드에서 성능이 떨어지고 멀티 스레드에서도 이제 사용하지 않는다
* 단일 스레드 처리에는 ArrayList를 쓰고, 동기화가 필요할 때는 Collection, synchronizedCollection, synchronizedList, Map 을 사용한다

## Code Smells
* 새로운 것이 추가될 때마다, 코드는 수정되어야 한다
* 리팩토링(Refactoring): 마틴 파울러
* 코드의 유지보수를 어렵게 만드는 요소를 냄새라 부른다 (Code Smells)

## Boxing
* Boxing = Collection 에 Primitive Type 을 저장하기 위해서는 Reference Type 으로 변환해야 한다
* 자동으로 박싱을 하는 것 = Auto Boxing 이라 한다
* 오토 박싱은 어떤 타입이 들어있는지 빼낼 때 알 수 없으므로 잘 사용하지 않는다
* Collection 에는 하나의 타입만 집어넣어야 한다

## Upcasting은 암묵적(Implicit)으로 허용한다
* static binding  : 컴파일러 (타입만 볼 수 있다) 가 결정한다
* dynamic binding : 실행시간에 결정한다 (default)

## private > package private > protected > public
* package private = 같은 클래스 내에서는 접근 가능,  같은 패키지 내에서는 protected 에 접근이 가능하다
* 패키지의 이름이 같으면 다른 모듈이여도 접근이 가능하다 (단점) 악의적으로 이용이 가능하다 (자바에서만 특별하게 default, 따라서 다른 언어에서는 이렇게 작동하지 않는다)

## StringBuilder 객체의 용도
* 객체 생성의 공정은 동일하지만, 다른 표현을 가지는 객체를 생성할 때 사용하는 패턴이다
* 불변 객체는 새로운 표현마다 새로운 객체가 만들어진다
* 프로그램 성능이 객체의 생성과 파괴에 큰 영향을 받는다
* String 과 다르게 불변 객체가 아니다
* 문자열 연산이 자주 있을 때 사용한다
* Builder은 단일 쓰레드 환경에서 사용하기 좋다
* Buffer는 멀티 쓰레드 환경에서 사용하기 좋으며 동기화를 지원, =을 쓸 이유가 없다

##  @Override (런타임 다형성을 구현하는 기능)
* 컴파일러에게 특정한 동작을 한다는 것을 알려주는 기능이다 (Annotation)
* 요즘에는 부모로부터 상속받은 클래스는 앞에 override를 명시한다
* 런타임에 작동하는 annotation을 만들어야 한다 (build, FunctionalInterface)

## 정적 배열 Array
* 컴파일 타임에 크기가 결정된다
* 사이즈 = 초기화시 고정된다
* 속도 = 초기화시 메모리에 할당, 속도가 빠르다
* 변경 = 사이즈 변경 불가하다

## 동적 배열 ArrayList
* 동적배열, 컬랙션 (특정한 부분을 찾는 시간이 빠르다)
* 런타임에 크기가 계속 변경될 수 있다 (정적배열을 사용해서 구현해야 한다)
* 원시적 (primitive) 타입을 넣을 수 없다
* 초기화시 사이즈를 표시하지 않음, 유동적이다
* 추가 시 메모리를 재할당, 속도가 느리다
* 추가 삭제 기능 (add ( ), remove ( ))

## 동적 배열 LinkedList
* 동적배열, 컬랙션 (특정한 부분을 삽입 삭제 하는 시간이 빠르다)
* 컴파일 할 때 정적 변수를 파일에 저장, 동적 변수는 런타임 때 저장한다

## 래퍼 클래스 (Integer, Long, Double)가 필요한 이유
* 원시적 타입 (call by value) 을 참조형 타입 (call by reference) 으로 사용하기 위해서 만들어진 클래스가 래퍼 클래스이다
* 원시 데이터 유형은 메모리 주소로 참조 될 수 없습니다. 그렇기 때문에 원시 값의 자리 표시자 역할을 하는 래퍼가 필요합니다. 이 값들은 돌연변이되어 액세스되거나, 재구성되거나, 정렬되거나 무작위화 될 수 있습니다

## 비교 
* 객체의 동등성 -> 동일한 내용을 가지는가 (.equals)
* 참조의 동등성 -> 동일한 참조값을 가지고 있는가 (==)

## final의 쓰임 3가지
* 변수 앞  = 상수화 (객체의 내용은 변경 가능)
* 클래스 앞 = 상속을 저지
* 메소드 앞 = 오버라이딩을 저지

## abstract 클래스
* 집합에 대한 개념, 인스턴스를 생성할 수 없다, 반드시 추상 클래스를 상속하는 자식 클래스에서 부모가 가진 추상 메소드를 모두 오버라이딩 해야 한다.

## 패키지를 쓰는 이유
* 이름 충돌을 방지하기 위해서 -> 소속 회사의 도메인을 거꾸로 사용하는게 보편적

## 자바 타입의 종류 
1. Primitive type (Built-in type) , Scala Type, Value Type =>
int, double, float, char, boolean, byte
2. Reference type (User-defined Type) => 모든 클래스 타입 (대문자로 시작)
Reference 타입으로 만드는 방법 3 가지 -> class, Array, enum, interface

## SOLID = 객체지향 설계 5대 원칙
* => 정리한 사람 : Uncle Bob (Robert C Martine = clean code)

### SRP(Single Responsibility Principle)
: 단일 책임의 원칙
-> 모듈(변수, 함수, 클래스, 프로그램)은
단 하나의 책임을 가져야 한다

### OCP(Open Close Principle)
: 개방 폐쇄의 원칙
-> 모듈은 수정에는 닫혀 있고, 확장에는 열려 있어야 한다
: 새로운 기능이 추가되어도, 기존 코드는 수정되면 안된다

### LSP(Liskov Substitution Principle)
: 리스코프의 치환 원칙
-> 자식은 부모 클래스로 대체할 수 있어야 한다
: 자식의 공통된 기능은 부모로부터 비롯되어야 한다
=> 상속의 목적은 다형성이다

### ISP(Interface Segregation Principle)
: 인터페이스 분리 원칙
MP3: play() / playOneMinute()
-> iPod: play()          Person {
iPhone: play()           void playMusic(MP3 mp3) { mp3.play(); }
}

: 범용 인터페이스(어떤 입출력 기기에도 적합하도록 구상된 인터페이스) 보다는 세분화된 인터페이스가 좋다

### DIP(Dependency Inversion Principle)
: 의존관계 역전 원칙
=> 클라이언트는 구체적인 타입에 의존하는 것이 아니라, 인터페이스나 추상 클래스에 의존해야 한다 (느슨한 결합)

## 메모리 영역 (Life cycle, 비용)
* Text ->  기계어 코드 저장되는 영역 (read-only) -> Segmentation Fault
* Data -> static (정적) 변수  -> 메모리 할당은 프로그램 시작부터 끝까지 -> 프로그램의 용량이 커지고, 메모리 사용량이 높아진다
* Heap (자유영역) -> new를 통해 생성된 객체, 원하는 시점에 생성, 파괴가 가능한 메모리, 상대적으로 느리다
* Stack -> 함수 실행, 함수 반환 주소 값, 지역 변수, 메모리 할당은 함수가 시작할 때, 함수가 끝날 때 파괴 -> 메모리 생성과 해지의 비용이 거의 없다

* Data Structure - Stack (가장 나중에 들어간 것), Queue (가장 먼저 들어간 것)
* 우선순위는 큐
* => 데이터가 들어간 순서 상관없이, 우선순위가 가장 높은 요소가 먼저 나온다
* Stack = 한쪽으로 데이터를 넣으면
* protected 를 사용하면 안 되는 이유 -> 재사용이 불가하다
* 자식 클래스가 부모의 기능을 이용할 때, 필드에 바로 접근하는 것이 아니라 메소드를 이용해야 한다
* 재사용은 포함이 좋다

## Comparator (비교자), Comparable (비교 가능한)
* 비교자 : 정렬을 할 때는 정책을 이용해야 한다
* 오름차순 (ascending), 내림 차순 (descending)
* Comparator (비교자) -> 내가 만든 객체가 아닐 경우 사용 -> 타입 안전성을 가지고 있다
* Comparable (비교 가능한) -> 내가 만든 객체일 경우 사용 -> 내가 만든 객체가 아니면 사용할 수 없다, Object 타입이기 때문에 잘못된 타입이 올 수도 있다
* 데이터는 Stream 기반으로 처리하는게 좋다

## ConcurrentModificationException - fail fast
* 하나의 컬렉션에 두 개 이상의 스레드가 데이터를 넣거나 뺄때 발생하는 문제이다
* Race Condition  => 원자적(더 이상 나누어 질 수 없는 하나)이 아니여서 발생하는 문제이다 => 쪼개지지 않는다
* 경쟁 조건이 발생하지 않도록, 임계 영역에 대해서 상호 배제를 해주어야 한다

* 임계 영역(Critical Section) : 임계구역(critical section) 또는 공유변수 영역은 병렬컴퓨팅에서 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말한다.임계 구역은 지정된 시간이 지난 후 종료된다.
* 상호 배제(Mutual Exclusion) : 하나의 스레드만 접근할 수 있도록 만들어 주는 것이다

* 경쟁 조건이 발생하였을 때, 정수의 연산만 존재한다면, 뮤텍스보다는 다른 방법을 쓰는 것이 좋다
* => 원자적 연산(CPU 명령)

* Mutex : 공유 자원에 대해 단 하나의 스레드만 접근하도록 하는 기능

## for (Socket socket : sessions)
* 향상된 for 구문
* 향상된 for 구문을 순회하는 도중에, 절대 컬렉션의 크기가 변경되면 안된다.

## 명시적으로 lock을 제공하는 방법
### 문제점
* : 실수 가능성이 높다
* 1) lock을 제대로 공유하지 않는 경우 문제가 발생한다
* 2) synchronized 구문을 제대로 작성하지 않는 경우 문제가 발생한다
 
## 해결방법 collection이 스스로 동기화 할 수 있도록하자
* : Decorator Pattern
* => 실행 중에 기존 객체에 새로운 기능을 추가하는 패턴이다

### sessions는 여러 개의 스레드에서 동시에 접근해야 하므로, 스스로 동기화 될 수 있어야 한다
* sessions = Collections.synchronizedList(sessions);

### 랜덤을 사용하기 위한 방법
* LocalDateTime.now().atZone(ZoneId.systemDefault()).toEpochSecond();
* Epoch time = 1970년 1월 1일 0시 0분부터 측정한 시간
 
### 리스너 기반의 처리 방식보다는 핸들러 기반 (함수 포인터) 이벤트 처리 방식을 사용하는 것이 좋다

## Interface 는 약속이다
* 자바는 익명의 클래스라는 문법을 제공합니다
* 느슨한 결합을 해야할 때 사용한다

## 람다 (함수형)
* openButton.setOnClickListener((id) -> {
* dialog.open();
* });

## 상속
* is-a 관계
* 부모의 구현(필드, 메소드)을 물려 받는다
* 부모의 자식 간의 강한 결합이 발생한다
* Upcasting은 암묵적으로 허용한다

### 강한 결합
* 구체적인 타입에 의존한다
* 부모의 참조변수를 통해 자식 객체를 참조할 수 있다

## Binding
### Static Binding
* 참조 변수의 타입을 통해 함수를 결정한다
* 장점: 런타임 오버헤드가 없다
* 단점: 합리적인 동작이 아니다
* Static (정적) - 컴파일 타임 => 타입

### Dynamic Binding
* 참조 변수가 참조하는 객체의 타입을 런타임에 확인해서 함수를 호출한다
* 장점: 합리적으로 동작한다 => 다형성
* 단점: 런타임 오버헤드가 있다
* 오버헤드 (Overhead)란 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등을 말한다
* 동적 디스패치 (바인딩): 참조 변수가 참조하는 객체 타입의 메소드를 호출한다
* Virtual (가상) 을 사용하면 정적을 동적으로 만들 수 있다

## 불변 객체
* 순수 함수 = 함수의 결과가 인자에 의해 결정되야 한다, 공유 데이터가 존재하지 않아 (상태를 가지고 있지 않다) 동기화할 필요가 없다
* 모든 필드는 private으로 하는게 좋다
* 운영체제를 시스템 관점으로 볼 때 커널이라 부른다

## 버퍼링
* 버퍼링을 하는 이유는 User mode 와 Kernel mode의 문맥 교환(context switching)을 자주 일어나지 않도록 하기 위해서 사용한다 (시스템 콜을 줄이기 위해)

1. 인자의 전달은 stack을 이용한다
2. 함수 호출 이전의 상태와 함수 호출 후의 스택 상태는 동일해야 한다
3. 가변 인자는 스택을 통해 인자가 전달된다 (가변 인자를 사용하려면 고정 인자(가변인자 바로 앞에 위치한 인자)가 필요하다)
* : 가변 인자를 통해 호출된 함수는, 몇 개의 인자가 자신에게 전달되었는지 알 수 없다, C 언어에서는 고정 인자를 통해 몇 개의 인자가 전달되었는지 알려야한다

## Thread
* 프로그래밍 언어로 소스를 짜서 만든 것을 프로그램이라고 한다, 이 프로그램을 실행 시켜서 동작하게 만들면 이것을 프로세스라고 한다
* 프로세스는 보통 하나의 루틴을 가지고 있다, 이 루틴은 직렬적이다
* 어떠한 일을 수행하는 것에 있어 프로그래머가 원하는 순서대로 일을 처리한다
* 스레드는 분리해서 동시에 처리하고 싶을 때 사용한다
* 스레드 사이에서 공통적으로 사용해야할 객체가 있다면 동기화에 대해 고민을 해야 한다
* 다중 스레드 작업 시에는 각 스레드 끼리 정보를 주고받을 수 있어 처리 과정의 오류를 줄일 수 있다, 프로세스 끼리는 정보를 주고 받을 수 없다

## multi thread
* 메모리 공유로 인한 시스템 자원 소모가 줄어 든다
* 동시에 두 가지 이상의 활동을 하는 것이 가능하다
* 서로 자원을 소모하다가 충돌이 일어날 가능성이 있다
* 코딩이 난해해져 버그 발생 확률이 높아진다

### Runnable
* 스레드가 실행되기 위한 준비 단계, CPU를 점유하고 있지 않으며 실행(Running 상태)을 하기 위해 대기하고 있는 상태이다
* 코딩 상에서 start( ) 메소드를 호출하면 run( ) 메소드에 설정된 스레드가 Runnable 상태로 진입한다

### Running
* CPU를 점유하여 실행하고 있는 상태이며 run() 메서드는 JVM만이 호출 가능하다
* Runnable (준비상태)에 있는 여러 스레드 중 우선 순위를 가진 스레드가 결정되면 JVM이 자동으로 run() 메소드를 호출하여 스레드가 Running 상태로 진입한다

### Dead
* Running 상태에서 스레드가 모두 실행되고 난 후 완료 상태이다, 즉, Done 상태

### Blocked (지연 상태)
* CPU 점유권을 상실한 상태, 후에 특정 메서드를 실행시켜 Runnable (준비 상태)로 전환한다
* wait () 메소드에 의해 Blocked 상태가 된 스레드는 notify () 메소드가 호출되면 Runnable 상태로 간다
* sleep (시간) 메소드에 의해 Blocked 상태가 된 스레드는 지정된 시간이 지나면 Runnable 상태로 간다

## 동작 파라미터화 코드 전달하기
* 동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다  
* 동작 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다
* 전략 디자인 패턴 = 각 알고리즘을 캡슐화하는 알고리즘 패밀리를 정의 해둔 다음에 런타임에 알고리즘을 선택하는 기법이다
* 자바는 클래스의 선언과 인스턴스화를 동시에 수행할 수 있도록 익명 클래스라는 기법을 제공 한다, 익명 클래스를 이용하면 코드의 양을 줄일 수 있다
* 익명 클래스는 자바의 지역 클래스와 비슷한 개념으로 생각하면 된다
* 람다를 이용하면 유연성과 간결함을 동시에 만족 할 수 있다
* 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다
* 동작 파라미터화를 이용하면 변화하는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며 나중에 엔지니어링 비용을 줄일 수 있다
* 코드 전달 기법을 이용하면 동작을 메서드의 인수로 전달 할 수 있다
* 익명 클래스로도 어느 정도 코드를 깔끔하게 만들 수 있지만 인터페이스를 상속받아 여러 클래스를 구현해야 하는 수고를 없앨 수 있다
* 자바 API의 많은 메서드는 정렬, 스레드, GUI 처리 등을 포함한 다양한 동작으로 파라미터화 할 수 있다