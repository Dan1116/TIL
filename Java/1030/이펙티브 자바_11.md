# 이펙티브 자바_11
## 직렬화
* 직렬화(Serialize)
* 자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술.
* JVM(Java Virtual Machine 이하 JVM)의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술
* 역직렬화(Deserialize)
* byte로 변환된 Data를 원래대로 Object나 Data로 변환하는 기술을 역직렬화(Deserialize)라고 부릅니다.
* 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태.

* Byte Stream은 데이터를 있는 그대로 송수신 하는 Stream. 그리고 이 Byte Stream을 이용하여 문자를 파일에 저장하는 것도 가능하다. 물론 이렇게 저장된 데이터를 자바 프로그램을 이용해서 읽으면 문제되지 않는다. 하지만 다른 프로그램을 이용해서 읽으면 문제가 될 수 있다.
* 객체 직렬화(object serialization) -> 이 API는 객체를 바이트 스트림(byte stream)으로 인코딩 하거나, 바이트 스트림 인코딩에서 객체를 복원하는 프레임워크
* 직렬화된 객체의 인코딩은 한 VM에서 다른 VM으로 전송 가능하고, 나중에 역직렬화하기 위해 디스크에 저장할 수도 있다
* 직렬화는 원격지 컴퓨터와 통신하기 위한 표준적 객체 인코딩을 제공하며, 자바빈 컴포넌트 아키텍처의 표준적 지속성 데이터 형식도 제공한다
* 직렬화 프락시 패턴(serialization proxy pattern)을 사용하면 객체 직렬화 과정에서 발생할 수 있는 많은 문제를 피하도록 도와준다

### Serializable 인터페이스를 구현할 때는 신중하라
* Serializable 구현과 관련된 가장 큰 문제는 일단 클래스를 릴리스하고 나면 클래스 구현을 유연하게 바꾸기 어려워진다는 것
* Serializable을 구현하면, 그 클래스의 바이트 스트림 인코딩도 공개 API의 일부가 되어버린다
* 사용자 정의 직렬화 형식(custom serialized form)을 설계하지 않고 기본 형식을 그대로 이용할 경우, 직렬화 형식은 영원히 클래스의 원래 내부 표현방식에 종속된다
* 기본 직렬화 형식을 받아들이면 그 클래스의 private 와 package-private 객체 필드도 공개 API가 된다는 것이다 (정보 은닉을 위해 필드의 접근 권한은 최소화해야 한다는 원칙은 효력을 잃게 된다)
* 기본 직렬화 형식을 받아들인 상태에서 나중에 클래스 내부 표현을 바꾸면, 직렬화 형식에 호환 불가능한 변화가 생길 수 있다 (옛날 버전 클래스로 만든 객체를 직렬화한 다음 새로운 버전의 클래스 객체로 역직렬화하려고 하면 프로그램에서는 오류가 발생할 것이다)
* Serializable을 구현하면 생기는 두 번째 문제는, 버그나 보완 취약점이 발생할 가능성이 높아진다는 것이다
* 보통 객체는 생성자를 통해 생성한다, 하지만 직렬화는 언어 외적인(extralinguistic) 객체 생성 메커니즘이다
* 기본 동작을 받아들이던 재정의 하던 간에 역직렬화는 생성자와 동일한 이슈를 갖고 있는 숨은 생성자다
* 역직렬화 과정에 관계된 생성자가 명시적으로 존재하지 않기 때문에, 생성자가 만족하는 모든 불변식을 보장해야 한다는 것, 그리고 생성 중인 객체의 내부에 공격자가 접근할 수 없도록 해야 한다는 것을 잊기 쉽다
* 기본 역직렬화 메커니즘을 그대로 사용할 경우, 객체는 불변식 훼손(invariant corruption)이나 불법 접근 문제에 쉽게 노출된다
* Serialization 을 구현하면 생기는 세 번째 문제는, 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다는 것이다
* 직렬화 가능 클래스를 수정할 때는, 새 릴리스에서 만들고 직렬화한 객체를 예전 릴리스에서 역직렬화할 수 있는지, 그리고 그 역도 가능한지 검사하는 것이 중요하다
* Serializable 인터페이스를 구현하면 직렬화를 통해 객체를 전송하거나 지속성 매체에 저장하는 프레임워크에 사용할 클래스라면 Serializable 구현은 필수다
* 계승을 염두에 두고 설계하는 클래스는 Serializable을 구현하지 않는 것이 바람직하다 또한 인터페이스는 가급적 Serializable을 계승하지 말아야 한다
* Throwable 이 Serializable 을 구현한 것은, 원격 메서드 호출(remote method invocation, RMI)시 발생하는 예외를 서버에서 클라이언트로 전달하기 위한 것이다
* Component가 Serializable을 구현한 것은 GUI (graphic user interface)를 전송, 보관, 복원할 수 있도록 하기 위해서다
* HttpServlet은 세션 상태를 캐시하기 위해서 Serializable을 구현한다
* 상위 클래스에 무인자(parameterless) 생성자가 없다면 직렬화 가능 하위 클래스 구현은 불가능하다
* 계승을 고려해 설계한 직렬화 불가능 클래스에는 무인자 생성자를 제공하는 것이 어떨지 반드시 따져봐야 한다
* 객체를 생성할 때는 불변식이 충족된 상태로 생성하는 것이 최선이다
* 객체 상태를 저장하는 변수들은 final로 선언 될 수 없다 (그 값을 initialize 메서드가 설정해야 하기 때문)
* 내부 클래스(inner class)는 Serializable 을 구현하면 안 된다 -> 내부 클래스에는 바깥 객체(enclosing instance)에 대한 참조를 보관하고 바깥 유효범위 (enclosing scope)의 지역 변수 값을 보관하기 위해 컴파일러가 자동으로 생성하는 인위생성 필드(synthetic field)가 있다 (익명 클래스나 지역 클래스 이름과 마찬가지로, 언어 명세서에는 이런 필드가 클래스 정의에 어떻게 들어맞는지 나와 있지 않다)
* 내부 클래스의 기본 직렬화 형식은 정의될 수 없다( ill-defined), 하지만 정적 멤버 클래스(static member class) 는 Serializable을 구현 해도 된다

### 사용자 지정 직렬화 형식을 사용하면 좋을지 따져 보라
* 대부분 가능하지만, Serializable을 구현한 클래스를 만들면서 기본 직렬화 형식을 그대로 이용하면, 기존 구현을 완전히 내버리기란 불가능하다
* 어떤 직렬화 형식이 적절할지 따져보지도 않고 기본 직렬화 형식(default serialized form)을 그대로 받아들이지 마라
* 기본 직렬화 형식을 받아들일 때는 그 인코딩이 유연성 성능 그리고 정확성 관점에서 적절하다는 판단이 서야 한다
* 사용자 정의 직렬화 형식을 설계한다면 이용하게 될 인코딩 방식과 대부분 동일할 경우에만 기본 직렬화 형식을 받아들여야 한다
* 어떤 객체의 기본 직렬화 형식은 해당 객체가 루트인 객체 그래프의 물리적 표현을 나름 효과적으로 인코딩한 것이다 (객체 안에 담긴 데이터와 해당 객체를 통해 접근할 수 있는 모든 객체에 담긴 데이터를 기술한다)
* 기본 직렬화 형식은 그 객체의 물리적 표현이 논리적 내용과 동일할 때만 적절하다
* 기본 직렬화 형식이 만족스럽다 하더라도, 불변식(Invariant)이나 보안 조건을 만족시키기 위해서는 readObject 메서드를 구현해야 하는 경우도 많다

* 객체의 물리적 표현 형태가 논리적 내용과 많이 다를 경우 기본 직렬화 형식을 그대로 받아들이면 아래의 네 가지 문제가 생긴다
* 1. 공개 API가 현재 내부 표현 형태에 영원히 종속된다 -> 연결 리스트 항목 처리에 관련된 코드를 제거하는 것은 영원히 불가능하다 ( 더 이상 연결 리스트를 사용하지 않는다 해도)
* 2. 너무 많은 공간(excessive space)을 차지하는 문제가 생길 수 있다 -> 직렬화 결과도 쓸데없이 커져서 디스크에 저장하거나 네트워크로 전송하는 속도도 너무 느려질 것이다
* 3. 너무 많은 시간을 소비하는 문제가 생길 수 있다 -> 기본 직렬화 로직은 객체 그래프 토폴로지 정보를 이해하지 못하므로, 많은 양의 그래프 순회를 해야 한다
* 4. 스택 오버플로 문제가 생길 수 있다 -> 기본 직렬화 절차는 재귀적인 객체 그래프 순회를 필요로 하는데, 설사 객체 그래프의 크기가 과도한 수준이 아니라 해도 그 과정에서 스택 오버플로 문제가 발생할 수 있다
*  새로운 스택 프레임을위한 공간이 없으면 JVM (Java Virtual Machine)에 의해 StackOverflowError가 발생합니다

* StringList 의 적절한 직렬화 형식은 그저 리스트에 담기는 문자열의 수 다음에 실제 문자열들이 오는 형태일 것이다 -> StringList의 논리적 데이터 형태만을 나타내는 형식으로서, 물리적 표현 형태에 대한 세부사항은 제거된 것이다
* transient는 Serialize하는 과정에 제외하고 싶은 경우 선언하는 키워드
* 왜(Why) 필요할까요?
패스워드와 같은 보안정보가 직렬화(Serialize) 과정에서 제외하고 싶은 경우에 적용합니다.
* 다양한 이유로 데이터를 전송을 하고 싶지 않을 때 선언할 수 있습니다.
* 객체의 모든 필드가 transient 일 때는 defaultWriteObject 나 defaultReadObject를 호출하지 않는 것도 기술적으로 가능하긴 하지만 권장하는 사항은 아니다
* 기본 직렬화 형식을 사용하건 말건, transient 로 선언되지 않은 모든 객체 필드는 defaultWriteObject 메서드가 호출될 때 직렬화된다
* 객체의 논리적 상태를 구성하는 값이라는 확신이 들기 전에는 비- transient 필드로 만들어야겠다는 결정을 내리지 마라
* 기본 직렬화 형식을 사용하는 경우, transient 레이블이 붙은 필드들은 역직렬화 되었을 때 기본값으로 초기화된다
* 기본 직렬화 형식 사용 여부에 상관없이, 객체를 직렬화 할 때는 객체의 상태 전부를 읽는 메서드에 적용할 동기화 수단을 반드시 적용해야 한다
* 어떤 직렬화 형식을 이용하건, 직렬화 가능 클래스를 구현할 때는 직렬 버전 UID(serial version UID)를 명시적으로 선언해야 한다

### readObject 메서든느 방어적으로 구현하라
* readObject는 바이트 스트림(byte stream)을 인자로 받는 생성자다, 일반적으로 이 바이트 스트림은 정상적인 과정을 통해 만들어진 객체를 직렬화한 결과다, 문제는 인공적으로 만들어진 바이트 스트림을 readObject에 인자로 넘길 때 생긴다 ( 클래스 불변식을 위반하는 객체를 만들어 낼 수 있게 되는 것이다)
* 객체를 역으로 직렬화할 때는 클라이언트가 가질 수 없어야 하는 객체 참조를 담은 모든 필드를 방어적으로 복사하도록 해야 한다 (private 로 선언된 변경 가능 컴포넌트가 있는 모든 직렬화 가능 변경 불가능 클래스는 해당 컴포넌트들을 readObject 메서드 안에서 방어적으로 복사해야 한다)
* 방어적 복사에는 Date의 clone 메서드를 사용하지 않는다는 것
* final로 선언된 필드에는 방어적 복사를 할 수 없다
* readObject 메서드를 사용하려면 start와 end는 비-final로 선언해야 한다
* writeUnshard 와 readUnshared 는 사용하지 말아라 -> 방어적 복사를 하는 것보다 빠르긴 하겠지만, 필요한 안전성을 제공하지 못한다
* 어떤 바이트 스트림이 주어지더라도 유효한 객체가 생성될 수 있도록 해야 한다

* readObject 메서드를 구현하고자 할 때 따라야 하는 지침들
* private 로 남아있어야 하는 객체 참조 필드를 가진 클래스는 그런 필드가 가리키는 객체를 방어적으로 복사해야 한다 (변경 불가능 클래스의 변경 가능 컴포넌트가 이 범주에 해당)
* 불변식을 검사해서 위반된 사실이 감지될 경우 InvalidObjectException을 던져라 (불변식 검사는 방어적 복사 이후에 시행해야 한다)
* 만일 객체를 완전히 역직렬화 한 다음에 전체 객체 그래프의 유효성을 검사해야 한다면, ObjectInputValidation 인터페이스를 이용하라 
* 직접적이던 간접적이던, 재정의 가능 메서드를 호출하지 말아라

### 개체 통제가 필요하다면 readResolve 대신 enum 자료형을 이용하라
* 선언부에 implements Serializable 을 붙이는 순간 이 클래스는 더 이상 싱글턴 클래스가 아니다
* 모든 readObject 메서드는 새로 생성된 객체를 반환하는데, 이 객체는 클래스가 초기화될 당시에 만들어진 객체와 같은 객체가 아니다
* readResolve를 이용하면 readObject가 만들어낸 객체를 다른 것으로 대체할 수 있다, 역직렬화할 때 객체의 클래스에 제대로 선언된 readResolve 메서드가 정의되어 있는 경우, 역직렬화가 끝나서 만들어진 객체에 대해 이 메서드가 호출된다
* 대부분의 경우 readResolve 호출이 끝나면 readObject가 만든 객체에 대한 참조는 사라지므로 바로 쓰레기 수집이 가능해진다
* 개체 통제를 위해 readResolve를 활용할 때는, 객체 참조 자료형으로 선언된 모든 객체 필드를 반드시 transient로 선언해야 한다 (그렇지 않으면 readResolve 메서드가 실행되기 전에 역직렬화된 객체에 대한 참조를 가로챌 수 있게 된다)
* readResolve 메서드의 접근 권한은 중요하다 (readResolve 메서드를 final 클래스에 두는 경우에는 반드시 private 로 선언해야 한다, 비-final 클래스에 둘 때는 접근 권한을 신중하게 정해야 한다)
* private 라면 하위 클래스에는 적용되지 않는다, package-private 인 경우에는 같은 패키지에 있는 하위 클래스들에만 적용된 것이다
* 개체 수와 관련된 불변식을 강제하고 싶을 때는 가능하면 enum을 이용하라 (그럴 상황이 아닌데도 직렬화가 가능하며 개체 수 통제가 가능한 클래스가 필요하다면, 반드시 readResolve 메서드를 구현해야 하고 클래스의 모든 객체 필드는 기본 자료형으로 하거나 transient 로 선언해야 한다

### 직렬화된 객체 대신 직렬화 프락시를 고려해 보라
* Serializable 인터페이스를 구현하겠다는 결정을 내리게 되면 버그나 보안 결함이 생길 가능성이 높아진다 (일반 생성자 대신 언어 외적인 메커니즘을 통해 객체를 생성할 수 있게 되기 때문에) -> 이런 위험을 크게 줄일 수 있는 기술이 직렬화 프락시 패턴 (serialization proxy pattern)
* 직렬화 프락시 패턴 -> 바깥 클래스 객체의 논리적 상태를 간결하게 표현하는 직렬화 가능 클래스를 private static 중첩 클래스로 설계 -> 이 중첩 클래스를 직렬화 프락시라고 부른다 (바깥 클래스를 인자 자료형으로 사용하는 생성자를 하나만 가진다)
* 이 생성자는 인자에서 데이터를 복사하기만 한다, 일관성 검사를 할 필요도 없고 방어적 복사를 할 필요도 없다 (설계상 직렬화 프락시의 기본 직렬화 형식은 바깥 클래스의 완벽한 직렬화 형태), 바깥 클래스뿐 아니라 직렬화 프락시도 반드시 Serializable 인터페이스를 구현한다고 선언되어야 한다
* 역직렬화된 객체도 일반 객체와 마찬가지로 생성자, 정적 팩터리, 일반 메서드를 통해 만들므로, 직렬화의 언어 외부적(extralinguistic) 특성이 대부분 제거 되는 것 -> 그 덕에 역직렬화된 객체가 클래스 불변식을 준수하도록 하기 위해 별도의 수단을 동원할 필요가 없다
* 클래스의 정적 팩터리나 생성자가 불변식을 만족하는 객체를 만들고, 객체 메서드가 그 불변식을 보존하기만 하면, 직렬화 전후로도 불변식은 보존될 것이다
* 방어적 복사 접근법과 마찬가지로 직렬화 프락시 접근법도 가짜 바이트 스트림을 통한 공격을 방지하며 내부 필드 탈취 공격도 저절로 중단되도록 만든다
* 직렬화 프락시 접근법을 이용하면 Period의 필드를 final로 선언할 수 있어서, Period를 진정한 변경 불가능 클래스로 만들 수 있다
* 직렬화 프락시 패턴을 이용하면 역직렬화된 객체가 애초에 직렬화된 객체와 다른 클래스가 되도록 만들 수 있다

* 직렬화 프락시 패턴에는 두가지 제약이 있다 ->
* 클라이언트가 확장 할 수 있는 클래스에는 적용할 수 없는 기법
* 객체 그래프에 순환되는 부분(circularity)이 있는 클래스에는 적용할 수 없다
* 어떤 객체의 메서드를 그 객체의 직렬화 프락시의 readResolve 안에서 호출하려면 ClassCastException이 발생할 것인데, 직렬화 프락시는 가졌으나 아직 실제 객체를 가진 것은 아니기 때문
