# 이펙티브자바_정리_(1101)
## 질문
* 형변환 = cast
* 형 안정성 -> 타입에 대한 제약이 얼마나 강하냐, 
* hook -> 클래스 내부 동작에 개입할 수 있는 훅(hook)을 신중하게 고른 protected 메서드 형태로 제공해야 한다
* 믹스인 -> 인터페이스는 믹스인(mixin)을 정의하는데 이상적,  추상 클래스는 믹스인 정의에는 사용할 수 없다
* 상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다
* 중첩 클래스의 4가지 종류 -> 정적 멤버 클래스 , 비 정적 멤버 클래스 , 익명 클래스, 지역 클래스
* 멤버 클래스 앞에는 왜 되도록이면 static 을 붙여야 하는가 -> 정적클래스로 만들어야 하는 이유
* 형인자 자료형
* 무인자 자료형
* 제네릭 자료형
* 재귀적 자료형
* 와일드카드 자료형
* 자료형 토큰 = 컴파일 시간 자료형이나 실행시간 자료형 정보를 메서드들에 전달할 목적으로 class 리터럴을 이용하는 경우

* 정적 팩토리 -> 정적 팩터리를 사용하면 클라이언트는 새로운 객체를 만드는 대신 기존 객체들을 공유하게 되므로 메모리 요구량과 쓰레기 수집 비용이 줄어든다
* 동적 팩토리 = run time ?

* 캐시 설명 = 변경 불가능 클래스는 자주 사용하는 객체를 캐시(cache)하여 이미 있는 객체가 거듭 생성되지 않도록 하는 정적 팩터리를 제공할 수 있다 -> 정적 팩터리를 사용하면 클라이언트는 새로운 객체를 만드는 대신 기존 객체들을 공유하게 되므로 메모리 요구량과 쓰레기 수집 비용이 줄어든
* 리플렉션 =클래스의 구조를 코딩으로 알 수 있고 값을 가져오거나 함수(메소드)를 콜 할수 있습니다.
* 리플렉션은 조합(Composition)과 함께 사용되어 다형성을 구현하는 강력한 도구, 조합을 사용하여 교체할 수 있는 위임 클래스를 리플랙션을 통해 동적/정적으로 생성하고 교체하는 방식으로 사용. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용되는 방식
* varargs = 가변인수는 컴파일러의 눈속임과 비슷하다. 파라미터의 앞에 ...을 붙여주면 컴파일러가 파라미터를 배열 형식으로 바꾸어버리고, 매개변수로 주어지는 변수들을 모아서 객체로 만들어버린다.
(varargs는 정말로 임의 개수의 인자를 처리할 수 있는 메서드를 만들어야 할 때만 사용)
* 객체 상태를 저장하는 변수들은 final로 선언 될 수 없다 (그 값을 initialize 메서드가 설정해야 하기 때문)
* 언어 명세서
* mixin = 

### 이팩티브자바_복습
* 코드는 복사하는게 아니라 재사용해야 한다, 모듈 간 의존성은 가능한 줄여야 한다
* 클래스 멤버 = 필드, 메서드, 멤버 클래스, 멤버 인터페이스
* API = Application Programming Interface, 응용 프로그래밍 인터페이스, 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 
있도록 만든 인터페이스
* 자바빈 패턴 = 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정 메서드들을 호출하여 필수 필드 뿐 아니라 선택적 필드의 값들까지 체울 수 있다 => 하지만, 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성(consistency)이 일시적으로 깨질 수 있다, 또한 자바빈 패턴으로는 변경 불가능한 클래스를 만들 수 없다는 것이다
* 빌더 패턴 = 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달, 빌더 객체를 만든다, 그 후 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다, 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만든다 (빌더 클래스는 빌더가 만드는 객체 클래스의 정적 멤버 클래스로 정의)
* 생성자와 마찬가지로, 빌더 패턴을 사용하면 인자에 불변식을 적용할 수 있다, build 메서드 안에서 해당 불변식이 위반되었는지 검사할 수 있는 것이다(빌더 객체에서 실제 객체로 인자가 복사된 다음에 불변식들을 검사할 수 잇다는 것, 그리고 그 불변식을 빌더 객체의 필드가 아니라 실제 객체의 필드를 두고 검사할 수 잇다는 것이 중요)
* private 생성자를 클래스에 넣어서 객체 생성을 방지할 수 있다 (하위 클래스도 만들 수 없다)
* 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의
* 종료자(finalizer) 는 예측 불가능하며, 대체로 위험하고 일반적으로 불필요하다, 종료자의 한 가지 단점은 즉시 실행되리라는 보장이 전혀 없다는 것이다 (따라서 긴급한 작업을 종료자 안에서 처리하면 안 된다)
*  동치 관계 = 반사율, 대칭률, 추이율이라는 특별한 세 가지 성질을 만족하는 관계를 말한다
* 객체 복제를 지원하는 좋은 방법은(clone), 복사 생성자(copy constructor) 나 복사 팩터리 (copy factory)를 제공하는 것
*  변경 불가능 클래스는 자주 사용하는 객체를 캐시(cache)하여 이미 있는 객체가 거듭 생성되지 않도록 하는 정적 팩터리를 제공할 수 있다 -> 정적 팩터리를 사용하면 클라이언트는 새로운 객체를 만드는 대신 기존 객체들을 공유하게 되므로 메모리 요구량과 쓰레기 수집 비용이 줄어든다
*  계승을 허용하려면 반드시 따라야 할 제약사항이 있다 -> 생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안 된다는 것
* 제네릭을 사용하면 컬렉션에 넣는 객체의 자료형이 무엇인지 컴파일러에게 알릴 수 있다
* 인자 리스트(parameter list)를 길게 만들지 말아라 (4개 이하가 좋다) -> 너무 길면 복잡해진다


### 클래스와 멤버의 접근 권한은 최소화
* 잘 설계된 모듈은 구현 세부사항을 전부 API 뒤쪽에 감춘다 -> 정보 은닉 ( information hiding), 캡슐화 (encapsulation) 
* 정보 은닉이 시스템을 구성하는 모듈 사이의 의존성을 낮춰서 각자 개별적으로 개발하고 , 시험하고, 최적화하고, 이해하고, 변경할 수 있도록 한다는 사실에 기초
* 정보 은닉 원칙은 소프트웨어의 재사용 가능성을 높인다 ( 모듈간 의존성이 낮아지므로)
* 각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들어야 한다

### equals를 재정의할 때는 반드시 hashCode도 재정의
* 많은 버그가 hashCode 메서드를 재정의하지 않아서 생긴다
* 같은 객체는 같은 해시 코드 값을 가져야 한다
* 중복 필드( redundant field)는 해시 코드 계산 과정에서 제외해도 된다
* 성능을 개선하려고 객체의 중요 부분을 해시 코드 계산 과정에서 생략하면 안 된다는 것이다

### 생성자 대신 정적 팩토리 메서드를 사용할 수 없는지 생각해보기
* 생성자와는 달리 정적 팩터리 메서드에 이름이 있다는 것
* 정적 팩터리 메서드는 이름을 잘 짓기만 한다면 클라이언트 코드의 가독성(readability) 도 높아진다
* 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다는 것, 정적 팩터리 메서드는 사용하면 같은 객체를 반복해서 반환 할 수 있다
* 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환 할 수 있다
* 형인자 자료형(parameterized type (List(String))) 객체를 만들 때 편하다는 점
* 무엇을 생성하는지 명시할 수 있다

### 정적 팩토리의 단점
* 정적 팩터리 메서드만 있는 클래스를 만들면 생기는 가장 큰 문제는, public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다
* 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는 다는 단점이 있다

### 추상 클래스 대신 인터페이스를 사용하라
* 추상 클래스는 구현된 메서드를 포함할 수 있지만, 인터페이스는 아니다
* 추상 클래스가 규정하는 자료형을 구현하기 위해서는 추상 클래스를 반드시 계승해야 한다
* 이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다
* 인터페이스는 믹스인(mixin)을 정의하는데 이상적
* 추상 클래스는 믹스인 정의에는 사용할 수 없다

### 멤버 클래스는 가능하면 static 으로 선언
* 중첩 클래스는 (nested class) 다른 클래스 안에 정의된 클래스다
* 중첩 클래스의 4가지 종류 -> 정적 멤버 클래스 , 비 정적 멤버 클래스 , 익명 클래스, 지역 클래스
* 정적 멤버 클래스 빼고는 전부 내부 클래스 (inner class)
* 정적 멤버 클래스는 바깥 클래스의 모든 멤버에( private로 선언된 것들도 ) 접근 가능, 정적 멤버 클래스를 private로 선언했다면 해당 중첩 클래스에 접근할 수 있는 것은 바깥 클래스 뿐이다
* 비 정적 멤버 클래스 객체는 바깥 클래스 객체와 자동적으로 연결, 비 정적 멤버 클래스 안에서는 바깥 클래스의 메서드를 호출할 수 있고, this 한정(qualified this)구문을 통해 바깥 객체에 대한 참조를 획득할 수 있다, 비 정적 멤버 클래스는 바깥 클래스 객체 없이는 존재할 수 없다
* 비 정적 멤버 클래스 객체와 바깥 객체와의 연결은 비 정적 멤버 클래스의 객체가 만들어지는 순간에 확립, 그 뒤에는 변경 할 수 없다
* 비 정적 멤버 클래스는 어댑터를 정의할 때 많이 쓰인다
* 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 때는 항상 선언문 앞에 static 을 붙여서 비 정적 멤버 클래스 대신 정적 멤버 클래스로 만들자
* private 정적 멤버 클래스는 바깥 클래스 객체의 컴포넌트를 표현하는데 많이 쓰인다
* 익명 클래스 = 멤버로 선언하지 않으며, 사용하는 순간에 선언하고 객체를 만든다, 비정적 문맥(nonstatic context) 안에서 사용될 때만 바깥 객체를 갖는다, 하지만 안에서 사용된다 해도 static 멤버를 가질 수는 없다
* 익명 클래스는 선언하는 그 순간에만 객체를 만들 수 있고, instanceof, 클래스 이름이 필요한 곳에는 사용할 수 없다
* 익명 클래스의 클라이언트는 상위 자료형에서 상속된 멤버만 호출할 수 있다
* 익명 클래스는 함수객체를 정의할 때 쓰인다
* 지역 클래스는 지역 변수가 선언될 수 있는 곳이라면 어디서든 선언 할 수 있으며 지역 변수와 동일한 유효범위 규칙을 따른다. 
* 지역 클래스는 멤버 클래스처럼 이름을 가지며, 반복적으로 사용될 수 있다, 익명 클래스처럼 비 정적 문맥에서 정의했을 때만 바깥 객체를 갖는다, static 멤버는 가질 수 없다

### 배열 대신 리스트를 써라
* 배열은 공변 자료형(covariant), 실제화 (reification) 이 되는 자료형 -> 배열의 각 원소의 자료형은 실행시간에 결정
* 제네릭은 불변 자료형(invariant), 실행 시간에 형인자 정보는 삭제  -> 자료형에 관계된 조건들을 컴파일 시점에만 적용, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다는 것

### int 상수 대신 enum을 사용해라
* enum 자료형은 실질적으로는 final로 선언된 것이나 마찬가지, 클라이언트가 접근할 수 있는 생성자가 없기 때문에 enum 자료형으로 새로운 객체를 생성하거나 계승을 통해 확장할 수 없기 때문에 , 이미 선언된 enum 상수 이외의 객체는 사용할 수 없다
* enum 자료형은 toString 메서드를 호출하면 인쇄 가능 문자열로 쉽게 변환
* enum 자료형은 임의의 메서드나 필드도 추가 할 수 있고, 임의의 인터페이스를 구현할 수도 있다
* enum 상수에 데이터를 넣으려면 객체 필드(instance field)를 선언하고 생성자를 통해 받은 데이터를 그 필드에 저장하면 된다
* enum 생성자 안에서는 enum의 static 필드를 접근할 수 없다(컴파일 시점에 상수인 static 필드는 제외), 생성자가 실행될 때 static 필드는 초기화된 상태가 아니기 때문에 필요한 제약
* 외부 (external) enum 자료형 상수별로 달리 동작하는 코드를 만들어야 할 때는 enum 상수에 switch 문을 적용하면 좋다
* enum을 사용해야할 때는 고정된 상수 집합이 필요할 때
* enum을 사용한 코드는 가독성도 높고, 안전하며, 더 강력, 상당수의 enum은 생성자나 멤버가 필요 없으나, 데이터 또는 그 데이터에 관계된 메서드를 추가해서 기능을 향상 시킨 enum도 많다

### 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용
* enum 자료형이 임의의 인터페이스를 구현할 수 있으므로 연산 코드 자료형에 대한 인터페이스를 먼저 정의하고 해당 인터페이스를 구현하는 enum 자료형을 만들면 이 enum 자료형은 해당 인터페이스의 표준 구현 역할을 하게 된다
* 계승 가능 enum 자료형은 만들 수 없지만, 인터페이스를 만들고 그 인터페이스를 구현하는 기본 enum 자료형을 만들면 계승 가능 enum 자료형을 흉내 낼 수 있다

### 작명 패턴 대신 어노테이션을 사용하라
* 작명 패턴의 단점 -> 철자를 틀리면 알아채기 힘들다, 특정한 프로그램 요소에만 적용되도록 만들 수 없다는 것, 프로그램 요소에 인자를 전달할 마땅한 방법이 없다
* 어노테이션은 이 위의 문제점들을 해결할 수 있다
* 어노테이션 자료형 선언부에 붙는 어노테이션은 메타 어노테이션이라 부른다
* 표식 어노테이션 = 아무 인자도 받지 않으며, 어노테이션이 적용된 프로그램 요소에 특정한 표식을 다는 구실만 한다

### 오버로딩할 때는 주의하라
* 오버로딩된 메서드 가운데 어떤 것이 호출될지는 컴파일 시점에 결정 된다
* 오버로딩된 메서드는 정적(static)으로 선택되지만, 재정의된 메서드는 동적(dynamic)으로 선택 된다
* 하위 클래스에서 재정의한 메서드를 하위 클래스 객체에 대해 호출하면, 해당 객체의 컴파일 시점 자료형과는 상관없이, 항상 하위 클래스의 재정의 메서드가 호출
* 실행될 메서드는 컴파일 시에, 인자의 컴파일 시점 자료형만을 근거로 결정
* 혼란을 피하는 안전하고 보수적인 전략은, 같은 수의 인자를 갖는 두 개의 오버로딩 메서드를 API에 포함시키지 않는 것이다
* 생성자가 많다면, 그 생성자들은 항상 오버로딩 된다 -> 이게 문제라면 생성자 대신 정적 팩터리 메서드를 사용하는 옵션을 사용할 수도 있다
* 두 자료형을 서로 형변환(cast)할 수 없다면 확실히 다른 것이다, 관련성이 없는 클래스는 서로 완전히 다른 클래스

### null 대신 빈 배열이나 컬렉션을 반환하라
* 컬렉션을 반환하는 메서드도 빈 컬렉션을 반환해야 할 때마다 동일한 변경 불가능 빈 컬렉션 객체를 반환하도록 구현할 수 있다
* null 대신에 빈 배열이나 빈 컬렉션을 반환, null 값을 반환하는 것은 C 언어에서 전해진 관습으로, C 에서는 배열의 길이가 배열과 따로 반환

### 지역 변수의 유효범위를 최소화
* 클래스와 멤버의 접근 권한은 최소화
* 지역 변수의 유효범위를 최소화하면 가독성(readability)과 유지보수성(maintainability) 이 좋아지고 오류 발생 가능성도 줄어든다
* 거의 모든 지역 변수 선언에는 초기값(initializer)이 포함되어야 한다
* while 문보다는 for 문을 쓰는 것이 좋다 -> 순환문 변수의 내용은 순환문 수행이 끝난 이후에는 필요 없다는 가정하에
* for 문을 사용할 때는 순환문마다 다른 이름의 변수를 이용할 필요가 없기 때문에, 복사해서 붙여넣기 버그가 발생할 가능성은 더욱 줄어든다 그리고 각각의 for 문은 서로 의존성이 없으므로, 같은 변수명을 거듭 사용해도 괜찮다

### for 문보다는 for-each 문을 사용하라
* for-each문의 성능은 for 문과 같다(배열에도 마찬가지), for-each문의 장점은 여러 컬렉션에 중첩되는 순환문을 만들어야 할 때
* for-each 문으로는 컬렉션과 배열뿐 아니라 Iterable 인터페이스를 구현하는 어떤 객체도 순회할 수 있다 ( Iterable 인터페이스는 메서드가 하나뿐인 아주 간단한 인터페이스)
* for-each 문을 적용할 수 없는 것들 -> 필터링(filtering), 컬렉션을 순회하다가 특정한 원소를 삭제할 필요가 있다면, 반복자를 명시적으로 사용해야 한다. 반복자의 remove 메서드를 호출해야 하기 때문/ 변환(transforming), 리스트나 배열을 순회하다가 그 원소 가운데 일부 또는 전부의 값을 변경해야 한다면, 원소의 값을 수정하기 위해서 리스트 반복자나 배열 첨자가 필요/ 병렬 순회(parallel iteration), 여러 컬렉션을 병렬적으로 순회해야 하고, 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구현해야 한다면 반복자나 첨자 변수를 명시적으로 제어할 필요가 있다

### 객체화된 기본 자료형 대신 기본 자료형을 이용하라
* 모든 자료형에는 대응되는 참조 자료형이 있는데, 이를 객체화된 기본 자료형(boxed primitive type)이라 부른다
* 기본 자료형과 객체화된 기본 자료형 사이에는 세가지 큰 차이점이 있다 -> 
* 1. 기본 자료형은 값만 가지지만 객체화된 기본 자료형은 값 외에도 신원(identity)을 가진다는 것 (객체화된 기본 자료형 객체가 두 개 있을 때, 값은 같더라도 신원은 다를 수 있다) 
* 2. 기본 자료형에 저장되는 값은 전부 기능적으로 완전한 값이지만, 객체화된 기본 자료형에 저장되는 값에는 그 이외에도 아무 기능도 없는 값, 즉 null이 하나 있다는 것. 
* 3. 기본 자료형은 시간이나 공간 요구량 측면에서 일반적으로 객체 표현형보다 효율적
* 객체화된 기본 자료형에 == 연산자를 사용하는 것은 거의 항상 오류
* 기본 자료형과 객체화된 기본 자료형을 한 연산 안에 엮어 놓으면 객체화된 기본 자료형은 자동으로 기본 자료형으로 변환된다
* 자동 객체화는 번거로운 일을 줄여주긴 하지만, 객체화된 기본 자료형을 사용할 때 생길 수 있는 문제들까지 없애주진 않는다
* 객체화된 기본 자료형과 기본 자료형을 한 표현식 안에 뒤섞으면 비객체화가 자동으로 일어나며, 그 과정에서 NullPointerException이 발생할 수 있다

### 일반적으로 통용되는 작명 관습을 따라라
* 패키지 이름은 마침표를 구분점으로 사용하는 계층적 이름이어야 한다, 패키지 이름을 구성하는 각각의 컴포넌트는 알파벳 소문자로 구성하고, 숫자는 거의 사용하지 않는다, 패키지 이름의 나머지 부분은 어떤 패키지인지 설명하는 하나 이상의 컴포넌트로 구성, 패키지명 가운데 상당수는 인터넷 도메인 이름 이외에 단 하나의 컴포넌트만 사용
* enum이나 어노테이션 자료형 이름을 비롯, 클래스나 인터페이스 이름은 하나 이상의 단어로 구성, 각 단어의 첫 글자는 대문자
* 메서드와 필드 이름은 클래스나 인터페이스 이름과 동일한 철자 규칙을 따른다, 다만 첫 글자는 소문자
* 상수 필드의 이름을 지을 때는 상수 필드의 이름은 하나 이상의 대문자 단어로 구성, 단어 사이에는 밑줄 기호(_)를 둔다
* 지역 변수 이름은 멤버 이름과 같은 철자 규칙을 따른다(약어가 허용)

* 패키지 = com.google.inject, org.joda.time.format
* 클래스나 인터페이스 = Timer, FutureTask, LinkedHashMap, HttpServlet
* 메서드나 필드 = Remove, ensureCapacity, getCrc
* 상수 필드 = MIN_VALUE, NEGATIVE_INFINITY
* 지역 변수 = i, xref, houseNumber
* 자료형 인자 = T, E, K, V, X, T1, T2

### 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
* 자바는 세 가지 종류의 throwable 을 제공 ->
* 1. 점검지정 예외(checked exception)
* 2. 실행지점 예외(runtime exception)
* 3. 오류 (error)
* 점검지정 예외를 사용할 것인지 무점검 예외를 사용할 것인지에 대한 규칙은, 호출자 측에서 복구할 것으로 여겨지는 상황에 대해서는 점검지정 예외를 이용해야 한다는 것이다
* 메서드에 선언된 점검지정 예외는 메서드를 호출하면 해당 예외와 관계된 상황이 발생할 수 있음을 API 사용자에게 알리는 구실을 한다
* API 사용자에게 점검지정 예외를 준다는 것은, 그 상태를 복구할 권한을 준다는 뜻
* 프로그램이 무점검 예외나 오류를 던진다는 것은 복구가 불가능한 상황에 직면했다는 뜻으로, 더 진행해 봐야 득보다 실이 더 크다는 뜻
* 프로그래밍 오류를 표현할 때는 실행시점 예외를 사용하라
* 대부분의 실행시점 예외는 선행조건 위반(precondition violation)을 나타낸다
* 사용자 정의 무점검 throwable은 RuntimeException의 하위 클래스로 만들어야 한다 (직접적이던 간접적이던 간에)
* Exception이나 RuntimeException 또는 Error의 하위 클래스가 아닌 throwable도 정의할 수 있다
* 복구 가능한 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류를 나타내고 싶을 때는 실행시점 예외를 사용하라

### 변경 가능 공유 데이터에 대한 접근은 동기화하라
* 동기화 (synchronized) 키워드는 특정 메서드나 코드 블록을 한 번에 한 스레드만 사용 하도록 보장한다
* 많은 프로그래머는 동기화(synchronization)를 상호 배제적(mutually exclusive)인 관점, 그러니까 다른 스레드가 변경 중인 객체의 상태를 관측할 수 없어야 한다는 관점으로만 바라본다
* 객체는 일관된(consistent) 상태를 갖도록 생성되며, 해당 객체를 접근하는 메서드는 그 객체에 락(lock)을 건다
* 락을 건 메서드는 객체의 상태를 관측할 수 있으며, 선택적으로 객체 상태를 변경할 수도 있다, 하나의 일관된 상태에서 다른 일관된 상태로 전이 시킬 수 있다는 것
* 동기화 메커니즘을 적절히 사용하기만 하면, 모든 메서드가 항상 객체의 일관된 상태만 보도록 만들 수 있다
* 동기화 없이는 한 스레드가 만든 변화를 다른 스레드가 확인할 수 없다
* 동기화는 스레드가 일관성이 깨진 객체를 관측할 수 없도록 할 뿐 아니라, 동기화 메서드나 동기화 블록에 진입한 스레드가 동일한 락의 보호 아래 이루어진 모든 변경(modification)의 영향을 관측할 수 있도록 보장
* 자바 언어 명세에는 long 이나 double이 아닌 모든 변수는 원자적(atomic) 으로 읽고 쓸 수 있다고 되어 있다
* 언어 명세상으로는 필드에서 읽어낸 값은 임의의 값이 될 수 없다고 되어 있으나, 그렇다고 어떤 스레드가 기록한 값을 반드시 다른 스레드가 보게 되리라는 보장은 없다
* 상호 배제성뿐 아니라 스레드 간의 안정적 통신을 위해서도 동기화는 반드시 필요 (메모리 모델 때문)
* 메모리 모델은 한 스레드가 만든 변화를 다른 스레드가 볼 수 있게 되는 시점과 그 절차를 규정
* 변경 가능한 공유 데이터에 대한 접근을 동기화하지 않았을 때 생길 수 있는 결과는, 그 데이터가 원자적으로 읽고 쓸 수 있는 데이터라 해도 심각하다
* Thread.stop은 절대 이용하지 마라, false로 초기화되는 boolean 필드를 이용하는 것이 바람직, 한 스레드는 이 필드의 값이 true로 바뀌는지 계속 검사해서 true로 바뀌면 실행을 스스로 중단하고, 해당 스레드를 중지시켜야 하는 다른 스레드는 필요할 때 해당 필드의 값을 true로 바꿔주면 된다
* 읽기 연산과 쓰기 연산에 전부 적용하지 않으면 동기화는 아무런 효과도 없다
* 어떤 스레드건 가장 최근에 기록된 값을 읽도록 보장
* 변경 가능 데이터는 한 스레드만 이용하도록 하라는 것
* 특정한 스레드만이 데이터 객체를 변경할 수 있도록 하고, 변경이 끝난 뒤에 다른 스레드와 공유하도록 할 때는 객체 참조를 공유하는 부분에만 동기화를 적용
* 실질적으로 변경 불가능한 객체(effectively immutable) -> 객체 참조를 가져온 스레드는, 객체가 더 이상 수정되지 않는 한, 동기화 없이도 객체의 내용을 읽을 수 있다
* 이런 객체 참조를 다른 스레드로 전달하는 행위를 안전한 발행이라고 부른다
* 변경 가능한 데이터를 공유할 때는 해당 데이터를 읽거나 쓰는 모든 스레드는 동기화를 수행해야 한다는 것
* static 필드를 변경하는 메서드가 있을 때는 해당 필드에 대한 접근을 반드시 동기화해야 한다 ( 보통 한 스레드만 이용하는 메서드라 해도 그렇다 )

###  Serializable 인터페이스를 구현할 때는 신중하라
* Serializable 구현과 관련된 가장 큰 문제는 일단 클래스를 릴리스하고 나면 클래스 구현을 유연하게 바꾸기 어려워진다는 것
* Serializable을 구현하면, 그 클래스의 바이트 스트림 인코딩도 공개 API의 일부가 되어버린다
* Serializable을 구현하면 생기는 두 번째 문제는, 버그나 보완 취약점이 발생할 가능성이 높아진다는 것이다
* 보통 객체는 생성자를 통해 생성한다, 하지만 직렬화는 언어 외적인(extralinguistic) 객체 생성 메커니즘이다
* 기본 역직렬화 메커니즘을 그대로 사용할 경우, 객체는 불변식 훼손(invariant corruption)이나 불법 접근 문제에 쉽게 노출된다
* Serialization 을 구현하면 생기는 세 번째 문제는, 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다는 것이다
* 직렬화 가능 클래스를 수정할 때는, 새 릴리스에서 만들고 직렬화한 객체를 예전 릴리스에서 역직렬화할 수 있는지, 그리고 그 역도 가능한지 검사하는 것이 중요하다
* 계승을 염두에 두고 설계하는 클래스는 Serializable을 구현하지 않는 것이 바람직하다 또한 인터페이스는 가급적 Serializable을 계승하지 말아야 한다
* 상위 클래스에 무인자(parameterless) 생성자가 없다면 직렬화 가능 하위 클래스 구현은 불가능하다
* 객체를 생성할 때는 불변식이 충족된 상태로 생성하는 것이 최선이다
* 객체 상태를 저장하는 변수들은 final로 선언 될 수 없다 (그 값을 initialize 메서드가 설정해야 하기 때문)
* 내부 클래스(inner class)는 Serializable 을 구현하면 안 된다 -> 내부 클래스에는 바깥 객체(enclosing instance)에 대한 참조를 보관하고 바깥 유효범위 (enclosing scope)의 지역 변수 값을 보관하기 위해 컴파일러가 자동으로 생성하는 인위생성 필드(synthetic field)가 있다 (익명 클래스나 지역 클래스 이름과 마찬가지로, 언어 명세서에는 이런 필드가 클래스 정의에 어떻게 들어맞는지 나와 있지 않다)
* 내부 클래스의 기본 직렬화 형식은 정의될 수 없다( ill-defined), 하지만 정적 멤버 클래스(static member class) 는 Serializable을 구현 해도 된다

### 객체의 물리적 표현 형태가 논리적 내용과 많이 다를 경우 기본 직렬화 형식을 그대로 받아들이면 아래의 네 가지 문제가 생긴다
* 1. 공개 API가 현재 내부 표현 형태에 영원히 종속된다 -> 연결 리스트 항목 처리에 관련된 코드를 제거하는 것은 영원히 불가능하다 ( 더 이상 연결 리스트를 사용하지 않는다 해도)
* 2. 너무 많은 공간(excessive space)을 차지하는 문제가 생길 수 있다 -> 직렬화 결과도 쓸데없이 커져서 디스크에 저장하거나 네트워크로 전송하는 속도도 너무 느려질 것이다
* 3. 너무 많은 시간을 소비하는 문제가 생길 수 있다 -> 기본 직렬화 로직은 객체 그래프 토폴로지 정보를 이해하지 못하므로, 많은 양의 그래프 순회를 해야 한다
* 4. 스택 오버플로 문제가 생길 수 있다 -> 기본 직렬화 절차는 재귀적인 객체 그래프 순회를 필요로 하는데, 설사 객체 그래프의 크기가 과도한 수준이 아니라 해도 그 과정에서 스택 오버플로 문제가 발생할 수 있다
*  새로운 스택 프레임을위한 공간이 없으면 JVM (Java Virtual Machine)에 의해 StackOverflowError가 발생합니다

### 직렬화된 객체 대신 직렬화 프락시를 고려해 보라
* Serializable 인터페이스를 구현하겠다는 결정을 내리게 되면 버그나 보안 결함이 생길 가능성이 높아진다 (일반 생성자 대신 언어 외적인 메커니즘을 통해 객체를 생성할 수 있게 되기 때문에) -> 이런 위험을 크게 줄일 수 있는 기술이 직렬화 프락시 패턴 (serialization proxy pattern)
* 직렬화 프락시 패턴 -> 바깥 클래스 객체의 논리적 상태를 간결하게 표현하는 직렬화 가능 클래스를 private static 중첩 클래스로 설계 -> 이 중첩 클래스를 직렬화 프락시라고 부른다 (바깥 클래스를 인자 자료형으로 사용하는 생성자를 하나만 가진다)
* 이 생성자는 인자에서 데이터를 복사하기만 한다, 일관성 검사를 할 필요도 없고 방어적 복사를 할 필요도 없다 (설계상 직렬화 프락시의 기본 직렬화 형식은 바깥 클래스의 완벽한 직렬화 형태), 바깥 클래스뿐 아니라 직렬화 프락시도 반드시 Serializable 인터페이스를 구현한다고 선언되어야 한다
* 역직렬화된 객체도 일반 객체와 마찬가지로 생성자, 정적 팩터리, 일반 메서드를 통해 만들므로, 직렬화의 언어 외부적(extralinguistic) 특성이 대부분 제거 되는 것 -> 그 덕에 역직렬화된 객체가 클래스 불변식을 준수하도록 하기 위해 별도의 수단을 동원할 필요가 없다
* 클래스의 정적 팩터리나 생성자가 불변식을 만족하는 객체를 만들고, 객체 메서드가 그 불변식을 보존하기만 하면, 직렬화 전후로도 불변식은 보존될 것이다
* 방어적 복사 접근법과 마찬가지로 직렬화 프락시 접근법도 가짜 바이트 스트림을 통한 공격을 방지하며 내부 필드 탈취 공격도 저절로 중단되도록 만든다
* 직렬화 프락시 접근법을 이용하면 Period의 필드를 final로 선언할 수 있어서, Period를 진정한 변경 불가능 클래스로 만들 수 있다
* 직렬화 프락시 패턴을 이용하면 역직렬화된 객체가 애초에 직렬화된 객체와 다른 클래스가 되도록 만들 수 있다

### 직렬화 프락시 패턴에는 두가지 제약이 있다 
* 클라이언트가 확장 할 수 있는 클래스에는 적용할 수 없는 기법
* 객체 그래프에 순환되는 부분(circularity)이 있는 클래스에는 적용할 수 없다