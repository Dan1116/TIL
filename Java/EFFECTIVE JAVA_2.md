# EFFECTIVE JAVA_2
# 모든 객체의 공통 메서드
* object는 객체를 만들 수 있는 구체 클래스지만 기본적으로는 상속해서 사용하도록 설계되어 있다
* Object에서 final 이 아닌 메서드들은 재정의를 염두에 두고 설계된 것이다

## equals는 일반 규약을 지켜 재정의하라
* 각 인스턴스가 본질적으로 고유하다, 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다
* 인스턴스의 논리적 동치성을 검사할 일이 없다 (logical equality) 
* 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다
* 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없다
* equals를 재정의해야 할 때는 객체 식별성 두 객체가 물리적으로 같은가가 아니라 논리적으로 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다 (주로 값 클래스가 여기 해당된다)
* 값 클래스란 Integer 와 String 처럼 값을 표현하는 클래스를 말한다, enum 클래스는 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하므로 재정의하지 않아도 된다

### equals 메서드는 동치관계를 구현하며, 다음을 만족한다
	1. 반사성 : null 이 아닌 모든 참조 값 x에 대해, x.equals(x) 는 true 이다
	2. 대칭성 : null 이 아닌 모든 참조 값 x, y에 대해, x.equals (y) 가 true 면 y.equals(x)도 true 다
	3. 추이성 : null이 아닌 모든 참조 값 x, y, z 에 대해, x.equals(y) 가 true 이고 y.equals(z)도 true이면 x.equals(z)도 true 이다
	4. 일관성 : null이 아닌 모든 참조 값 x,y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다
	5. null-아님 : null이 아닌 모든 참조 값 x에 대해, x.equals(null) 은 false 이다

* 반사성은 단순히 말하면 객체는 자기 자신과 같아야 한다는 뜻이다
* 대칭성은 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다는 뜻이다
* 추이성은 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다는 뜻이다
* 일관성은 두 객체가 같다면 앞으로도 같아야 한다는 뜻이다
* null-아님은 이름처럼 모든 객체가 null과 같이 않아야 한다는 뜻이다

* equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다
* 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다
* 추상 클래스의 하위 클래스에서라면 equals 규약을 지키면서도 값을 추가할 수 있다
* 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다

### 양질의 equals 메서드 구현 방법
	1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다
	2. instanced 연산자로 입력이 올바른 타입인지 확인한다
	3. 입력을 올바른 타입으로 형변환한다
	4. 입력 개체와 자시 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나 씩 검사한다

* float 과 double을 제외한 기본 타입 필드는 == 연산자로 비교하고, 참조 타입 필드는 각각의 equals 메서드로, float 과 double 필드는 각각 정적 메서드인 Float.compare 과 Double.compare 로 비교한다
* 어떤 필드를 먼저 비교하느냐가 equals 의 성능을 좌우하기도 한다
* equals를 다 구현했다면 세 가지만 체크해보자, 대칭적인가, 추이성이 있는가, 일관적인가
* equals 를 재정의할 땐 hashCode도 반드시 재정의하자
* Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자
* 꼭 필요한 경우가 아니라면 equals 를 재정의하지 말자

## equals 를 재정의하려거든 hashCode도 재정의하라
* equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다

### Object 규약
* equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다, 단 애플리케이션을 다시 실행하면 값이 달라져도 상관없다
* equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다
* equals가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다, 단 다른 객체에 대에서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다

### 좋은 hashCode 를 작성하는 요령
	1. int 변수 result를 선언한 후 값 c로 초기화한다, 이때 c는 해당 객체의 첫번째 핵심 필드를 단계 2.a 방식으로 계산한 해시코드다
	2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행
	* a) 해당 필드의 해시코드 c를 계산한다 -> 기본 타입 필드라면, Type.hashCode(f)를 수행 (여기서 Type은 해당 기본 타입의 박싱 클래스다)
	* b) 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의 hashCode를 재귀적으로 호출 (계산이 더 복잡해질거 같으면, 이 필드의 표준형(canonical representation)을 만들어 그 표준형의 hashCode를 호출
	* 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다, 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음 2.d 방식으로 갱신 (배열에 핵심 원소가 하나도 없으면 단순히 상수를 사용)
	* d) 단계 2.a 에서 계산한 코드를 c 로 result를 갱신
	3. result를 반환

* 파생 필드는 해시코드 계산에서 제외해도 된다, 다른 필드로부터 계산할 수 있는 필드는 모두 무시해도 된다 (또한 equals 비교에 사용되지 않은 필드는 반드시 제외해야 한다)
* 클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기 보다는 캐싱하는 방식을 고려해야 한다
* 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략하면 안 된다
* hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자, 그래야 클라이언트가 이 값에 의지하지 않고 추후에 계산 방식을 바꿀 수도 있다

## toString을 항상 재정의하라
* toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다
* toString 메서드는 객체를 println, printf 문자열 연결 연산자 +, assert 구문에 넘길 때, 혹은 디버거가 객체를 출력할 때 자동으로 불린다
* 우리가 작성한 객체를 참조하는 컴포넌트 오류 메시지를 로깅할 때 자동으로 호출할 수 있다, toString을 제대로 재정의하지 않는다면 쓸모 없는 메시지만 로그에 남을 것이다
* 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다
* toString을 구현할 때면 반환값의 포맷을 문서화 할지 정해야 한다, 포맷을 명시하기로 했다면, 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 정적 팩터리나 생성자를 함께 제공해주면 좋다
* 포맷을 한번 명시하면 평생 그 포맷에 얽매이게 되는 문제점이 있을 수 있다
* 포맷을 명시하던 아니던 우리의 의도는 명확히 밝혀야 한다
* 포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된  정보를 얻어 올 수 있는 API를 제공하자
* 정적 유틸리티 클래스는 toString을 제공할 이유가 없다, 대부분의 열거 타입도 자바가 이미 완벽한 toString을 제공하니 따로 재정의하지 않아도 된다

## clone 재정의는 주의해서 진행하라
* Cloneable을 구현하는 것만으로는 외부 객체에서 clone 메서드를 호출 할 수 없다 (리플렉션을 사용하면 가능하지만 100% 성공하는 것은 아니다)
* 메서드 하나 없는 Cloneable 인터페이스는 -> Object의 protected 메서드인 clone의 동작 방식을 결정
* Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나 하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 clone 을 호출하면 CloneNotSupportedException을 던진다
* 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public 으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다
* 쓸데없는 복사를 지양한다는 관점에서 보면 불변 클래스는 굳이 clone 메서드를 제공하지 않는게 좋다
* 재정의한 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있다
* 원본이나 복제본 중 하나를 수정하면 다른 하나도 수정되어 불변식을 해칠 수 있다
* clone 메서드는 사실상 생성자와 같은 효과를 낸다, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다
* 배열은 clone 기능을 제대로 사용하는 유일한 법
* Cloneable 아키텍처는 가변 객체를 참조하는 필드 final로 선언하라는 일반 용법과 충돌한다 (단 원본과 복제된 객체가 그 가변 객체를 공유해도 안전하다면 괜찮다)
* public 인 clone 메서드에서는 throws 절을 없애야 한다 (검사 예외를 던지지 않아야 그 메서드를 사용하기 편하기 때문이다)
* 상속용 클래스는 Cloneable을 구현해서는 안 된다
* Cloneable을 구현한 스레드 안전 클래스를 작성할 때는 clone 메서드 역시 적절히 동기화 해줘야 한다
* Cloneable을 구현하는 모든 클래스는 clone을 재정의해야 한다, 이때 접근 제한자는 public 으로 반환 타입은 클래스 자신으로 변경한다
* 복제 기능은 생성자와 팩터리를 이용하는게 최고, 단 배열은 clone 메서드 방식이 가장 깔끔하다

## Comparable 을 구현할지 고려하라
* compareTo 는 Object의 메서드가 아니다, 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다
* Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서가 있음을 뜻한다
* 알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자
* 모든 객체에 대해 전역 동치관계를 부여하는 equals 메서드와는 달리 compareTo는 타입이 다른 객체를 신경 쓰지 않아도 된다

### compareTo 규약 

	1. 두 객체 참조의 순서를 바꿔 비교해도 예상한 결과가 나와야 한다, 즉 첫 번째 객체가 두 번째 객체보다 작으면, 두 번째가 첫 번째보다 커야 한다
	2. 첫 번째가 두 번째보다 크고 두 번째가 세 번째보다 크면, 첫 번째는 세 번째보다 커야 한다
	3. 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다

* Comparable 을 구현한 클래스를 확장해 값 컴포넌트를 추가하고 싶다면, 확장하는 대신 독립된 클래스를 만들고, 이 클래스에 원래 클래스의 인스턴스를 가리키는 필드를 둬야 한다 그 후에 내부 인스턴스를 반환하는 뷰 메서드를 제공하면 된다
* Comparable 은 타입을 인수로 받는 제네릭 인터페이스이므로 compareTo 메서드의 인수 타입은 컴파일타임에 정해진다, 입력 인수의 타입을 확인하거나 형변환할 필요가 없다는 뜻이다
* compareTo 메서드는 각 필드가 동치인지를 비교하는 게 아니라 그 순서를 비교, 객체 참조 필드를 비교하려면 compareTo 메서드를 재귀적으로 호출
* Comparable 을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 Comparator을 사용해야 한다
* compareTo 메서드에서 관계 연산자 <와>를 사용하는 이전 방식은 오류를 유발하니, 이제는 추천하지 않는다
* 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다
* 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자