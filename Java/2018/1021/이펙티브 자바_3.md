# 이펙티브 자바_3
## 3장 -  모든 객체의 공통 메서드
* 동치 관계 = 반사율, 대칭률, 추이율이라는 특별한 세 가지 성질을 만족하는 관계를 말한다
* Object는 객체 생성이 가능한 클래스이긴 하지만 기본적으로는 계승해서 사용하도록 설계된 클래스

### equals를 재정의할 때는 일반 규약을 따르라
* equals 메서드는 재정의하기 쉬워 보이지만 실수할 여지가 많다 -> 각각의 객체가 고유하다, 값 대신 활성 개체 (active entity)를 나타내는 Thread 같은 클래스가 이 조건에 부합
* 클래스에 논리적 동일성 (logical equality) 검사 방법이 있건 없건 상관없다 -> Object에서 계승한 equals만으로 충분
* 클래스가 private 또는 package-private 로 선언되었고, equals 메서드를 호출할 일이 없다 -> 반드시 equals를 재정의해야 한다, 실수로 equals를 호출 할 수도 있기 때문
* equals 메서드를 정의할 때 준수해야 하는 일반 규약 -> Object 클래스 명세에서 복사한 것, equals 메서드는 동치 관계 (equivalence relation)을 구현 
* 반사성 (reflexive) -> null이 아닌 참조 x 가 있을 때, x.equals(x)는 true를 반환 -> 모든 객체는 자기 자신과 같아야 한다
* 대칭성 (symmetric) -> null 아닌 참조 x 와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환 -> equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다 (이 문제를 방지하려면, CaseInsensitiveString의 equals 메서드가 String 객체와 상호작용하지 않도록 해야 한다)
* 추이성 (transitive) -> null 아닌 참조 x,y,z가 있을 때 x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true 이다 -> 첫 번째 객체가 두 번째 객체와 같고, 두 번째 객체가 세 번째 객체와 같다면 첫 번째 객체와 세 번쨰 객체도 같아야 한다는 것이다
* 일관성 (consistent) -> null 아닌 참조 x와  y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다 -> 일단 같다고 판정 된 객체들은 추후 변경되지 않는 한 계속 같아야 한다 (변경 가능한 객체들간의 동치 관계는 시간에 따라 달라질 수 있지만, 변경 불가능 객체 사이의 동치 관계는 달라질 수 없다), 또한 신뢰성이 보장되지 않는 자원들을 비교하는 equals 를 구현하는 것을 삼가라 
* null 아닌 참조 x 에 대해서, x.equals(null)은 항상 false이다 -> null에 대한 비 동치성 (non-nullity) 모든 객체는 null과 동치 관계에 있지 아니한다
* 리스코프 대체 원칙 -> 어떤 자료형의 중요한 속성은 하위 자료형에도 그대로 유지되어서, 그 자료형을 위한 메서드는 하위 자료형에도 잘 동작해야 한다는 원칙

1. ==연산자를 사용하여 equals의 인자가 자기 자신인지 검사 -> 만일 그렇다면 true
2. instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사 -> 그렇지 않으면 false
3. equals의 인자를 정확한 자료형으로 변환 
4. 중요 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다 -> 모두 일치하면 true 반환, 아니면 flase ( float이나 double 이외의 기본 자료형은 ==연산자로 비교 )
5. equals 메서드 구현을 끝냈다면, 대칭성, 추이성, 일관성이 만족되는지 검토

### equals를 재정의할 때는 반드시 hashCode도 재정의
* 많은 버그가 hashCode 메서드를 재정의하지 않아서 생긴다
* 같은 객체는 같은 해시 코드 값을 가져야 한다
* 중복 필드( redundant field)는 해시 코드 계산 과정에서 제외해도 된다
* 성능을 개선하려고 객체의 중요 부분을 해시 코드 계산 과정에서 생략하면 안 된다는 것이다

### toString은 항상 재정의
* toString을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다
* 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다
* toString 구현할 때 중요한 사항은 반환하는 문자열의 형식을 문서에 명시할 것이냐 하는 것이다
* toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에, 어떤 의도인지는 문서에 남겨야 한다
* toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해서 가져올 수 있도록 해야한다

### clone을 재정의할 때는 신중하라
* 어떤 클래스가 Cloneable을 구현하면, Object의 clone 메서드는 해당 객체를 필드 단위로 복사한 객체를 반환
* Cloneable을 구현하지 않은 클래스라면 clone 메서드는 CloneNotSupportedException을 던진다
* 비-final 클래스에 clone을 재정의할 때는 반드시 super.clone을 호출해 얻은 객체를 반환 -> super.clone은 최종적으로 Object 의 clone메서드를 호출하게 될 것이고, 원하는 클래스의 객체가 만들어질 것이다
* 실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다 -> 해당 클래스의 모든 상위 클래스가 제대로 된 public 또는 protected clone 메서드를 제공하지 않으면 일반적으로는 불가능한 일이다
* 라이브러리가 할 수 있는 일을 클라이언트에게 미루지 말라
* clone 메서드는 또 다른 형태의 생성자 -> 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식(invariant)도 제대로 만족시켜야 한다
* clone의 아키텍처는 변경 가능한 객체를 참조하는 final 필드의 일반적 용법과 호환되지 않는다
* 객체 복제를 지원하는 좋은 방법은, 복사 생성자(copy constructor) 나 복사 팩터리 (copy factory)를 제공하는 것

### Comparatble 구현을 고려하라
* 다른 메서드와는 달리 compareTo 메서드는 Object에 선언되어 있지 않다
* 객체 참조를 비교하는 방향을 뒤집어도 객체 간 대소 관계는 그대로 유지되어야 한다
* 첫 번째 객체가 두 번째 객체보다 크고 두 번째 객체가 세 번째 객체보다 클 경우 첫 번재 객체는 반드시 세 번째보다 커야 한다
* 비교 결과가 같다고 판정된 모든 객체 각각을 다른 어떤 객체와 비교할 경우, 그 비교 결과는 전부 동일해야 한다
* 반사성, 대칭성, 추이성을 만족해야한다
* Comparable 인터페이스가 자료형을 인자로 받는 제네릭 인터페이스이므로 compareTo 메서드의 인자 자료형은 컴파일 시간에 정적으로 결정된다 (따라서 인자로 받은 객체의 자료형을 검사하거나 형 변환할 필요가 없다)
