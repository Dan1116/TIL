# 이펙티브자바#3_10
## 예외
* 제대로 활용한다면 프로그램의 가독성, 신뢰성, 유지보수성이 높아진다

### 예외는 진짜 예외 상황에서만 사용하라
* 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다
* 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다
* 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다, JVM이 알아서 최적화해 없애준다
* 예외를 사용한 반복문의 단점은 코드를 헷갈리게 하고 성능을 떨어트리는데서 끝나지 않는다, 심지어 제대로 동작하지 않을 수도 있다
* 예외는 오직 예외 상황에서만 써야 한다, 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다
* 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다
* 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다, 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다
* 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행 한다면 옵셔널이나 특정 값을 선택한다
* 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 좋다고 할 수 있다, 가독성이 살짝 더 좋고 잘못 사용했을 때 발견하기가 쉽다, 상태 검사 메서드 호출을 깜빡 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다, 반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다

### 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
* 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라 (검사와 비검사 예외를 구분하는 기본 규칙)
* 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다
* API 설계자는 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구
* 비검사 throwable은 두 가지로, 런타임 예외와 에러, 둘 다 동작 측면에서는 다르지 않다, 이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로는 잡지 말아야 한다
* 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자
* 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생
* 에러는 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다
* 우리가 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다
* Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다 (AssertionError는 예외)
* throwable은 절대 사용하지 말자
* 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자 (확실하지 않다면 비검사 예외)

### 필요 없는 검사 예외 사용은 피하라
* 검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것, 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다 (예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다)
* 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다
* 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 고통스러운 API를 만든다
* API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자, 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자

### 표준 예외를 사용하라
* Exception, RuntimeException, Throwable, Error 는 직접 재사용하지 말자
* 예외는 직렬화 할 수 있다(직렬화에는 많은 부담이 따른다)
* 인수 값이 무엇이었든 어차피 실패했을거라면 IllegalStateException을, 그렇지 않으면 IllegalArgumentException을 던지자

### 추상화 수준에 맞는 예외를 던저라
* 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다
* 예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄(exception chaining) 을 사용하는 게 좋다
* 예외 연쇄란 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식, 고수준 예외의 생성자는 상위 클래스의 생성자에 이 원인을 건네주어, 최종적으로 Throwable 생성자까지 건네지게 한다
* 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라, 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다

### 메서드가 던지는 모든 예외를 문서화하라
* 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자
* main은 오직 JVM만이 호출하므로 Exception을 던지도록 선언해도 괜찮다
* 메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자
* 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 있다

### 예외의 상세 메세지에 실패 관련 정보를 담아라
* 예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 스택 추적 정보를 자동으로 출력한다
* 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메세지에 담아야 한다
* 접근자 메서드를 제공하라 (비검사 예외든 검사 예외든)

### 가능한 한 실패 원자적으로 만들라
* 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다 (실패 원자적(failure-atomic))
* 가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법은 작업 수행에 앞서 매개변수의 유효성을 검사하는 것 (객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성 대부분을 걸러낼 수 있는 방법)
* 실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법 (계산을 수행해보기 전에는 인수의 유효성을 검사해 볼 수 없을 때 쓸 수 있는 기법)
* 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것 (데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식)
* 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법

### 예외를 무시하지 말라
* catch 블록을 비워두면 예외가 존재할 이유가 없어진다
* 예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔야 한다