# 이펙티브자바#3_9
### 지역변수의 범위를 최소화하라
* 지역변수 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다
* 지역변수의 범위를 줄이는 가장 강력한 기법은 역시 가장 처음 쓰일 때 선언하면 된다
* 지역변수를 생각 없이 선언하다 보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 여전히 살아 있게 되기 쉽다
* 거의 모든 지역변수는 선언과 동시에 초기화해야 한다, 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다 (try-catch문은 이 규칙에서 예외변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야 한다, 변수 값을 try 블록 바깥에서도 사용해야 한다면 try 블록 앞에서 선언해야 한다)
* 반복문은 독특한 방식으로 변수 범위를 최소화해준다, 반복문에서는 반복 변수의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한된다
* 반복자를 사용해야 하는 상황이라면 for-each, while보다 for문이 좋다
* 지역변수 범위를 최소화하는 마지막 방법은 메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다

### 전통적인 for 문보다는 for-each 문을 사용하라
* for-each문은 반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일도 없다 또한 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지는 신경 쓰지 않아도 된다
* 컬렉션을 중첩해 순회해야 한다면 for-each 문의 이점이 더욱 커진다
* for-each 문을 사용할 수 없는 세 가지 ->
* 파괴적인 필터링(destructive filtering) - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다
* 변형(transforming) - 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다
* 병렬 반복(parallel iteration) - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다

### 라이브러리를 익히고 사용하라
* 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다
* 핵심적인 일과 크게 관련 없는 문제를 해결하는데 시간을 허비하지 않아도 된다
* 따로 노력하지 않아도 성능이 지속해서 개선된다
* 기능이 점점 많아진다
* 많은 사람에게 낯익은 코드가 된다 (유지보수하기 좋다)
* ThreadLocalRandom으로 대체하면 대부분 잘 작동한다(Random 보다)
* 메이저 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가된다
* 자바 프로그래머라면 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 한다

### 정확한 답이 필요하다면 float와 double은 피하라
* float과 double 타입은 특히 금융 관련 계산과는 맞지 않는다
* 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다
* BigDecimal이 제공하는 여덟 가지 반올림 모드를 이용하여 반올림을 완벽히 제어할 수 있다

### 박싱된 기본 타입보다는 기본 타입을 사용하라
* 자바의 데이터 타입은 크게 두 가지 -> int, double, boolean 같은 기본 타입과 String,List 같은 참조 타입
* 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다
* 기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지다 -> 
* 1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 갖는다 (박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다) 358페이지 오타
* 2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다
* 3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다
* 박싱된 기본 타입에 == 연산자를 사용하면 오류가 난다, 실무에서 기본 타입을 다루는 비교자가 필요하다면, Comparator.naturalOrder()를 사용하자
* 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다
* 박싱된 기본 타입을 쓰는 경우 ->
* 1. 컬렉션의 원소, 키, 값으로 쓴다, 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야 한다 (매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다)
* 2. 리플렉션을 통해 메서드를 호출할 때
* 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애 주지는 않는다
* 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 NullPointerException을 던질 수 있다, 또한 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 만들 수 있다

### 다른 타입이 적절하다면 문자열 사용을 피하라
* 문자열은 다른 값 타입을 대신하기에 적합하지 않다
* 문자열은 열거 타입을 대신하기에 적합하지 않다
* 문자열은 혼합 타입을 대신하기에 적합하지 않다
* 문자열은 권한을 표현하기에 적합하지 않다
* 더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 싶은 유혹을 뿌리쳐라, 문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다

### 문자열 연결은 느리니 주의하라
* 문자열 연결 연산자로 문자열 n개를 있는 시간은 n 제곱에 비례한다
* 성능을 포기하고 싶지 않다면 String 대신 StringBuilder (append)를 사용하자

### 객체는 인터페이스를 사용해 참조하라
* 적합한 인터페이스만 있다면 매개변수 뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라
* 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다
* 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다
* 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자

### 리플렉션보다는 인터페이스를 사용하라
* 리플렉션 기능을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다, Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다
* 리플렉션을 이용할 때의 단점 -> 
* 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다, 예외 검사도 마찬가지
* 리플렉션을 이용하면 코드가 지저분하고 장황해진다
* 성능이 떨어진다, 느리고 고려해야 하는 요소가 많아진다
* 리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다
* 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자
* 리플렉션은 되도록 객체 생성에만 사용하고, 생성한 객체를 이용할 때는 적절한 인터페이스나 컴파일타임에 알 수 있는 상위 클래스로 형변환해 사용해야 한다

### 네이티브 메서드는 신중히 사용하라
* 네이티브 메서드의 주요 쓰임 ->
* 1. 레지스트리 같은 플랫폼 특화 기능을 사용한다
* 2. 네이티브 코드로 작성된 기존 라이브러리를 사용한다
* 3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다
* 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다
* 네이티브 메서드에는 심각한 단점이 있다 -> 네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더 이상 안전하지 않다

### 최적화는 신중히 하라
* 빠른 프로그램보다는 좋은 프로그램을 작성하라
* 성능을 제한하는 설계를 피하라
* API를 설계할 때 성능에 주는 영향을 고려하라
* 성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각이다
* 각각의 최적화 시도 전후로 성능을 측정하라

### 일반적으로 통용되는 명명 규칙을 따르라
* 패키지와 모듈 이름은 각 요소를 점(.)으로 구분하여 계층적으로 짓는다
* 요소들은 모두 소문자 알파벳 혹은 숫자로 이뤄진다
* 표준 명명 규칙을 항상 따라야 한다