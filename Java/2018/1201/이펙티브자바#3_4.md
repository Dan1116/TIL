# 이펙티브자바#3_4
## 클래스와 인터페이스
* 추상화의 기본 단위인 클래스와 인터페이스는 자바 언어의 심장

### 클래스와 멤버의 접근 권한을 최소화하라
* 잘 설계된 컴포넌트는 클래스의 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨겨져 있다 (구현과 API를 깔끔히 분리)

* 정보 은닉의 장점
* 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문
* 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문
* 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음, 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다
* 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다
* 큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문이다

* 자바는 정보 은닉을 위한 다양한 장치를 제공한다, 그 중 접근 제어 메커니즘은 클래스, 인터페이스, 멤버의 접근성을 명시
* 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다, 소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다
* 가장 바깥에 있는 클래스(톱 레벨)와 인터페이스에 부여할 수 있는 접근 수준은 package-private 와 public 두 가지다
* package-private으로 선언하면 해당 패키지 안에서만 이용할 수 있다
* private = 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다
* package-private = 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다, 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다 (단, 인터페이스의 멤버는 기본적으로 public 적용)
* protected = package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다
* public = 모든 곳에서 접근 가능
* 클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private으로 만들자 ( 그런 다음 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private 으로 해주자)
* Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다
* 상위 클래스의 메서드를 재정의 할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다
* public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다
* public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다
* 길이가 0이 아닌 배열은 모두 변경 가능하니 주의해야 한다
* 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다
* 패키지 = 클래스들의 묶음 , 모듈 = 패키지들의 묶음
* 모듈은 자신에 속하는 패키지 중 공개(exports) 할 것들을 (관례상 module-info.java 파일에) 선언한다
* protected, public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서는 접근할 수 없다 (물론 모듈 안에서는 exports로 선언했는지 여부에 아무런 영향도 받지 않는다)
* 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다
* 자바 라이브에서 공개하지 않은 패키지들은 해당 모듈 밖에서는 절대로 접근할 수 없다

* 프로그램 요소의 접근성은 가능한 한 최소한으로 하라, 꼭 필요한 것만 골라 최소한의 public API를 설계하자, 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다.
* public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다
* public static final 필드가 참조하는 객체가 불변인지 확인하라

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
* 패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다
* package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다, 그 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 된다
* public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다, 불변 필드라면 노출해도 덜 위험하지만 완전히 안심 할 수는 없다, 하지만 package-private 클래스나 private 중첩 클래스에서는 종종 (불변이든 가변이든) 필드를 노출하는 편이 좋을 때도 있다

### 변경 가능성을 최소화하라
* 불변 클래스 = String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal
* 불변으로 만들려면 필요한 규칙들 ->
* 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다
* 클래스를 확장할 수 없도록 한다, 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다 (대부분 final 선언)
* 모든 필드를 final로 선언 -> 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법이다, 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장하는 데도 필요하다
* 모든 필드를 private으로 선언하다, 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다
* 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다, 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다 -> 이런 필드는 절대 클라이언트가 제공한 객체 참조를 가리키게 해서는 안 되며, 접근자 메서드가 그 필드를 그대로 반환 해서도 안 된다, 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행하라
* 불변 객체는 단순하다 -> 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다
* 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다, 불변 객체는 안심하고 공유할 수 있다
* 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 적정 팩터리를 제공할 수 있다 (박싱된 기본 타입 클래스 전부와 BigInteger가 여기 속한다)
* 새로운 클래스를 설계할 때 public 생성자 대신 정적 팩터리를 만들어두면, 클라이언트를 수정하지 않고도 필요에 따라 캐시 기능을 나중에 덧 붙일 수 있다
* 불변 객체를 자유롭게 공유할 수 있다는 점은 방어적 복사도 필요 없다
* 불변 객체는 자유롭게 공유할 수 있고, 불변 객체끼리는 내부 데이터를 공유 할 수도 있다
* 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다, 불변식을 유지하기 훨씬 수월하다
* 불변 객체는 그 자체로 실패 원자성을 제공한다
* 불변 클래스에도 단점은 있다, 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것
* 흔히 쓰일 다단계 연산들을 예측하여 기본 기능으로 제공하는 방법 -> 더 이상 각 단계 마다 객체를 생성하지 않아도 된다
* 정적 팩토리 방식은 다수의 구현 클래스를 활용한 유연성을 제공하고, 이와 더불어 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다
* 직렬화 할 때는 추가로 주의할 점이 있다 -> Serializable 을 구현하는 불변 클래스의 내부에 가변 객체를 참조하는 필드가 있다면 readObject나 readResolve 메서드를 반드시 제공하거나, ObjectOutputStream.writeUnshard와 ObjectInputStream.readUnshard 메서드를 사용해야한다 -> 공격자가 이 클래스로부터 가변 인스턴스를 만들어 낼 수 있다

* 게터가 있다고 무조건 세터를 만들지는 말자
* 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다 -> 잠재적 성능 저하 라는 단점 말고는 단점이 존재하지 않기 때문
* 성능 때문에 어쩔 수 없다면, 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하도록 
* 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄여야 한다-> 객체가 가질 수 잇는 상태의 수를 줄인다면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다 (final 이용)
* 다른 합당한 이유가 없다면 모든 필드는 private final 이어야 한다
* 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다

### 상속보다는 컴포지션을 사용하라
* 상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다 
* 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이다
* 일반적인 구체 클래스를 패키지 경계를 넘어, 다른 패키지의 구체 클래스를 상속하는 일은 위험하다
* 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다, 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다
* 컴포지션 = 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하는 것
* 새 클래스의 메서드들은 (private 필드로 참조하는) 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다
* 이 방식을 전달(forwarding)이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다
* 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다
* 상속 방식은 구체 클래스 각각을 따로 확장해야 하며, 지원하고 싶은 상위 클래스의 생성자에 각각에 대응하는 생성자를 별도로 정의해줘야 한다, 하지만 컴포지션 방식은 한 번만 구현해두면 어떠한 Set 구현체라도 계측할 수 있으며, 기존 생성자들과도 함께 사용할 수 있다
* 래퍼 클래스는 단점이 거의 없다, 한 가지, 래퍼 클래스가 콜백 프레임워크와는 어울리지 않는다는 점만 주의하면 된다
* 콜백 프레임워크에서는 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출 때 사용하도록 한다
* 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 한다 (is-a 관계)
* 상속은 강력하지만 캡슐화를 해친다는 문제가 있다, 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다, is-a 관계일 때도 안심 할 수만은 없는게, 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않는다면 여전히 문제가 될 수 있다
* 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용 -> 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다, 래퍼 클래스는 하위 클래스보다 견고하고 강력하다

### 상속을 고려해 설계하고 문서화하라, 그러지 않았다면 상속을 금지하라
* 상속용 클래스는 재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다
* 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출 할 수도 있다
* 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다
* 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일한 방법이다
* 상속용 클래스의 생성자는 직접적으로던 간접적으로던 재정의 가능 메서드를 호출해서는 안 된다
* 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 호출된다, 이때 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 작동하지 않을 것이다
* private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다
* clone 과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다
* readObject의 경우 하위 클래스의 상태가 미처 다 직렬화 되기 전에 재정의한 메서드부터 호출하게 된다
* clone의 경우 하위 클래스의 clone이 잘못되면 복제본 뿐 아니라 원본 객체에도 피해를 줄 수 있다
* Serializable 을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private 이 아닌 protected로 선언해야 한다 (private으로 선언한다면 하위 클래스에서 무시되기 때문이다)
* 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 제약도 상당하다
* 상속용으로 설계하지 않은 클래스는 상속을 금지해라
* final로 선언해서 상속을 금지 시키거나, 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법
* 구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다 -> 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기는 방법을 이용하라
* 클래스의 동작을 유지하면서 재정의 간의 메서드를 사용하는 코드를 제거할 수 있는 기계적인 방법 -> 먼저 각각의 재정의 가능 메서드는 자신의 본문 코드를 private 도우미 메서드로 옮기고, 이 도우미 메서드를 호출하도록 수정한다, 그런 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정하면 된다

### 추상 클래스보다는 인터페이스를 우선하라
* 다중 구현 메커니즘 -> 인터페이스, 추상 클래스
* 추상 클래스 -> 반드시 추상 클래스의 하위 클래스가 되어야 한다 (자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 받게 된다)
* 인터페이스 -> 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속 했던 같은 타입으로 취급
* 기존 클래스에도 손 쉽게 새로운 인터페이스를 구현해 넣을 수 있다 (인터페이스가 요구하는 메서드를 추가하고, 클래스 선언에 implements 구문만 추가하면 끝이다)
* 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다
* 믹스인 = 클래스가 구현할 수 있는 타입으로 믹스인을 구현한 클래스에 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다
* Comparable 은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스이다
* 추상 클래스로는 믹스인을 정의할 수 없다 -> 기존 클래스에 덧 씌울 수가 없다, 클래스는 두 부모를 섬길 수 없고, 클래스 계층구조에는 믹스인을 삽입하기에 합리적인 위치가 없기 때문
* 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다
* 래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다
* 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속 뿐이다 (상속으로 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다)
* 디폴트 메서드의 제약 -> equals 와 hashCode 는 디폴트 메서드로 제공해서는 안 되고, 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 멤버도 가질 수 없다(private 정적 메서드는 예외), 우리가 만들지 않은 인터페이스에는 메서드를 추가할 수 없다
* 인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다 -> 인터페이스로는 타입을 정의하고 필요하면 디폴트 메서드 몇 개도 함께 제공, 그리고 골격 구현 클래스는 나머지 메서드들까지 구현 = 템플릿 메서드 패턴
* 골격 구현 클래스의 아름다움은 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서는 자유롭다는 점
* 인터페이스를 구현한 클래스에서 해당 골격 구현을 확장한 private 내부 클래스를 정의하고, 각 메서드 호출을 내부 클래스의 인스턴스에 전달하는 것
* 골격 구현 작성은 쉽다 -> 인터페이스를 잘 살펴 다른 메서드들의 구현에 사용되는 기반 메서드들을 선정, 이 기반 메서드들은 골격 구현에서는 추상 메서드가 될 것이다, 그 다음으로 기반 메서드들을 사용해 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 제공, 만약 인터페이스의 메서드 모두가 기반 메서드와 디폴트 메서드가 된다면 골격 구현 클래스를 별도로 만들 이유는 없다, 기반 메서드나 디폴트 메서드로 만들지 못한 메서드가 남아 있다면, 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드들을 작성해 넣는다, 골격 구현 클래스에는 필요하면 public이 아닌 필드와 메서드를 추가해도 된다
* 단순 구현(simple implementation) 은 골격 구현의 작은 변종으로 Abstract Map.simpleEntry 가 좋은 예다
* 다중 구현용 타입으로는 인터페이스가 가장 적합하다, 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 꼭 고려해보자, 골격 구현은 가능한 한 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다 (가능한 한 이라고 한 이유는, 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문)

### 인터페이스는 구현하는 쪽을 생각해 설계하라
* 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다
* 디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다
* 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다, 추가하려는 디폴트 메서드가 기존 구현체들과 충돌하지는 않을지 심사숙고해야 함도 당연하다
* 하지만 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는 데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해준다
* 디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계 할 때는 여전히 세심한 주의를 기울여야 한다
* 인터페이스를 릴리스한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성을 기대서는 안 된다

### 인터페이스는 타입을 정의하는 용도로만 사용하라
* 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 잇는 타입 역할을 한다
* 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 이야기해주는 것이다
* 상수 인터페이스란 메서드 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 말한다, 그리고 이 상수들을 사용하려는 클래스에서는 정규화된 이름 (qualified name)을 쓰는 걸 피하고자 그 인터페이스를 구현하곤 한다
* 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다, 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당, 따라서 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위
* 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야 한다 (모든 숫자 기본 타입의 박싱 클래스가 대표적)
* 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들어 공개하면 된다, 그것도 아니라면, 인스턴스화할 수 없는 유틸리티 클래스에 담아 공개
* 유틸리티 클래스에 정의된 상수를 클라이언트에서 사용하려면 클래스 이름까지 함께 명시해야 한다
* 인터페이스는 타입을 정의하는 용도로만 사용해야 한다, 상수 공개용 수단으로 사용하지 말자

### 태그 달린 클래스보다는 클래스 계층구조를 활용하라
* 태그 달린 클래스에는 단점이 너무나도 많다 -> 우선 열거 타입 선언, 태그 필드, switch 문 들 쓸데 없는 코드가 많다, 여러 구현이 한 클래스에 혼합돼 있어서 가독성도 나쁘다, 다른 의미를 위한 코드도 언제나 함께 하니 메모리도 많이 사용 -> 한 마디로 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다, 계층구조를 어설프게 흉내낸 아류일 뿐이다
* 서브타이핑(subtyping) = 클래스 계층구조를 활용하는 방식
* 태그 달린 클래스를 클래스 계층구조로 바꾸는 방법 -> 계층구조의 루트가 될 추상 클래스를 정의, 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언, 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클래스에 일반 메서드로 추가, 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들도 전부 루트 클래스로 올린다, 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의, 루트 클래스가 정의한 추상 메서드를 각자의 의미에 맞게 구현

### 멤버 클래스는 되도록 static 으로 만들라
* 중첩 클래스 = 다른 클래스 안에 정의된 클래스, 자신을 감싼 바깥 클래스에서만 쓰여야 한다 (그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다)
* 중첩 클래스의 종류 = 정적 멤버 클래스, 비정적 멤버 클래스, 익명 클래스, 지역 클래스 (정적 멤버 클래스 빼고 세 가지는 내부 클래스에 해당)
* 정적 멤버 클래스 = 다른 클래스 안에 선언, 바깥 클래스의 private 멤버에도 접근 할 수 있다는 점만 제외하고는 일반 클래스와 똑같다, 흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다
* 정적 멤버 클래스와 비정적 멤버 클래스의 구문상 차이는 단지 static이 붙어 있고 없고 뿐이지만, 의미상 차이는 꽤 크다
* 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결, 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다 (정규화된 this = 클래스명.this 형태로 바깥 클래스의 이름을 명시하는 용법)
* 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없기 때문에 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다
* 비정적 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다, 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용
* 멤버 클래스애서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자 (가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하여 메모리 누수가 생길 수도 있다)
* private 정적 멤버 클래스는 흔히 바깥 클래스가 표현하는 객체의 한 부분을 나타낼 때 쓴다
* 익명 클래스에는 이름이 없다, 또한 바깥 클래스의 멤버도 아니다, 멤버와 달리 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다, 그리고 오직 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다 (정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다, 즉 상수 표현을 위해 초기화된 final 기본 타입과 문자열 필드만 가질 수 있다)
* 익명 클래스는 선언한 지점에서만 인스턴스를 만들 수 있고, instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다, 익명 클래스를 사용하는 클라이언트는 그 익명 클래스가 상위 타입에서 상속한 멤버 외에는 호출할 수 없다, 짧지 않으면 가독성이 떨어진다
* 지역 클래스는 지역변수를 선언할 수 잇는 곳이면 실질적으로 어디서든 선언할 수 있고, 유효범위도 지역변수와 같다, 멤버 클래스처럼 이름이 있고 반복해서 사용할 수 있다, 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있으며, 정적 멤버는 가질 수 없으며, 가독성을 위해 짧게 작성해야 한다
* 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로, 그렇지 않으면 정적으로, 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 그렇지 않으면 지역 클래스로 만들자

### 톱레벨 클래스는 한 파일에 하나만 담아라
* 소스 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 자바 컴파일러는 불평하지 않는다, 하지만 아무런 득이 없을 뿐더러 심각한 위험을 감수해야하는 행위다 (한 클래스를 여러 가지로 정의할 수 있으며, 그중 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하느냐에 따라 달라진다)
*  소스 파일 하나에는 반드시 톱레벨 클래스를 하나만 담자