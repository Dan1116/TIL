# 이펙티브자바_4
## 클래스와 인터페이스
* 클래스와 인터페이스는 자바 프로그래밍 언어의 핵심적인 부분, 추상화의 기본 단위

### 클래스와 멤버의 접근 권한은 최소화
* 잘 설계된 모듈은 구현 세부사항을 전부 API 뒤쪽에 감춘다 -> 정보 은닉 ( information hiding), 캡슐화 (encapsulation)
* 정보 은닉이 시스템을 구성하는 모듈 사이의 의존성을 낮춰서 각자 개별적으로 개발하고 , 시험하고, 최적화하고, 이해하고, 변경할 수 있도록 한다는 사실에 기초
* 정보 은닉 원칙은 소프트웨어의 재사용 가능성을 높인다 ( 모듈간 의존성이 낮아지므로)
* 각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들어야 한다

* private = 선언된 최상위 레벨 클래스 내부에서만 접근 가능
* package-private = 같은 패키지 내의 아무 클래스나 사용, 기본 접근 권한으로 알려져 있다
* protected - 선언된 클래스 및 그 하위 클래스만 사용 가능, 선언된 클래스와 같은 패키지에 있는 클래스에서도 사용 가능
* public - 어디서도 사용 가능

* 상위 클래스 메서드를 재정의할 때는 원래 메서드의 접근 권한보다 낮은 권한을 설정할 수 없다
* 객체 필드 ( instance field )는 절대로 public으로 선언하면 안 된다 -> 비 - final 필드나 변경 가능 객체에 대한 final 참조 필드를 public 으로 선언하면, 필드에 저장될 값을 제한 할 수 없다
* 변경 가능 public 필드를 가진 클래스는 다중 쓰레드에 안전하지 않다
* 한 가지 예외 -> 어떤 상수들이 클래스로 추상화된 경과물의 핵심적 부분을 구성한다고 판단되는 경우, 해당 상수들을  public static final 필드들로 선언하여 공개할 수 있다
* 길이가 0 아닌 배열은 언제나 변경 가능하므로 -> public static final 배열 필드를 두거나 배열 필드를 반환하는 접근자를 정의하면 안 된다

### public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용해라
* 선언된 패키지 밖에서도 사용 가능한 클래스에는 접근자 메서드를 제공해라
* package-private 클래스나 private 중첩 클래스 (nested class)는 데이터 필드를 공개하더라도 잘못이라 말할 수 없다
* public 클래스는 변경 가능 필드를 외부로 공개하면 안 된다

### 변경 가능성을 최소화하라
* 변경 불가능 클래스는 설계하기 쉽고, 구현하기 쉽고, 사용하기도 쉽다 ( 오류 가능성도 적고 더 안전하다)

1. 객체 상태를 변경하는 메서드 ( 수정자 mutator 메서드) 를 제공하지 않는다
2. 계승할 수 없도록 한다 -> 계승을 금지하려면 보통 클래스를 final로 선언하면 된다
3. 모든 필드를 final로 선언 해라 -> 새로 생성된 객체에 대한 참조가 동기화 없이 다른 쓰레드로 전달되어도 안전하다
4. 모든 필드를 private 로 선언 해라 -> 클라이언트가 필드가 참조하는 변경 가능 객체를 직접 수정하는 일을 막을 수 있다
5. 변경 가능 컴포넌트에 대한 독점적 접근권을 보장 -> 클래스에 포함된 변경 가능 객체에 대한 참조를 클라이언트는 획득할 수 없어야 한다

* 변경 불가능 객체는 단순하다 -> 생성될 때 부여된 한 가지 상태만 갖는다
* 변경 불가능 객체는 쓰레드에 안전할 수밖에 없다 (어떤 동기화도 필요 없으며, 여러 쓰레드가 동시에 사용해도 상태가 훼손될 일이 없다)
* 변경 불가능한 객체는 자유롭게 공유할 수 있다
* 변경 불가능 클래스는 자주 사용하는 객체를 캐시(cache)하여 이미 있는 객체가 거듭 생성되지 않도록 하는 정적 팩터리를 제공할 수 있다 -> 정적 팩터리를 사용하면 클라이언트는 새로운 객체를 만드는 대신 기존 객체들을 공유하게 되므로 메모리 요구량과 쓰레기 수집 비용이 줄어든다
* 변경 불가능한 객체를 자유롭게 공유할 수 있다는 것은, 방어적 복사본을 만들 필요가 없다는 뜻이기도 하다
* 변경 불가능 객체는 그 내부도 공유할 수 있다
* 변경 불가능 객체는 다른 객체의 구성 요소로도 훌륭 -> 변경 불가능 객체는 맵의 키나 집합의 원소로 활용하기 좋다
* 변경 불가능 객체의 유일한 단점은 값 마다 별도의 객체를 만들어야 한다는 점이다 -> 객체 생성 비용이 높을 가능성이 있다
* 변경 불가능한 클래스로 만들 수 없다면, 변경 가능성을 최대한 제한하라 -> 특별한 이유가 없다면 모든 필드는 final로 선언하라

### 계승하는 대신 구성하라 
* 계승은 코드 재사용을 돕는 강력한 도구지만, 항상 최선이라고는 할 수 없다
* 메서드 호출과 달리, 계승은 캡슐화 원칙을 위반한다
* 기존 클래스를 계승하는 대신, 새로운 클래스에 기존 클래스 객체를 참조하는 private필드를 하나 두는 방식으로 사용해야 한다 -> 이 설계 기법을 구성( composition) 이라 하고, 이 구현 기법을 전달 (fowarding) 이라 하고 전달 기법을 사용해 구현된 메서드를 전달 메서드(forwarding method)라 부른다
* 포장 클래스에는 단점이 별로 없으나, 역호출(callback) 프레임워크와 함께 사용하기에는 적합하지 않다 ( 역호출 프레임워크에서 객체는 자기 자신에 대한 참조를 다른 객체에 넘겨, 나중에 필요할 때 역호출 하도록 요청한다) -> 포장된 객체는 포장 객체에 대해서는 모르기 때문에, 자기 자신에 대한 참조를 전달할 것이다, 따라서 역호출 과정에서 포장 객체는 제외
* 계승을 할려면 Is-a 관계가 성립해야 한다