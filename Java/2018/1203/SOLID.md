# SOLID
## The Single Responsibility Principle (SRP)
* 이 원칙은 Tom DeMarco 와 Meilir Page- Jones에 의해 묘사 된 원칙이다, 그들은 이것을 cohesion(결합)이라 불렀다.
* 왜  두개의 의무가 각각의 클래스들에 의해 나누어져 있을까?  -> 각각의 책임과 의무는 변화의 중심축(axis)이기 때문이다
* 만약 하나의 클래스가 하나 이상의 책임이 있다면, 꼭 그 클래스를 바꿔야 한다
* 두 가지의 책임을 가지고 있는 클래스의 책임을 하나로 변경하면 클래스의 능력이 손상되거나 금지 될 수 있다

### 책임과 의무는 무엇인가?
* 우리는 책임과 의무를 변화의 이유로 정의했다 
* 각각의 다른 두가지의 의무와 책임은 두 개의 나누어진 각각의 interface에 집어넣어야 한다

## The Open-Closed Principle (OCP)
* 모든 변수들은 private으로 해야하고 , global 변수들은 피해야한다, run time type identification 을 사용하는 것은 위험하다
* Betrand Meyer -> 소프트웨어 ENTITLES(CLASSES, MODULES, FUNCTIONS…) 은 확장에는 열려있어야 하지만, 수정에는 닫혀 있어야 한다
* 프로그램에 대한 단일 변경으로 인해 종속 모듈의 변경 사항이 연속적으로 발생하면 해당 프로그램은 "잘못된"설계와 관련이 있는 바람직하지 않은 특성을 나타낸다

### 추상화가 키(답) 이다
* 추상화는 추상적인 기본 클래스이며 가능한 모든 동작의 제한되지 않은 그룹은 모두 파생 클래스에 의해 나타난다
* 모듈이 추상화를 조작하는 것이 가능하다, 그러한 모듈은 수정 된 추상화에 의존하기 때문에 수정을 닫아야한다, 그러나 추상화의 새로운 파생물을(derivatives) 만들어 해당 모듈의 동작을 확장 할 수 있습니다

### 추상화의 모양
* 기존의 코드를 바꾸는거 보다는 새로운 코드를 추가함으로써 변경되기 때문에 부적합한 프로그램이 보여주는 변경 사항의 연속을 경험하지 않습니다.

### 전략적인 closure(닫음)
* 완벽하게 클래스를 닫을 수  없으므로 전략적으로 접근해야 한다

### 결론
* 여러면에서 이 원칙은 객체 지향 설계의 핵심입니다. 이 원리의 준수는 객체 지향 기술에 대해 가장 큰 이익을 얻는 것입니다. 재사용 성 및 유지 보수성. 설계자가 변경 될 수 있다고 느끼는 프로그램 부분에 추상화를 적용하려면 디자이너의 노력이 필요합니다

## The Liskov Substitution Principle
* Open-Closed 원리의 기본 메커니즘은 추상화와 다형성이다. C ++과 같이 정적으로 형식화 된 언어에서 추상화 및 다형성을 지원하는 주요 메커니즘 중 하나는 상속입니다. 상속을 사용하여 추상 기본 클래스에서 순수 가상 함수로 정의 된 추상화된 다형 인터페이스를 준수하는 파생 클래스를 만들 수 있다
* 기본 클래스에 대한 포인터 또는 참조를 사용한 함수는 상속 된 클래스의 목적을 사용할 수 있어야한다
* Open-Closed 원칙은 OOD(객체 지향 디자인)에 대한 핵심입니다. 응용 프로그램을 유지 관리하고 재사용하며 강력하게 만드는 것이 이 원칙의 효과입니다. Liskov Substitution Principle은 Open-Closed 원칙을 준수하는 모든 프로그램의 중요한 특징입니다. 파생 된 유형이 해당 기본 유형을 완전히 대체 할 수있는 경우에만 해당 기본 유형을 사용하는 함수가 재사용 될 수 있고 파생 된 유형을 변경하지 않을 수 있습니다

## The Interface Segregation Principle
* 이 원칙은 뚱뚱한 인터페이스의 단점을 다룹니다. 뚱뚱한 인터페이스를 가지는 클래스는, 인터페이스가 응집하지 않는 클래스이다
* 클래스의 인터페이스는 멤버 함수 그룹으로 나눌 수 있습니다. 각 그룹은 다른 클라이언트 세트를 제공합니다. 따라서 일부 클라이언트는 하나의 구성원 기능 그룹을 사용하고 다른 클라이언트는 다른 그룹을 사용합니다
* ISP는 비 응집 인터페이스가 필요한 객체가 있음을 인정한다. 그러나 그것은 클라이언트가 그들에 대해 하나의 클래스로 알면 안된다는 것을 암시한다. 대신, 클라이언트는 응집력있는 인터페이스가있는 추상 기본 클래스에 대해 알아야합니다. 어떤 언어는 이러한 추상 기본 클래스를 인터페이스, 프로토콜이라고 부른다
* 뚱뚱한 인터페이스는 격리되어야하는 클라이던트 사이에 의도하지 않은 문제를 일으킵니다. 위임 (객체 형식) 또는 다중 상속 (클래스 형식)을 ADAPTER 패턴을 사용함으로써 뚱뚱한 인터페이스를 클라이언트 간의 원하지 않는 결합을 깨뜨리는 추상 기본 클래스로 분리 될 수 있다

## The Dependency Inversion Principle
* 구조화 된 분석 및 설계와 같은 전통적인 소프트웨어 개발 방법은 상위 레벨 모듈이 하위 레벨 모듈에 의존하고 추상화가 세부 사항에 의존하는 소프트웨어 구조를 만드는 경향이 있기 때문에 실제로 이러한 메소드의 목표 중 하나는 상위 레벨 모듈이 하위 레벨 모듈을 호출하는 방법을 설명하는 서브 프로그램 계층을 정의하는 것이다
* 종속성 반전의 원칙을 준수하기 위해서는 추상화를  세부 사항과 분리해야 한다. 그런 다음 세부 사항이 추상화에 종속되도록 디자인의 종속성을 지정해야 한다
* 종속성 반전의 원칙은 객체 지향 기술에 대한 많은 이점의 근원이다. 재사용 가능한 프레임 워크를 생성하려면 적절한 응용 프로그램이 필요하다
* 또한 변경하기 쉽도록 코드를 구성하는 것이 중요하다. 추상화와 세부 사항은 모두 서로 분리되어 있기 때문에 코드를 유지 관리하기가 훨씬 쉽다
* 의존하지 않게 만드는 것이 포인트
