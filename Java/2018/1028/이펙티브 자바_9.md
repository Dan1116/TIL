# 이펙티브 자바_9
## 예외
* 잘만 활용하면 프로그램의 가독성, 안정성, 유지보수성을 모두 향상

### 예외는 예외적 상황에만 사용하라
* 예외는 예외적 상황을 위해 고안된 것이기 때문에, JVM을 구현하는 사람 입장에서 보면 명시적 테스트 (explicit test) 만큼 빠르게 만들 이유가 없다
* try-catch 블록 안에 넣어둔 코드에는 최신 JVM이 사용하는 최적화 기법 가운데 일부가 적용되지 않는다
* 배열을 순회하는 표준 숙어가 중복 검사로 이어지리라는 생각은 틀렸다, 최신 JVM은 그런 부분도 최적화해서 없애 버린다
* 예외는 예외적인 상황에서만 사용해야 한다, 평상시 제어 흐름(ordinary control flow)에 이용해서는 안 된다
* 잘 설계된 API는 클라이언트에게 평상시 제어 흐름의 예외를 사용하도록 강요해서는 안 된다
* 특정한 예측 불가능 조건이 만족될 때만 호출할 수 있는 상태 종속적 (state-dependent) 메서드를 가진 클래스에는 보통 해당 메서드를 호출해도 되는지를 알기 위한 상태 검사(state-testing) 메서드가 별도로 갖춰져 있다

### 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
* 자바는 세 가지 종류의 throwable 을 제공 ->
* 1. 점검지정 예외(checked exception)
* 2. 실행지점 예외(runtime exception)
* 3. 오류 (error)
* 점검지정 예외를 사용할 것인지 무점검 예외를 사용할 것인지에 대한 규칙은, 호출자 측에서 복수할 것으로 여겨지는 상황에 대해서는 점검지정 예외를 이용해야 한다는 것이다
* 메서드에 선언된 점검지정 예외는 메서드를 호출하면 해당 예외와 관계된 상황이 발생할 수 있음을 API 사용자에게 알리는 구실을 한다
* API 사용자에게 점검지정 예외를 준다는 것은, 그 상태를 복구할 권한을 준다는 뜻
* 프로그램이 무점검 예외나 오류를 던진다는 것은 복구가 불가능한 상황에 직면했다는 뜻으로, 더 진행해 봐야 득보다 실이 더 크다는 뜻이다
* 프로그래밍 오류를 표현할 때는 실행시점 예외를 사용하라
* 대부분의 실행시점 예외는 선행조건 위반(precondition violation)을 나타낸다
* 사용자 정의 무점검 throwable은 RuntimeException의 하위 클래스로 만들어야 한다 (직접적이던 간접적이던 간에)
* Exception이나 RuntimeException 또는 Error의 하위 클래스가 아닌 throwable도 정의할 수 있다
* 복구 가능한 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류를 나타내고 싶을 때는 실행시점 예외를 사용하라

### 불필요한 점검지정 예외 사용은 피해라
* 점검지정 예외는 코드를 반환하는 것과는 달리, 프로그래머로 하여금 예외적인 상황을 처리하도록 강제함으로써 안정성을 높인다
* 점검지정 예외를 무점검 예외로 바꾸는 한 가지 방법은, 예외를 던지는 메서드를 둘로 나워서 첫 번째 메서드가 boolean 값을 반환하도록 만드는 것이다

### 표준 예외를 사용하라
* 자바 플랫폼 라이브러리에는 대부분의 API가 필요로 하는 기본적인 무점검 예외들이 갖추어져 있다
* 이미 있는 예외들을 재사용하면, 배우기 쉽고 사용하기 편리한 API를 만들 수 있다는 것, 그렇게 구현된 API는 가독성이 높다는 것, 예외 클래스 개수를 줄이면 프로그램의 메모리 요구량이 줄어들고 클래스를 로딩하는 시간도 줄어든다는 것
* IllegalArgumentException -> 잘못된 값을 인자로 전달했을 때 일반적으로 발생하는 오류
* IllegalStateException -> 현재 객체 상태로는 호출할 수 없는 메서드를 호출했을 때 일반적으로 발생하는 예외
* ConcurrentModificationException -> 하나의 스레드만 사용하도록 설계된 객체나, 외부적인 동기화 수단과 함께 이용되어야 하는 객체를 여러 스레드가 동시에 변경하려 하는 경우에 발생

### 추상화 수준에 맞는 예외를 던져라
* 상위 계층에서는 하위 계층에서 발생하는 예외를 반드시 받아서 상위 계층 추상화 수준에 맞는 예외로 바꿔서 던져야 한다 -> 이 숙어를 예외 변환(exception translation) 이라 부른다
* 대부분의 표준 예외들은 예외 연결 지원 생성자를 구비하고 있다
* 그런 생성자가 없는 예외는 Throwable.initCause 메서드를 호출하면 하위 계층 예외를 연결할 수 있다
* 하위 계층 메서드에서 예외가 발생하는 것을 막을 수 없다면, 그다음으로 좋은 방법은 하위 계층에서 생기는 문제를 상위 계층 메소드 호출자로부터 격리 시키는 것이다

### 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라
* 점검지정 예외는 독립적으로 선언하고, 해당 예외가 발생하는 상황은 Javadoc@throws 태그를 사용해서 정확하게 밝혀라
* 메서드가 던질 가능성이 있는 모든 무점검 예외까지 선언할 필요는 없으나, 점검지정 예외들과 마찬가지로 주의해서 문서로 남겨 놓으면 좋다
* javadoc@throws 태그를 사용해서 메서드에서 발생 가능한 모든 무점검 예외에 대한 문서를 남겨라, 하지만 메서드 선언부의 throws 뒤에 무점검 예외를 나열하진 마라
* 동일한 예외를 던지는 메서드가 많다면, 메서드마다 문서를 만드는 대신, 해당 예외에 대한 문서는 클래스의 문서화 주석에 남겨도 된다

### 어떤 오류인지를 드러내는 정보를 상세한 메세지에 담아라
* 무점검 예외 때문에 프로그램이 죽으면, 시스템은 자동적으로 해당 예외의 스택 추적 정보(stack trace)를 출력 -> 이 정보는 해당 예외 객체의 toString 메서드가 예외 정보를 문자열로 변환한 결과, 스택 추적 정보는 예외 객체의 클래스명 뒤에 상세 메시지가 오는 형태로 구성
* 오류 정보를 포착해 내기 위해서는, 오류의 상세 메세지에 예외에 관계된 모든 인자와 필드의 값을 포함시켜야 한다
* 오류를 적절히 포착하는 정보를 상세 메시지에 담는 한 가지 방법은, 상세한 정보를 요구하는 생성자를 만드는 것이다

### 실패 원자성 달성을 위해 노력하라
* 예외를 던지고 난 뒤에도 객체의 상태가 잘 정의된, 사용 가능한 상태로 남아 있으면 좋다
* 실패 원자성을 달성하는 방법 -> 변경 불가능 객체로 설계하는 것, 실패할 가능성이 있는 코드를 전부 객체 상태를 바꾸는 코드 앞에 배치하는 것, 연상 수행 도중에 발생하는 오류를 가로채는 복구 코드(recovery code)를 작성하는 것, 객체의 임시 복사본 상에서 필요한 연산을 수행하고, 연산이 끝난 다음에 임시 복사본의 내용으로 객체 상태를 바꾸는 것
* 예외와는 달리 오류는 복구가 불가능하며, 오류를 던지는 경우에는 실패 원자성을 보존하려 애쓸 필요가 없다

### 예외를 무시하지 마라
* 빈 catch 블록은 예외를 선언한 목적, 그러니까 예외적 상황을 반드시 처리하도록 강제한다는 목적
* 적어도 catch 블록 안에는 예외를 무시해도 괜찮은 이유라도 주석으로 남겨 두어야 한다