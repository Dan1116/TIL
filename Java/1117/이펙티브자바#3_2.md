# 이펙티브자바#3_2
### private 생성자나 열거 타입으로 싱글턴임을 보증하라
* 싱글턴 = 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다
* 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다, 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 가짜(mock) 구현으로 대체할 수 없기 때문이다
* 싱글턴을 만드는 방식은 보통 둘 중 하나다 -> 두 방식 모두 생성자는 private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다
* 둘 중 하나의 방식으로 만든 싱글턴 클래스를 직렬화하려면 단순히 Serializable 을 구현한다고 선언하는 것만으로는 부족하다, 모든 인스턴스 필드를 일시적(transient) 이라고 선언하고 readResolve 메서드를 제공해야 한다
* 싱글턴을 만드는 세 번째 방법은 원소가 하나인 열거 타입을 선언하는 것이다
* public 필드 방식과 비슷하지만, 더 간결하고, 추가 노력 없이 직렬화 할 수 있고, 심지어 아주 복잡한 직렬화 상황이나 리플렉션 공격에서도 제 2의 인스턴스가 생기는 일을 완벽히 막아준다
* 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다 (단 만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다, 열거 타입이 다른 인터페이스를 구현하도록 선언할 수는 있다)

### 인스턴스화를 막으려거든 private 생성자를 사용하라
* 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다, 하위 클래스를 만들어 인스턴스화하면 그만이다
* 인스턴스화를 막는 방법은 아주 간단하다 -> 컴파일러가 기본 생성자를 만드는 경우는 오직 명시된 생성자가 없을 때분이니 private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다
* 이 방식은 상속을 불가능하게 하는 효과도 있다

### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
* 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다
* 대신 클래스(SpellChecker)가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원(dictionary)을 사용해야 한다 -> 이 조건을 만족하는 간단한 패턴은 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식
* 팩터리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다 -> 팩터리 메서드 패턴(Factory Method pattern)
* 의존 객체 주입이 유연성과 테스트 용이성을 개선해주긴 하지만, 의존성이 수천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도 한다
* 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다 -> 대신 필요한 자원을 생성자에 넘겨주자 (의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 개선해준다)

### 불필요한 객체 생성을 피하라
* 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다
* 생성자 대신 정적 팩터리 매서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다 (Boolean 생성자 대신 Boolean.valueOf 팩터리를 사용하는 것이 좋다)
* 생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않다, 불변 객체만이 아니라 가변 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용할 수 있다
* String.matches 는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다
* 반환한 객체 중 하나를 수정하면 다른 모든 객체가 따라서 바뀐다
* 불필요한 객체를 만들어내는 또 다른 예로 오토박싱을 들 수 있다, 오토박싱은 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술
* 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다
* 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자
* 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다, 아주 무거운 객체가 아닌 다음에야 단순히 객체 생성을 피하고자 여러분만의 객체 풀(pool)을 만들지는 말자
* 방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다

### 다 쓴 객체 참조를 해제하라
* 해당 참조를 다 썼을 때 null 처리하면 객체가 참조하는 모든객체를 회수해가고 만약 null 처리한 참조를 실수로 사용하려 하면 프로그램은 즉시 NullPointerException을 던지며 종료
* 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다 -> 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다
* 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항상 메모리 누수에 주의해야 한다 (원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리해줘야 한다)
* 캐시 역시 메모리 누수를 일으키는 주범이다 
* 메모리 누수의 세 번째 주범은 바로 리스너 혹은 콜백

### finalizer 와 cleaner 사용을 피하라
* 자바는 두 가지 객체 소멸자를 제공한다
* finalizer 는 예측할 수 없고 상황에 따라 위험할 수 있어 일반적으로 불필요하다 (오작동, 낮은 성능, 이식성 문제의 원인이 되기도 한다)
* cleaner 는 finalizer 보다는 덜 위험하지만, 여전히 예측할 수 없고 , 느리고, 일반적으로 불필요하다
* 소멸자는 즉시 수행된다는 보장이 없다 -> 즉 finalizer 와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없다
* 자바 언어 명세는 finalizer 나 cleaner 의 수행 시점 뿐 아니라 수행 여부조차 보장하지 않는다
* 상태를 영구적으로 수정하는 작업에서는 절대 finalizer 나 cleaner에 의존해서는 안 된다
* finalizer 와 cleaner는 심각한 성능 문제도 동반한다, finalizer 를 사용한 객체를 생성하고 파괴하니 50배나 느렸다 (cleaner 비슷)
* finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다
* 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, finalizer 가 있다면 그렇지도 않다 (final 클래스들은 그 누구도 하위 클래스를 만들 수 없으니 이 공격에서 안전하다)
* final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들고 final로 선언하자
* 소멸자들은 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할을 한다, 또한 네이티브 피어 (native peer)와 연결된 객체에서다
* 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다, 네이티브 피어는 자바 객체가 아니어서 가비지 컬렉터는 그 존재를 알지 못한다
* cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용 (이런 경우라도 불확실성과 성능 저하에 주의해야 한다)

### try-finally 보다는 try-with-resources 를 사용하라
* 자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다
* 꼭 회수해야 하는 자원을 다룰 때는 try-finally 말고 try-with-resources를 사용하자, 예외는 없다 코드는 더 짧고 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다
* try-finally 로 정리하면 실용적이지 못할 만큼 코드가 지저분해지는 경우가 생길수도 있지만,  try-with-resources로는 정확하고 쉽게 자원을 회수할 수 있다