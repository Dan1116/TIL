# 이펙티브자바#3_1
* 명료성(clarity)과 단순성(simplicity)
*  코드는 복사되는 게 아니라 재사용되어야 한다
* 컴포넌트 사이의 의존석은 최소로 유지해야 한다
* 자바가 지원하는 타입 => 인터페이스, 클래스, 배열, 기본타입
* 참조 타입 = 인터페이스, 클래스, 배열
* 에너테이션은 인터페이스의 일종이며 열거 타입(enum)은 클래스의 일종이다
* 메서드 시그니처는 메서드 이름과 입력 매개변수(parameter)의 타입들로 이뤄진다 (반환값의 타입은 시그니처에 포함되지 않는다) 
* 상속 (inheritance) = 서브클래싱(subclassing) 
* 인터페이스 상속 대신 클래스가 인터페이스를 구현한다 (implement) 혹은 인터페이스가 다른 인터페이스를 확장한다 (extend)고 표현한다
* 아무것도 명시하지 않은 접근 수준(access level)을 이야기할 때는 패키지 접근 대신 전통적인 패키지-프라이빗을 쓴다
* 클래스, 인터페이스, 생성자, 멤버, 직렬화된 형태를 총칭해 API 요소라 한다

## 객체 생성과 파괴
* 객체를 만들어야 할 때와 만들지 말아야 할 때를 구분하는 법, 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법, 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령을 알아야 한다

### 생성자 대신 정적 팩터리 메서드를 고려하라
* 클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자이다
* 클래스는 생성자와 별도로 정적 팩터리 메서드를 제공할 수 있다

#### 정적 팩터리 메서드가 좋은 장점 다섯 가지
* 1.이름을 가질 수 있다 -> 반환될 객체의 특성을 쉽게 묘사할 수 있다 (한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주자) 
* 2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다 -> 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다, 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스 통제 클래스라 한다 (인스턴스를 통제하면 클래스를 싱글턴으로 만들 수도, 인스턴스화 불가로 만들 수 있고 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다)
* 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다 -> 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 엄청난 유연성을 선물, 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다
* 자바 8부터는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸기 때문에 인스턴스화 불가 동반 클래스를 둘 이유가 별로 없다
* 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다 -> 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다
* 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다 -> 이런 유연함은 서비스 제공자 프레임워크를 만드는 근간이 된다
* 서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이뤄진다 -> 구현체의 동작을 정의하는 서비스 인터페이스, 제공자가 구현체를 등록할 때 사용하는 제공자 등록 API, 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 서비스 접근 API

#### 정적 팩터리 메서드의 단점
* 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다 -> 컬렉션 프레임워크의 유틸리티 구현 클래스들을 상속할 수 없다는 이야기
* 2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다 -> 생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다

#### 정적 팩터리 메서드에 흔히 사용하는 명명 방식들
* from = 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
* of = 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
* valueof = form 과 of 의 더 자세한 버전
* instance , getInstance = 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다
* create , newInstance = instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장
* getType = getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다, Type 은 팩터리 메서드가 반환할 객체의 타입
* newType = newInstance 와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다, Type은 팩터리 메서드가 반환할 객체의 타입
* type = getType , newType의 간결한 버전

* 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다 

### 생성자에 매개변수가 많다면 빌더를 고려하라
* 선택적 매개변수가 많을 때 정적 팩터리와 생성자는 적절히 대응하기 어렵다 
* 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다
* 선택 매개변수가 많을 때에는 자바빈즈 패턴을 사용할 수 있다 -> 매개변수가 없는 생성자로 객체를 만든 후, 세터 메서드들을 호출해 원하는 매개변수의 값을 설정하는 방식
* 자바빈즈 패턴에서는 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다 -> 자바빈즈 패턴에서는 클래스를 불면으로 만들 수 없으며, 스레드 안전성을 얻으려면 프로그래머가 추라 작업을 해줘야 한다
* 빌더 패턴 -> 클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수만으로 생성자(혹은 정적 팩터리)를 호출해 빌더 객체를 얻는다, 그 후 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수들을 설정, 마지막으로 매개변수가 없는 build 메서드를 호출해 드디어 우리에게 필요한 객체를 얻는다
* 빌더 패턴은 명명된 선택적 매개변수를 흉내 낸 것이다, 계층적으로 설계된 클래스와 함께 쓰기에 좋다
* 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능을 공변 반환 타이핑(covariant return typing) -> 이 기능을 이용하면, 클라이언트가 형변환에 신경 쓰지 않고도 빌더를 사용할 수 있다
* 생성자로는 누릴 수 없는 사소한 이점으로, 빌더를 이용하면 가변인수(varargs) 매개변수를 여러 개 사용할 수 있다 ( 각각을 적절한 메서드로 나눠 선언하면 된다)
* 빌더 패턴의 단점은 객체를 만들려면, 그의 앞서 빌더부터 만들어야 한다는 것이다 -> 빌더 생성 비용이 크지는 않지만 성능에 민감한 상황에서는 문제가 될 수 있다, 또한 점층적 생성자 패턴보다는 코드가 장황해서 매개변수가 4개 이상은 되어야 값어치를 한다
* 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 더 낫다