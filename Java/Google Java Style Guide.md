# Google Java Style Guide
## Introduction
* 코딩 표준을 정의한 것이다, Java 소스 파일은 여기에 있는 규칙을 준수하는 경우에만 Google 스타일로 설명이 된다

## Terminology notes (용어 노트)
1. @interface는 일반 클래스, enum 클래스, 인터페이스, 주석을 의미한다
2. 멤버 (클래스)라는 용어는 중첩 된 클래스, 필드, 메서드 또는 생성자를 의미하는 데 포괄적으로 사용된다. 즉 초기화 이거나 주석을 제외한 클래스의 모든 최상위 내용이 멤버클래스인 것이다
3. 주석이라는 용어는 항상 구현 주석을 나타냅니다. “Javadoc”이라는 일반 용어를 사용하는 대신 “documentation comments”라는 구를 사용하지 않는다
* 다른 “용어 노트”는 문서 전체에서 간혹 나타난다
* 이 문서의 예제 코드는 비 규범 적입니다. 즉, 예제는 Google 스타일에 있지만 코드를 나타내는 유일한 방법은 설명하지 못할 수 있습니다. 예제에서의 선택적인 형식화는 규칙으로 적용해서는 안된다

* 소스 파일 이름이 포함된 최상위 클래스의 대소문자로 구분 이름을 명명한다. 확장자는 .java로 지정한다.
* 파일의 인코딩은 UTF-8로 지정한다.
* 공백문자는 소스 파일에서 아무렇게나 쓸 수 있는 유일한 문자이다.
* 모든 특수 문자를 사용할 때 이스케이프 시퀀스(예를 들어 \b , \t , \n , \f , \r , \” , \’ 와 \\ )를 사용한다.
* 그러나 그 문자의 진수(\012 ). 유니코드 (예 : \u000a ) 는 사용하지 않는다.
* 코드 가독성이 좋다면 비 ASCII문자(\u221e)를 사용해도 무방하다.

## Source file basics (소스 파일 구조)
### File name
* 소스 파일 이름은 포함하고있는 최상위 레벨 클래스의 대소 문자를 구분하는 이름과 .java 확장자로 구성된다

### Whitespace characters
* 문자열 및 문자 리터럴의 다른 모든 공백 문자는 이스케이프 처리된다
* 탭 문자는 들여 쓰기에 사용되지 않는다

### Non -ASCII characters
* 나머지 비 ASCII 문자의 경우 실제 유니 코드 문자 또는 이와 동등한 유니 코드 이스케이프가 사용된다. 유니 코드는 문자열 리터럴 밖에서 이스케이프 처리되고 주석은 강력하게 권장되지 않지만 코드를 더 쉽게 읽고 이해할수있게하는 것에 중점을 둬야한다

* 유니 코드 이스케이프의 경우, 때로는 실제 유니 코드 문자가 사용되는 경우에도 설명 주석이 매우 유용 할 수 있습니다.

## Source file structure
### 소스 파일의 구조의 순서
1. 라이센스 또는 저작권 정보 
2. 패키지 문
3. import 문
4. 정확히 하나의 최상위 클래스

### 라이센스 또는 저작권 정보
* 라이센스 또는 저작권이 있는 경우 표기해야한다

### 패키지 문
* 패키지 문은 줄 바꿈되지 않는다

### Import 문
* Wildcard imports 문은 사용하지 않는다
* Import 하는 것은 줄바꿈 되지 않는다

#### 정리와 공백
* 모든 정적, 비정적 import는 단일 블록으로 이루어진다
* 정적 및 비 정적 import가 모두있는 경우 하나의 빈 줄이 두 블록을 분리합니다. import 문 사이에 다른 빈 줄이 없다

* 각 블록 내에서 가져온 이름은 ASCII 정렬 순서로 나타낸다
* 정적 import는 정적 중첩 클래스에는 사용되지 않는다
* 각 최상위 클래스는 고유한 소스 파일에 있다

### ordering of class contents
* 클래스의 멤버 및 초기화 프로그램에 대해 선택한 순서는 학습 가능성에 큰 영향을 줄 수 있다
*  그러나 이를 수행하는 방법에 대한 올바른 올바른 방법은 없습니다. 다른 클래스는 다른 방법으로 내용을 주문할 수 있다
* 중요한 것은 각 클래스가 논리적인 순서를 사용한다는 점이다. 새로운 메소드는 클래스의 마지막에 습관적으로 추가되는 것이 아니라 논리적 순서가 아닌 “날짜순으로 시간순으로 정렬”순서를 생성한다
* 클래스에 여러 생성자가 있거나 동일한 이름을 가진 여러 메소드가있는 경우 이들 클래스는 순서대로 나타나며 그 사이에 다른 코드는 없어야 한다

## Formatting
* 블록과 같은 구조체는 클래스, 메서드 또는 생성자의 본문을 참조합니다. 모든 배열 이니셜 라이저는 선택적으로 블록 같은 구조로 처리 될 수 있다

### Braces (중괄호)
* 중괄호는 본문이 비어 있거나 단일 문만 포함하는 경우에도 if, else, for, do 및 while 문과 함께 사용된다

### Nonempty blocks : K & R style
* 여는 중괄호 앞에 줄 바꿈이 없다
* 여는 중괄호 뒤의 줄 바꿈을 해야한다
* 닫는 중괄호 앞에 줄 바꿈을 해야한다
* 해당 중괄호가 문을 종료하거나 메서드, 생성자 또는 명명 된 클래스의 본문을 종료하는 경우에만 닫는 중괄호 뒤의 줄 바꿈을 해야한다, 예를 들어, else 또는 쉼표가 뒤에 오는 경우 중괄호 다음에 줄 바꿈이 필요 없다

### Empty blocks: may be concise (간결한)
* 빈 블록이나 블록과 같은 구조는 K & R 스타일 일 수 있다, 또는 다중 블록 명령문의 일부가 아닌 한 문자를 열지 않고 줄 바꿈 ({})을 사용하여 열 직후 닫을 수 있습니다

### Block indentation : +2 spaces 블록 들여 쓰기 : +2 공백
* 새로운 블록 또는 블록과 같은 구조가 열릴 때마다 들여 쓰기가 두 칸 증가한다. 블록이 끝나면 들여 쓰기가 이전 들여 쓰기 수준으로 돌아간다. 들여 쓰기 수준은 블록 전체에서 코드와 주석 모두에 적용된다.

### One statement per line
* 각 명령문 다음에 줄 바꿈이온다

### Column limit : 100
* Java 코드의 컬럼 제한은 100 자 이다. “문자”는 모든 유니 코드 코드 포인트를 의미한다
* 각 유니 코드 코드 포인트는 표시 폭이 더 크거나 작더라도 하나의 문자로 계산된다

### 예외
* Column limit에 복종하는 라인은 불가능합니다.
* 페키지와 import 선언문
* 쉘에 잘라 붙일 수있는 주석의 명령 행

### Line-wrapping
* 단일 행을 차지할 수있는 코드가 여러 줄로 분리되면이 활동을 줄 바꿈이라고한다
* 모든 상황에서 정확히 줄 바꿈하는 방법을 정확하게 보여주는 포괄적이고 결정적인 공식은 없습니다. 매우 자주 동일한 코드를 줄 바꿈하는 여러 가지 유효한 방법이 있습니다.
* 줄 바꿈의 일반적인 이유는 열 제한이 넘치는 것을 피하는 것이지만 실제로 열 제한 내에 들어갈 수있는 코드조차도 작성자의 재량에 따라 줄 바꿈 될 수 있습니다.

### 수직 공백
* 필드, 생성자, 중첩 메소드, 클래스 사이
* 여러 줄의 빈 줄은 허용하지만, 추천하지 않는다

### 수평 공백
* if, for, catch와 그다음에 오는 ‘(‘ 사이에 공백문자
* else, catch와 그 이전에 오는 ‘}’ 사이에 공백문자
* ‘,’, ‘:’, ‘;’의 다음이나 타입 캐스트시의 ‘)’ 다음에 공백문자
* 연산자 앞뒤로는 공백문자 삽입
* 연산자와 비슷한 심볼에서도 앞뒤로 공백문자 삽입

### 그룹화 권장
* 소스의 그룹화를 통해 가동성을 좋게 만들 수 있다

## 서식
### 특정 구조
* 열거형, 배열 선언
* 열거형 정수 다음에 쉼표, 그 이후 줄 바꿈은 선택이다

### 변수 선언
* 모든 변수 선언은(맴버 또는 지역) 하나의 변수 선언을 사용하지 않는다
* 맴버 변수는 사용하는 점 부근에서 선언한다
* 지역 변수는 일반적으로 초기화를 하거나 선언 후 즉시 초기화 한다

### C 스타일 배열 선언
* String [] args 로 선언한다

### Switch 
* 스위치문 뒤에 열린 중괄호를 두고 줄 바꿈이 일어난다
* 줄 바꿈 후에는 +2 들여쓰기가 일어난다, 중괄호가 종료되면 이전 들여쓰기 수준으로 돌아간다
* case, default 뒤 줄 바꿈이 일어난다, 줄 바꿈이 일어나면 블록이 열려있는 것처럼 +2 들여쓰기가 일어난다
* case, default 블록이 종료되면 이전 들여쓰기 수준으로 돌아간다

### 통과 주석
* switch ~ case 는 기본적으로 break, return, throw 로 switch 의 블록 구분을 나타낸다
* 다음 case 계속된 실행을 나타날떄는 주석을 남긴다

### 어노테이션
* 하나의 라인에 어노테이션을 사용한다. 들여쓰기는 증가하지 않는다

### 주석
* 주석은 주변 코드와 같은 수준의 들여쓰기를 사용한다

### 숫자 리터럴
* long 타입의 리터럴은 대문자로 사용 L

## 네이밍
### 패키지 이름
* 패키지 이름은 단순히 함께 연결된 연속 단어, 모두 소문자로 되어있다

### 클래스 이름 
* 클래스 이름은 명사 또는 명사구입니다. 인터페이스 이름은 명사 또는 명사구, 형용사구이다. (형용사 + 명사)
* 클래스의 단어 구분은 대문자로 구분한다
* Unit 테스트 클래스는 test로 시작한다

### 메소드 이름
* 메소드 이름은 동사나 동사구이다. (동사 + 명사)
* 메소드의 단어의 구분은 대문자로 구분한다. - Unit 테스트 클래스는 test로 시작한다

### 상수 이름
* 상수 이름은 모두 대문자로 밑줄로 단어 구분 된다

### 맴버 변수 이름
* 일반적으로 명사 또는 명사구이다

### 지역 변수 이름
* 일반적으로 명사 또는 명사구이다
* 지역변수는 단어를 자유롭게 단축할 수 있다

## Programming Practices
### @Override
* 인터페이스 방법을 구현하는 방법 또는 재정의하는 매소드의 경우는 @Override를 반드시 사용한다

### 예외 규칙을 무시하지 않기
* try ~ catch 를 사용하는 경우 catch 문 안에 아무런 애용이 없으면 안 된다

### 정적 참조
* 직접적인 참조로 상요한다

## 자바독
### 단락
* 한 줄의 빈 라인이다

### 절
* @param , @return , @throws , @deprecated의 네 가지 유형은 반드시 설명이 있어야 한다.

### 내용
* 반드시 하나의 문장으로 완성해야 한다