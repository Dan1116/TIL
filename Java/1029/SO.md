# SO
## The Single Responsibility Principle (SRP)
* 이 원칙은 Tom DeMarco 와 Meilir Page- Jones에 의해 묘사 된 원칙이다, 그들은 이것을 cohesion(결합)이라 불렀다.
* 왜  두개의 의무가 각각의 클래스들에 의해 나누어져 있을까?  -> 각각의 책임과 의무는 변화의 중심축(axis)이기 때문이다
* 만약 하나의 클래스가 하나 이상의 책임이 있다면, 꼭 그 클래스를 바꿔야 한다
* 두 가지의 책임을 가지고 있는 클래스의 책임을 하나로 변경하면 클래스의 능력이 손상되거나 금지 될 수 있다

### 책임과 의무는 무엇인가?
* 우리는 책임과 의무를 변화의 이유로 정의했다 
* 각각의 다른 두가지의 의무와 책임은 두 개의 나누어진 각각의 interface에게 집어넣어야 한다

## The Open-Closed Principle (OCP)
* 모든 변수들은 private으로 해야하고 , global 변수들은 피해야한다, run time type identification 을 사용하는 것은 위험하다
* Betrand Meyer -> 소프트웨어 ENTITLES(CLASSES, MODULES, FUNCTIONS…) 은 확장에는 열려있어야 하지만, 수정에는 닫혀 있어야 한다
* 프로그램에 대한 단일 변경으로 인해 종속 모듈의 변경 사항이 연속적으로 발생하면 해당 프로그램은 "잘못된"설계와 관련이 있는 바람직하지 않은 특성을 나타낸다

### 추상화가 키(답) 이다
* 추상화는 추상적인 기본 클래스이며 가능한 모든 동작의 제한되지 않은 그룹은 모든 가능한 파생 클래스에 의해 나타난다
* 모듈이 추상화를 조작하는 것이 가능하다, 그러한 모듈은 수정 된 추상화에 의존하기 때문에 수정을 닫아야한다, 그러나 추상화의 새로운 파생물을(derivatives) 만들어 해당 모듈의 동작을 확장 할 수 있습니다.

### 추상화의 모양
* 기존의 코드를 바꾸는거 보다는 새로운 코드를 추가함으로써 변경되기 때문에 부적합한 프로그램이 보여주는 변경 사항의 연속을 경험하지 않습니다.

### 전략적인 closure(종결)
* 종결은 완료 될 수 없으므로 전략적이어야한다

### 결론
* 여러면에서 이 원칙은 객체 지향 설계의 핵심입니다. 이 원리의 준수는 객체 지향 기술에 대해 가장 큰 이익을 얻는 것입니다. 재사용 성 및 유지 보수성. 설계자가 변경 될 수 있다고 느끼는 프로그램 부분에 추상화를 적용하려면 디자이너의 노력이 필요합니다



