# 이펙티브 자바_10
## 병행성
* 스레드를 이용하면 여러 활동을 병렬적으로 진행할 수 있다, 하지만 문제가 생길 수 있는 곳도 늘어나고 오류를 재현하기도 어려워진다
* 하지만 병행성을 외면할 수는 없다, 멀티코어 프로세서에서 좋은 성능을 내야 한다는 요구사항도 보편화되고 있다

### 변경 가능 공유 데이터에 대한 접근은 동기화하라
* 동기화 (synchronized) 키워드는 특정 메서드나 코드 블록을 한 번에 한 스레드만 사용 하도록 보장한다
* 많은 프로그래머는 동기화(synchronization)를 상호 배제적(mutually exclusive)인 관점, 그러니까 다른 스레드가 변경 중인 객체의 상태를 관측할 수 없어야 한다는 관점으로만 바라본다
* 객체는 일관된(consistent) 상태를 갖도록 생성되며, 해당 객체를 접근하는 메서드는 그 객체에 락(lock)을 건다
* 락을 건 메서드는 객체의 상태를 관측할 수 있으며, 선택적으로 객체 상태를 변경할 수도 있다, 하나의 일관된 상태에서 다른 일관된 상태로 전이시킬 수 있다는 것
* 동기화 메커니즘을 적절히 사용하기만 하면, 모든 메서드가 항상 객체의 일관된 상태만 보도록 만들 수 있다
* 동기화 없이는 한 스레드가 만든 변화를 다른 스레드가 확인할 수 없다
* 동기화는 스레드가 일관성이 깨진 객체를 관측할 수 없도록 할 뿐 아니라, 동기화 메서드나 동기화 블록에 진입한 스레드가 동일한 락의 보호 아래 이루어진 모든 변경(modification)의 영향을 관측할 수 있도록 보장
* 자바 언어 명세에는 long 이나 double이 아닌 모든 변수는 원자적(atomic) 으로 읽고 쓸 수 있다고 되어 있다
* 언어 명세상으로는 필드에서 읽어낸 값은 임의의 값이 될 수 없다고 되어 있으나, 그렇다고 어떤 스레드가 기록한 값을 반드시 다른 스레드가 보게 되리라는 보장은 없다
* 상호 배제성뿐 아니라 스레드 간의 안정적 통신을 위해서도 동기화는 반드시 필요 (메모리 모델 때문)
* 메모리 모델은 한 스레드가 만든 변화를 다른 스레드가 볼 수 있게 되는 시점과 그 절차를 규정
* 변경 가능한 공유 데이터에 대한 접근을 동기화하지 않았을 때 생길 수 있는 결과는, 그 데이터가 원자적으로 읽고 쓸 수 있는 데이터라 해도 심각하다
* Thread.stop은 절대 이용하지 마라, false로 초기화되는 boolean 필드를 이용하는 것이 바람직, 한 스레드는 이 필드의 값이 true로 바뀌는지 계속 검사해서 true로 바뀌면 실행을 스스로 중단하고, 해당 스레드를 중지시켜야 하는 다른 스레드는 필요할 때 해당 필드의 값을 true로 바꿔주면 된다
* 읽기 연산과 쓰기 연산에 전부 적용하지 않으면 동기화는 아무런 효과도 없다
* 어떤 스레드건 가장 최근에 기록된 값을 읽도록 보장
* 변경 가능 데이터는 한 스레드만 이용하도록 하라는 것
* 특정한 스레드만이 데이터 객체를 변경할 수 있도록 하고, 변경이 끝난 뒤에 다른 스레드와 공유하도록 할 때는 객체 참조를 공유하는 부분에만 동기화를 적용
* 실질적으로 변경 불가능한 객체(effectively immutable) -> 객체 참조를 가져온 스레드는, 객체가 더 이상 수정되지 않는 한, 동기화 없이도 객체의 내용을 읽을 수 있다
* 이런 객체 참조를 다른 스레드로 전달하는 행위를 안전한 발행이라고 부른다
* 변경 가능한 데이터를 공유할 때는 해당 데이터를 읽거나 쓰는 모든 스레드는 동기화를 수행해야 한다는 것

### 과도한 동기화는 피하라
* 동기화를 너무 과도하게 적용하면 성능 저하, 교착상태(deadlock), 비결정적 동작(nondeterministic behavior) 등의 문제가 생길 수 있다
* 생존 오류나 안전 오류를 피하고 싶으면, 동기화 메서드나 블록 안에서 클라이언트에게 프로그램 제어 흐름(control)을 넘기지 마라
* 동기화가 적용된 영역 안에서는 재정의 가능 메서드나 클라이언트가 제공한 함수 객체 메서드를 호출하지 말라는 것
* 동기화가 적용된 영역 안에서는 재정의 가능 메서드나 클라이언트가 제공한 함수 객체 메서드를 호출하지 말라는 것 -> 동기화 영역이 존재하는 클래스 관점에서 보면, 이런 메서드는 불가해(alien) 메서드
* 동기화 영역 바깥에서 불가해 메서드를 호출하는 것을 열린 호출(open call)이라고 한다 -> 오류를 방지할 뿐 아니라, 병행성을 대단히 높여주는 기법
* 동기화 영역 안에서 수행되는 작업의 양을 가능한 한 줄여야 한다는 것
* 변경 가능 클래스의 경우, 병렬적으로 이용될 클래스이거나, 내부적인 동기화를 통해 외부에서 전체 객체에 락을 걸 때보다 높은 병행성을 달성할 수 있을 때만 스레드 안정성을 갖도록 구현해야 한다
* 클래스 내부적으로 동기화 메커니즘을 적용해야 한다면, 락 분할, 락 스트라이핑, 비봉쇄형 병행성 제어처럼 높은 병생성을 달성하도록 돕는 기법을 이용해야 한다
* static 필드를 변경하는 메서드가 있을 때는 해당 필드에 대한 접근을 반드시 동기화해야 한다 ( 보통 한 스레드만 이용하는 메서드라 해도 그렇다 )
* 데드락과 데이터 훼손 문제를 피하려면 동기화 영역 안에서 불가해 메서드는 호출하지 말라는 것 -> 동기화 영역 안에서 하는 작업의 양을 제한하라는 것

### 스레드보다는 실행자와 테스크를 이용하라
* java.util.concurrent -> 이 패키지에는 실행자 프레임워크(Executor Framework), 유연성이 높은 인터페이스 기반 태스크 실행 프레임워크
* 큐의 작업을 처리하는 스레드를 여러 개 만들고 싶을 때는 스레드 풀이라 불리는 실행자 서비스를 생성하는 정적 팩터리 메서드를 이용하면 된다 (스레드 풀에 담기는 스레드의 숫자는 고정시켜 놓을 수도 있고, 가변적으로 변하도록 설정할 수도 있다)
* 일반적으로 스레드를 직접 이용하는 것도 피하는 것이 좋다
* 태스크에는 두 가지 종류가 있다 -> Runnable , Callable ( 값을 반환하는 차이가 있다)
* Runnable = 다른 스레드에 의해서 실행되어질 수 있는 클래스의 객체를 위한 interface, 바로 Thread에 인자로 전달 할 수 있다, 객체는 결과를 반환하지 않는다, 확인 된 예외를 슬로우 할 수 없다
* Callable = 다른 스레드에 의해서 실행되어질 수 있는 클래스의 객체를 위한 interface, 바로 Thread에 인자로 전달 할 수 없다, 객체는 결과를 V 형으로 반환한다, 객체가 예외를 throw 할 가능성이 있는 경우

### wait나 notify 대신 병행성 유틸리티를 이용하라
* wait과 notify를 정확하게 사용하는 것이 어렵기 때문에, 이 고수준 유틸리티들을 반드시 이용해야 한다
* java.util.concurrent에 포함된 이 유틸리티들은 실행자 프레임워크, 병행 컬렉션(concurrent collection), 동기화 (synchronizer) 
* 병행 컬렉션은 List, Queue,Map 등의 표준 컬렉션 인터페이스에 대한 고성능 병행 컬렉션 구현을 제공 -> 이 컬렉션들은 병행성을 높이기 위해 동기화를 내부적으로 처리한다
* 컬렉션 외부에서 병행성을 처리하는 것은 불가능하다, 락을 걸어봐야 아무 효과가 없을 뿐 아니라 프로그램만 느려진다
* 클라이언트는 병행 컬렉션에 대한 메서드 호출을 원자적으로 작성 할 수 없다 그래서 컬렉션 인터페이스 가운데 일부는 상태 종속 변경 연상(state-depended modify operation)으로 확장되었는데, 이는 몇 가지 기본 연상(primitive)들을 하나의 원자적 연상(automic operation)으로 묶는 것이다
* 확실한 이유가 없다면, Collections.synchronizedMap 이나 Hashtable 대신 ConcurrentHashMap을 이용하자
* 생산자 스레드들은 큐에 새 작업이 들어오면 꺼내어 처리하면 된다
* 동기자는 스레드들이 서로를 기다릴 수 있도록 하여, 상호 협력이 가능하게 한다
* 특정 구간의 실행시간을 잴 때는 System.currentTimeMillis대신 System.nanoTime을 사용해야 한다
* wait 메서드를 호출할 때는 반드시 이 대시 순환문 (wait loop) 숙어대로 하자

* 조건이 만족되지도 않았는데 스레드가 깨어나는 데는 몇 가지 이유가 있다 
* 1. 다른 스레드가 notify를 호출한 적에 wait 상태에서 벗어나긴 했는데, 또 다른 스레드가 락을 획득해서 해당 락이 보호하는 상태를 바꿔버린 경우
* 2. 조건이 만족될 수 없는 상황에서 다른 스레드가 우연히 또는 악의적으로 notify를 호출한 경우, 외부로 공개된 객체에 wait를 호출하면 이런 상황에 노출, 클래스 외부로 공개된 객체에 정의된 동기화 메서드 안에서 wait를 호출하면 이런 문제가 생긴다
* wait를 호출하여 대기 중인 스레드를 깨우는 스레드가 너무 너그러운 경우
* notify 호출 없이도 대기 중인 메서드가 깨어나는 경우 , 허위 각성이라고 부른다

* 새로 만드는 프로그램에 wait 이나 notifty를 사용할 이유는 거의 없다

### 스레드 안전성에 대해 문서로 남겨라
* synchronized 키워드는 메서드의 구현 상세(implementation detail)에 해당하는 정보이며, 공개 API의 일부가 아니다
* 병렬적으로 사용해도 안전한 클래스가 되려면, 어떤 수준의 스레드 안전성을 제공하는 클래스인지 문서에 명확하게 남겨야 한다
* 변경 불가능(immutable) = 이 클래스로 만든 객체들은 상수, 따라서 외부적인 동기화 메커니즘 없이도 병렬적으로 이용이 가능 (String, Long, BibInteger)
* 무조건적 스레드 안전성(unconditionally thread-safe) = 이 클래스의 객체들은 변경이 가능하지만 적절한 내부 동기화 메커니즘을 갖추고 있어서 외부적으로 동기화 메커니즘을 적용하지 않아도 병렬적으로 사용할 수 있다 ( Random, ConcurrentHashMap)
* 조건부 스레드 안전성(conditionally thread-safe) = 무조건적 스레드 안전성과 거의 같은 수준이나, 몇몇 스레드는 외부적 동기화가 없이는 병렬적으로 사용할 수 없다 ( Collections.synchronized 계열 메서드가 반환하는 포장 객체(wrapper))
* 스레드 안전성 없음 = 이 클래스의 객체들은 변경 가능하다, 해당 객체들을 병렬적으로 사용하려면 클라이언트는 메서드를 호출하는 부분을 클라이언트가 선택한 외부적 동기화 수단으로 감싸야 한다 (ArrayList, HashMap) 
* 다중 스레드에 적대적(thread-hostile) = 이런 클래스의 객체는 설사 메서드를 호출하는 모든 부분을 외부적 동기화 수단으로 감싸더라도 안전하지 않다, 이런 클래스가 되는 것은 보통, 동기화 없이 정적 데이터(static data)를 변경하기 때문

* 메서드를 실행하려면 어떤 락을 사용해야 하는지 명시해야 한다, 보통은 객체 자체에 락을 걸면 되는데, 다른 객체에 대한 뷰 역할을 하는 객체의 경우, 클라이언트는 원래 객체에 대해 동기화를 해야 한다
* 클래스의 스레드 안전성에 대한 설명은 일반적으로 클래스의 문서화 주석에 들어가지만, 특별한 스레드 안전성 속성을 갖는 메서드는 그 속성을 자기 문서화 주석에 설명해야한다 ( enum 자료형의 경우에는 변경 불가능성을 문서에 밝힐 필요는 없다)
* private 락 객체는 클래스 바깥에서는 이용할 수 없으므로, 클라이언트는 객체의 동기화 메커니즘에 개입할 수 없다
* private 락 객체 숙어는 계승을 염두에 두고 설계하는 클래스에 걸맞다

### 초기화 지연은 신중하게 하라
* 초기화 지연(lazy initialization)은 필드 초기화를 실제로 그 값이 쓰일 때까지 미루는 것이다, 값을 사용하는 곳이 없다면 필드는 결코 초기화되지 않을 것이다 (static 필드와 객체 필드에 모두 적용 가능)
* 대부분의 경우, 지연된 초기화를 하느니 일반 초기화를 하는 편이 낫다
* 초기화 순환성(initialization circularity) 문제를 해소하기 위해서 초기화를 지연시키는 경우에는 동기화된 접근자 (synchronized accessor) 를 사용하라
* 성능 문제 때문에 정적 필드 초기화를 지연시키고 싶을 때는 초기화 지연 담당 클래스(lazy initialization holder class) 숙어를 사용하라
* 성능 문제 때문에 객체 필드 초기화를 지연시키고 싶다면 이중 검사 숙어를 사용하라

### 스레드 스케줄러에 의존하지 마라
* 스레드 스케줄러(thread scheduler) = 실행할 스레드가 많을 때, 어떤 스레드를 얼마나 오랫동안 실행할지 결정하는 것
* 정확성을 보장하거나 성능을 높이기 위해 스레드 스케줄러에 의존하는 프로그램은 이식성이 떨어진다 (non-portable)
* 스레드는 필요한 일을 하고 있지 않을 때는 실행 중이어서는 안 된다
* 스레드는 바쁘게 대기 (busy wait) 해서는 안 된다, 즉 무언가 일어나길 기다리면서 공유 객체를 계속 검사해대서는 곤란하다
* 스레드 우선순위는 자바 플랫폼에서 가장 이식성이 낮은 부분 가운데 하나다

### 스레드 그룹은 피하라
* 스레드 시스템이 제공하는 기본적인 추상화 단위(abstraction) 가운데는 스레드 락, 모니터 이외에도 스레드 그룹 이라는 것이 있다
* 스레드 그룹은 이제 폐기된 추상화 단위