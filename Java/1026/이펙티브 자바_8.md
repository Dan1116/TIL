# 이펙티브 자바_8
## 일반적인 프로그래밍 원칙들
* 지역 변수, 제어 구조, 라이브러리, 다양한 자료형,  리플렉션(reflection), 네이티브 메서드(native method)

### 지역 변수의 유효범위를 최소화
* 클래스와 멤버의 접근 권한은 최소화
* 지역 변수의 유효범위를 최소화하면 가독성(readability)과 유지보수성(maintainability) 이 좋아지고 오류 발생 가능성도 줄어든다
* 지역 변수의 유효범위를 최소화하는 가장 강력한 기법은, 처음으로 사용하는 곳에서 선언하는 것
* 거의 모든 지역 변수 선언에는 초기값(initializer)이 포함되어야 한다
* while 문보다는 for 문을 쓰는 것이 좋다 -> 순환문 변수의 내용은 순환문 수행이 끝난 이후에는 필요 없다는 가정하에
* for 문을 사용할 때는 순환문마다 다른 이름의 변수를 이용할 필요가 없기 때문에, 복사해서 붙여넣기 버그가 발생할 가능성은 더욱 줄어든다 그리고 각각의 for 문은 서로 의존성이 없으므로, 같은 변수명을 거듭 사용해도 괜찮다
* 지역 변수의 유효범위를 최소화하는 마지막 전략은 메서드의 크기를 줄이고 특정한 기능에 집중하라는 것

### for 문보다는 for-each 문을 사용하라
* for-each문의 성능은 for 문과 같다(배열에도 마찬가지), for-each문의 장점은 여러 컬렉션에 중첩되는 순환문을 만들어야 할 때
* for-each 문으로는 컬렉션과 배열뿐 아니라 Iterable 인터페이스를 구현하는 어떤 객체도 순회할 수 있다 ( Iterable 인터페이스는 메서드가 하나뿐인 아주 간단한 인터페이스)
* for-each 문을 적용할 수 없는 것들 -> 필터링(filtering), 컬렉션을 순회하다가 특정한 원소를 삭제할 필요가 있다면, 반복자를 명시적으로 사용해야 한다. 반복자의 remove 메서드를 호출해야 하기 때문/ 변환(transforming), 리스트나 배열을 순회하다가 그 원소 가운데 일부 또는 전부의 값을 변경해야 한다면, 원소의 값을 수정하기 위해서 리스트 반복자나 배열 첨자가 필요/ 병렬 순회(parallel iteration), 여러 컬렉션을 병렬적으로 순회해야 하고, 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구현해야 한다면 반복자나 첨자 변수를 명시적으로 제어할 필요가 있다

### 어떤 라이브러리가 있는지 파악하고, 적절히 활용
* 중요한 새 라이브러리가 나올 때마다 많은 기능이 새로 추가되는데, 그때마다 어떤 것들이 추가 되었는지를 알아두는 것이 좋다

### 정확한 답이 필요하다면 float와 double은 피하라
* 돈 계산을 할 때는 BigDecimal, int 또는 long을 사용하라, float 과 double은 오차가 존재한다

### 객체화된 기본 자료형 대신 기본 자료형을 이용하라
* 모든 자료형에는 대응되는 참조 자료형이 있는데, 이를 객체화된 기본 자료형(boxed primitive type)이라 부른다
* 기본 자료형과 객체화된 기본 자료형 사이에는 세가지 큰 차이점이 있다 -> 
* 1. 기본 자료형은 값만 가지지만 객체화된 기본 자료형은 값 외에도 신원(identity)을 가진다는 것 ( 객체화된 기본 자료형 객체가 두 개 있을 때, 값은 같더라도 신원은 다를 수 있다) 
* 2. 기본 자료형에 저장되는 값은 전부 기능적으로 완전한 값이지만, 객체화된 기본 자료형에 저장되는 값에는 그 이외에도 아무 기능도 없는 값, 즉 null이 하나 있다는 것. 
* 3. 기본 자료형은 시간이나 공간 요구량 측면에서 일반적으로 객체 표현형보다 효율적
* 객체화된 기본 자료형에 == 연산자를 사용하는 것은 거의 항상 오류
* 기본 자료형과 객체화된 기본 자료형을 한 연산 안에 엮어 놓으면 객체화된 기본 자료형은 자동으로 기본 자료형으로 변환된다
* 자동 객체화는 번거로운 일을 줄여주긴 하지만, 객체화된 기본 자료형을 사용할 때 생길 수 있는 문제들까지 없애주진 않는다
* 객체화된 기본 자료형과 기본 자료형을 한 표현식 안에 뒤섞으면 비객체화가 자동으로 일어나며, 그 과정에서 NullPointerException이 발생할 수 있다

### 다른 자료형이 적절하다면 문자열 사용을 피하라
* 문자열은 텍스트 표현과 처리에 걸맞도록 설계 
* 문자열은 값 자료형을 대신하기에는 부족하다
* 문자열은 enum 자료형을 대신하기에는 부족하다
* 문자열은 혼합 자료형 (aggregate type)을 대신하기에는 부족하다
* 문자열은 권한(capability)을 표현하기에는 부족하다

### 문자열 연결 시 성능에 주의하라
* n개의 문자열에 연결 연산자(+)를 반복 적용해서 연결하는 데 드는 시간은, n 제곱에 비례한다 (문자열이 변경 불가능하기 때문)
* + 연산자 대신, StringBuilder의 append 메서드를 사용

### 객체를 참조할 때는 그 인터페이스를 사용하라
* 만일 적당한 인터페이스 자료형이 있다면 인자나 반환값, 변수, 그리고 필드의 자료형은 클래스 대신 인터페이스로 선언하자 (객체의 실제 클래스를 참조할 필요가 있는 유일한 순간은, 생성자로 객체를 생성할 때)
* 인터페이스를 자료형으로 쓰는 습관을 들이면 프로그램은 더욱 유연해진다
* 적당한 인터페이스가 없는 경우에는 객체를 클래스로 참조하는 것이 당연하다

### 리플렉션 대신 인터페이스를 이용하라
* 핵심 리플렉션 기능을 이용하면 메모리에 적재된 클래스의 정보를 가져오는 프로그램을 작성할 수 있다
* 리플렉션을 이용하면, 소스 코드가 컴파일 될 당시에는 존재하지도 않았던 클래스를 이용할 수 있다 
* 하지만 컴파일 시점에 자료형을 검사함으로써 얻을 수 있는 이점들을 포기해야 한다 ( 리플렉션을 통해 존재하지 않는, 또는 접근 할 수 없는 메서드를 호출하면 실행 도중에 오류가 발생 )
* 리플렉션 기능을 이용하는 코드는 보기 싫은데다 장황하다
* 성능이 낮다, 리플렉션을 통한 메서드 호출 성능은, 일반적인 메서드 호출에 비해 훨씬 낮다
* 일반적인 프로그램은 프로그램 실행 중에 리플렉션을 통해 객체를 이용하려 하면 안 된다는 것
* 리플렉션을 아주 제한적으로만 사용하면 오버헤드(어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다)는 피하면서도 리플렉션의 다양한 장점을 누릴 수 있다
* 리플렉션은 실행시점에 존재하지 않는 클래스나 메서드 필드에 대한 종속성을 관리하는데 적합
* 리플렉션은 특정한 종류의 복잡한 시스템 프로그래밍에 필요한, 강력한 도구 하지만 단점이 많으므로 컴파일 시점에는 알 수 없는 클래스를 이용하는 프로그램을 작성하고 있다면, 리플렉션을 사용하되 가능하면 객체를 만들 때만 이용하고, 객체를 참조할 때는 컴파일 시에 알고 있는 인터페이스나 상위 클래스를 이용하라

### 네이티브 메서드는 신중하게 사용하라
* 자바의 네이티브 인터페이스는 C나 C++ 등의 네이티브 프로그래밍 언어로 작성된 네이티브 메서드를 호출하는 데 이용되는 기능
* 네이티브 메서드를 사용하면 레지스트리(registry)나 파일 락 같은 특정 플랫폼에 고유한 기능을 이용할 수 있다, 또한 이미 구현되어 있는 라이브러리를 이용할 수 있으며 , 그 라이브러리를 통해 기존 데이터를 활용할 수 있다, 네이티브 메서드를 사용하면 성능이 중요한 부분의 처리를 네이티브 언어에 맡길 수 있다
* 하지만 네이티브 메서드를 통해 성능을 개선하는 것은 추천하고 싶지 않다

### 신중하게 최적화하라
* 빠른 프로그램이 아닌, 좋은 프로그램(정보 은닉 원칙을 잘 지킨 프로그램)을 만들려 노력하라
* 설계를 할 때는 성능을 제약할 가능성이 있는 결정들은 피하라
* API를 설계할 때 내리는 결정들이 성능에 어떤 영향을 끼칠지를 생각하라

### 일반적으로 통용되는 작명 관습을 따라라
* 패키지 이름은 마침표를 구분점으로 사용하는 계층적 이름이어야 한다, 패키지 이름을 구성하는 각각의 컴포넌트는 알파벳 소문자로 구성하고, 숫자는 거의 사용하지 않는다, 패키지 이름의 나머지 부분은 어떤 패키지인지 설명하는 하나 이상의 컴포넌트로 구성, 패키지명 가운데 상당수는 인터넷 도메인 이름 이외에 단 하나의 컴포넌트만 사용
* enum이나 어노테이션 자료형 이름을 비롯, 클래스나 인터페이스 이름은 하나 이상의 단어로 구성, 각 단어의 첫 글자는 대문자
* 메서드와 필드 이름은 클래스나 인터페이스 이름과 동일한 철자 규칙을 따른다, 다만 첫 글자는 소문자
* 상수 필드의 이름을 지을 때는 상수 필드의 이름은 하나 이상의 대문자 단어로 구성, 단어 사이에는 밑줄 기호(_)를 둔다
* 지역 변수 이름은 멤버 이름과 같은 철자 규칙을 따른다(약어가 허용)

* 패키지 = com.google.inject, org.joda.time.format
* 클래스나 인터페이스 = Timer, FutureTask, LinkedHashMap, HttpServlet
* 메서드나 필드 = Remove, ensureCapacity, getCrc
* 상수 필드 = MIN_VALUE, NEGATIVE_INFINITY
* 지역 변수 = i, xref, houseNumber
* 자료형 인자 = T, E, K, V, X, T1, T2

