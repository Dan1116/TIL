# 이펙티브 자바_2
### 유효기간이 지난 객체 참조는 폐기
* 쓸 일 없는 개체 참조는 무조건 null로 만들어야 한다, Stack 클래스의 경우, 스택에서 pop된 객체에 대한 참조는 그 즉시 null로 만들면 된다
* 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의
* cache도 메모리 누수가 흔히 발생하는 장소 -> 첫 번째 해결책은 WeakHashMap을 가지고 캐시를 구현하는 것 (캐시 바깥에서 키를 참조하고 있을 때만 값을 보관하면 될 때 쓸 수 있는 전략)
* 메모리 누수가 흔히 발견되는 또 한 곳은 리스너 등의 역호출자 -> API 를 사용하는 클라이언트가 역호출자를 명시적으로 제거하지 않을 경우, 적절한 조치를 취하기 전까지 메모리는 점유된 상태로 남아있게 된다

### 종료자 사용을 피해라
* 종료자(finalizer) 는 예측 불가능하며, 대체로 위험하고 일반적으로 불필요하다, 종료자의 한 가지 단점은 즉시 실행되리라는 보장이 전혀 없다는 것이다 (따라서 긴급한 작업을 종료자 안에서 처리하면 안 된다)
* 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다 -> 명시적인 종료 메서드 ( termination method ) 를 하나 정의하고 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메서들르 호출하도록 -> OutputStream, InputStream, java.sql.Connection에 정의된 close 메서드
* 이런 명시적 종료 메서드는 try-finally 문과 함께 쓰인다
* 하위 클래스에서 상위 클래스 종료자를 재정의 (override) 하면서 상위 클래스 종료자 호출을 잊으면, 상위 클래스 종료자는 절대로 호출되지 않는다. 이런 멍청한 하위 클래스 덕에 생기는 문제를 방지하는 한 가지 방법은, 종료되어야 하는 모든 객체마다 여벌의 객체를 하나 더 만드는 것이다. 종료되어야 하는 객체의 클래스 안에 종료자를 정의하는 대신, 익명 클래스 (anonymous class) 안에 종료자를 정의하는 것 

## 3장 -  모든 객체의 공통 메서드
* Object는 객체 생성이 가능한 클래스이긴 하지만 기본적으로는 계승해서 사용하도록 설계된 클래스

###  equals를 재정의할 때는 일반 규약을 따르라
* equals 메서드는 재정의하기 쉬워 보이지만 실수할 여지가 많다 -> 각각의 객체가 고유하다, 값 대신 활성 개체 (active entity)를 나타내는 Thread 같은 클래스가 이 조건에 부합
* 클래스에 논리적 동일성 (logical equality) 검사 방법이 있건 없건 상관없다 -> Object에서 계승한 equals만으로 충분
* 클래스가 private 또는 package-private 로 선언되었고, equals 메서드를 호출할 일이 없다 -> 반드시 equals를 재정의해야 한다, 실수로 equals를 호출 할 수도 있기 때문
* equals 메서드를 정의할 때 준수해야 하는 일반 규약 -> Object 클래스 명세에서 복사한 것, equals 메서드는 동치 관계 (equivalence relation)을 구현 
* 동치 관계 : 
* 반사성 (reflexive) -> null이 아닌 참조 x 가 있을 때, x.equals(x)는 true를 반환 -> 모든 객체는 자기 자신과 같아야 한다
* 대칭성 (symmetric) -> null 아닌 참조 x 와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환 -> equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다 (이 문제를 방지하려면, CaseInsensitiveString의 equals 메서드가 String 객체와 상호작용하지 않도록 해야 한다)
* 추이성 (transitive) -> null 아닌 참조 x,y,z가 있을 때 x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true 이다 -> 
* 일관성 (consistent) -> null 아닌 참조 x와  y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다
* null 아닌 참조 x 에 대해서, x.equals(null)은 항상 false이다



