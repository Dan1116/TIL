# 이펙티브자바_5
### 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라
* 재정의 가능 메서드를 내부적으로 어떻게 사용하는지 반드시 문서에 남겨야 한다 ( 재정의가 가능하다는 것은(overridable) public, protected로 선언된 비-final 메서드라는 뜻)
* 클래스 내부 동작에 개입할 수 있는 훅(hook)을 신중하게 고른 protected 메서드 형태로 제공해야 한다
* 계승을 위해 설계한 클래스를 테스트할 유일한 방법은 하위 클래스를 직접 만들어 보는 것이다
* 계승을 허용하려면 반드시 따라야 할 제약사항이 있다 -> 생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안 된다는 것
* clone이나 readObject메서드 안에서 직접적이건 간접적이건 재정의 가능한 메서드를 호출하지 않도록 주의
* 계승을 위해 클래스를 설계하면 클래스에 상당한 제약이 가해진다
* 계승에 맞도록 설계하고 문서화하지 않은 클래스에 대한 하위 클래스는 만들지 않아야 한다
* 하위 클래스 생성을 금지 하는 방법 -> 클래스를 final 선언

### 추상 클래스 대신 인터페이스를 사용하라
* 여러 가지 구현을 허용하는 자료형을 만드는 방법 -> 인터페이스와 추상 클래스
* 추상 클래스는 구현된 메서드를 포함할 수 있지만, 인터페이스는 아니다
* 추상 클래스가 규정하는 자료형을 구현하기 위해서는 추상 클래스를 반드시 계승해야 한다
* 이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다
* 인터페이스는 믹스인(mixin)을 정의하는데 이상적
* 추상 클래스는 믹스인 정의에는 사용할 수 없다
* 인터페이스는 비 계층적인(nonhierarchical) 자료형 프레임워크를 만들 수 있도록 한다
* 인터페이스를 사용하면 포장 클래스 숙어를 통해 안전하면서도 강력한 기능 개선이 가능
* 추상 클래스를 사용해 자료형을 정의하면 프로그래머는 계승 이외의 수단을 사용할 수 없다
* 추상 골격 구현( abstract skeletal implementation) 클래스를 중요 인터페이스마다 두면, 인터페이스의 장점과 추상 클래스의 장점을 결합할 수 있다
* 골격 구현 클래스는 계승 용도로 설계하는 클래스
* 인터페이스 보다는 추상 클래스가 발전시키기 쉽다
* 인터페이스가 공개되고 널리 구현된 다음에는, 인터페이스 수정이 거의 불가능
* 인터페이스는 다양한 구현이 가능한 자료형을 정의하는 일반적으로 가장 좋은 방법

### 인터페이스는 자료형을 정의할 때만 사용하라
* 인터페이스를 구현하는 클래스를 만들게 되면, 그 인터페이스는 해당 클래스의 객체를 참조할 수 잇는 자료형 역할을 하게 된다
* 상수 인터페이스 ( constant interface) = 메서드가 없고, stack final 필드만 있다
* 상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다
* 인터페이스는 자료형을 정의할 때만 사용해야 한다, 특정 상수를 API의 일부로 공개할 목적으로는 적절치 않다

### 태그 달린 클래스 대신 클래스 계층을 활용하라
* 태그 기반 클래스는 너저분한데다 오류 발생 가능성이 높고, 효율적이지도 않다
* 클래스 계층을 통해 태그를 제거할 방법이 없는지 생각해 보고 리팩터링( refectoring)을 통해 클래스 계층으로 변환할 방법은 없는지 고민해야 한다

### 전략을 표현하고 싶을 때는 함수 객체를 사용
* 특정 함수를 호출할 수 있는 능력을 저장하고 전달할 수 있도록 하는 것 = 함수의 인자로 함수를 전달하기 위해 널리 사용, 이때 인자로 전달되는 함수는 호출된 함수의 기능을 변경하는 구실을 한다
* 전략 인터페이스는 실행 가능 전략 객체들의 자료형 구실을 한다 ( 따라서 실행 가능 전략 클래스는 굳이 public으로 만들어 공개할 필요가 없다)
* 전략 인터페이스가 자료형인 public static 필드들을 갖는 호스트 클래스를 정의하는 것도 방법
* 함수 객체의 주된 용도는 전략 패턴을 구현하는 것 -> 전략을 표현하는 인터페이스를 선언하고, 실행 가능 전략 클래스가 전부 해당 인터페이스를 구현하도록 해야한다

### 멤버 클래스는 가능하면 static 으로 선언
* 중첩 클래스는 (nested class) 다른 클래스 안에 정의된 클래스다
* 중첩 클래스의 4가지 종류 -> 정적 멤버 클래스 , 비 정적 멤버 클래스 , 익명 클래스, 지역 클래스
* 정적 멤버 클래스 빼고는 전부 내부 클래스 (inner class)
* 정적 멤버 클래스는 바깥 클래스의 모든 멤버에( private로 선언된 것들도 ) 접근 가능
* 정적 멤버 클래스를 private로 선언했다면 해당 중첩 클래스에 접근할 수 있는 것은 바깥 클래스 뿐이다
* 비 정적 멤버 클래스 객체는 바깥 클래스 객체와 자동적으로 연결
* 비 정적 멤버 클래스 안에서는 바깥 클래스의 메서드를 호출할 수 있고, this 한정(qualified this)구문을 통해 바깥 객체에 대한 참조를 획득할 수 있다
* 비 정적 멤버 클래스는 바깥 클래스 객체 없이는 존재할 수 없다
* 비 정적 멤버 클래스 객체와 바깥 객체와의 연결은 비 정적 멤버 클래스의 객체가 만들어지는 순간에 확립, 그 뒤에는 변경 할 수 없다
* 비 정적 멤버 클래스는 어댑터를 정의할 때 많이 쓰인다
* 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 때는 항상 선언문 앞에 static 을 붙여서 비 정적 멤버 클래스 대신 정적 멤버 클래스로 만들자
* private 정적 멤버 클래스는 바깥 클래스 객체의 컴포넌트를 표현하는데 많이 쓰인다
* 익명 클래스 = 멤버로 선언하지 않으며, 사용하는 순간에 선언하고 객체를 만든다, 비정적 문맥(nonstatic context) 안에서 사용될 때만 바깥 객체를 갖는다, 하지만 안에서 사용된다 해도 static 멤버를 가질 수는 없다
* 익명 클래스는 선언하는 그 순간에만 객체를 만들 수 있고, instanceof, 클래스 이름이 필요한 곳에는 사용할 수 없다
* 익명 클래스의 클라이언트는 상위 자료형에서 상속된 멤버만 호출할 수 있다
* 익명 클래스는 함수객체를 정의할 때 쓰인다
* 지역 클래스는 지역 변수가 선언될 수 있는 곳이라면 어디서든 선언 할 수 있으며 지역 변수와 동일한 유효범위 규칙을 따른다. 
* 지역 클래스는 멤버 클래스처럼 이름을 가지며, 반복적으로 사용될 수 있다, 익명 클래스처럼 비 정적 문맥에서 정의했을 때만 바깥 객체를 갖는다, static 멤버는 가질 수 없다

## 제네릭
* 형변환 = cast
* 제네릭을 사용하면 컬렉션에 넣는 객체의 자료형이 무엇인지 컴파일러에게 알릴 수 있다

### 새 코드에는 무인자 제네릭 자료형을 사용하지 말아라
* 선언부에 형인자 (type parameter)가 포함된 클래스나 인터페이스는 제네릭 클래스나 인터페이스라고 부른다
* 제네릭 클래스와 인터페이스는 제네릭 자료형이라 부른다
* 각 제네릭 자료형은 형인자 자료형(parameterized type) 집합을 정의 또한 새로운 무인자 (raw type) 자료형을 정의 ( 무인자 자료형은 실 형인자가 없이 시용되는 제네릭 자료형)
* 형인자 자료형을 쓰면 컬렉션에서 원소를 꺼낼 때 형변환을 하지 않아도 된다
* 무인자 자료형을 쓰면 형 안전성이 사라지고, 제네릭의 장점 중 하나인 표현력 측면에서 손해를 보게 된다
* 무인자 자료형을 인자로 받는 메서드에 형인자 자료형 객체를 전달 할 수도 있어야 했고 그 반대도 가능해야해서 무인자 자료형을 지원하게 된 것
* 클래스 리터럴( class literal) 에는 반드시 무인자 자료형을 사용해야 한다
* 제네릭 자료형 정보는 프로그램이 실행될 때는 지워지기 때문에, instanceof 연산자는 비한정적 와일드카드 자료형 이외의 형인자 자료형에 적용할 수 없다

### 무점검 경고(unchecked warning) 를 제거하라
* 모든 무점검 경고는, 가능하다면 없애야 한다 (프로그램 실행 도중에 ClassCastExceptiopn이 발생할 가능성)
* 제거할 수 없는 경고 메세지는 형 안전성이 확실할 때만 Supress Warnings 어노테이션을 사용해 억제하기 바란다
* Suppress Warnings 어노테이션은 가능한 한 작은 범위에 적용하라
* @Suppress Warnings 어노테이션을 사용할 때마다, 왜 형 안전성을 위반하지 않는지 밝히는 주석을 반드시 붙여라

### 배열 대신 리스트를 써라
* 배열은 공변 자료형(covariant), 실제화 (reification) 이 되는 자료형 -> 배열의 각 원소의 자료형은 실행시간에 결정
* 제네릭은 불변 자료형(invariant), 실행 시간에 형인자 정보는 삭제  -> 자료형에 관계된 조건들을 컴파일 시점에만 적용, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다는 것

### 가능하면 제네릭 자료형으로 만들 것
* 클래스를 제네릭화하는 첫 번째 단계는 선언부에 형인자를 추가하는 것
* 다음 단계는 Object를 자료형으로 사용하는 부분들을 전부 찾아서, 형인자로 대체하고 컴파일
* 제네릭 자료형은 클라이언트가 형변환을 해야만 사용할 수 있는 자료형보다 안전할 뿐 아니라 사용하기도 쉽다, 새로운 자료형을 설계할 때는 형변환 없이도 사용할 수 있도록 하라

### 가능하면 제네릭 메서드로 만들 것
* 제네릭화로 혜택을 보는 것은 클래스뿐만 아니라 메서드도 혜택을 본다
* 형인자를 선언하는 형인자 목록은 메서드의 수정자와 반환값 자료형 사이에 둔다
* 제네릭 생성자를 호출할 때는 명시적으로 주어야 했던 형인자를 전달할 필요가 없다는 것
* 제네릭 메서드를 호출할 때 자료형이 유추되는 것을 이용하면, 형인자 자료형 객체를 좀 더 쉽게 생성할 수 있다
* 제네릭 정적 팩터리 메서드를 사용하면 중복되는 형인자를 제거하여 간결한 코드를 만들 수 있다
* 재귀적 자료형 한정 = 형인자가 포함된 표현식으로 형인자를 한정하는 것도 가능 (자료형의 자연적 순서를 정의하는 Comparable 인터페이스와 함께 쓰인다)
* 제네릭 자료형이나 마찬가지로 제네릭 메서드는 클라이언트가 직접 입력 값과 반환값의 자료형을 형변환해야 하는 메서드보다 사용하기 쉽고 형 안전성도 높다

### 한정적 와일드카드를 써서 API 유연성을 높여라
* 형인자 자료형은 불변 자료형
* 반환값에는 와일드카드 자료형을 쓰면 안 된다
* 형인자가 메서드 선언에 단 한군데 나타난다면 해당 인자를 와일드카드로 바꾸라는 것이다
* 와일드다르 자료형을 사용하면 API의 유연성은 높아진다
* 생산자는 extends, 소비자는 super
* 모든 Comparable과 Comparator는 소비자

### 형 안전 다형성 컨테이너 사용하기
* 형 안정성을 깨지 않으면서 각 열에 접근할 수 있는 방법은 컨테이너 대신 키에 형인자를 지정하는 것이다
* 자료형 토큰 = 컴파일 시간 자료형이나 실행시간 자료형 정보를 메서드들에 전달할 목적으로 class 리터럴을 이용하는 경우
* cast 메서드는 자바의 형변환 연산자의 동적 버전이다
* 포장 객체를 만드는 정적 팩터리 메서드는 컬렉션과 Class 객체 하나(맵인 경우 두 개)를 인자로 받는다
* 정적 메서드들은 제네릭 메서드로서, Class 객체의 컴파일 시간 자료형이 컬렉션 자료형과 일치하도록 보장한다
* 인자 annotation TYPE 은 어노테이션 자료형을 나타내는 한 정적 자료형 토큰 -> 이 메서드는 리플렉션 객체에 붙은 어노테이션 가운데서 주어진 자료형에 해당하는 어노테이션을 반환한다 ( 어노테이션이 없을 때는 null을 반환)
* 컬렉션 API를 통해 확인할 수 있는 제네릭의 일반 용법에 따르면, 컨테이너 별로 형인자 개수는 고정, 그런데 컨테이너 대신 키를 제네릭으로 만들면 그런 제약이 없는 형 안전 다형성 컨테이너를 만들 수 있다 -> 그런 컨테이너는 Class 객체를 키로 쓰는데, 이런 Class 객체를 자료형 토큰이라 부른다