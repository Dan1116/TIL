# 이펙티브 자바
## 제 1장 - 서론
*  이 책에서 모듈은 재사용 가능한 컴포넌트를 지칭, 개별 메서드뿐 아니라 여러 패키지로 구성된 복잡한 시스템
* 코드는 복사하는게 아니라 재사용해야 한다, 모듈 간 의존성은 가능한 줄여야 한다
* 자바는 4가지 자료형 = 인터페이스(interface, annotation 포함), 클래스( class, enum포함) , 배열 (array) , 기본 자료형 (primitive) 
* 클래스 멤버 = 필드, 메서드, 멤버 클래스, 멤버 인터페이스
* 어떤 패키지의 공개 API는 패키지에 포함되는 모든 public 클래스와 인터페이스의 public/protected 멤버와 생서자다

## 2장 - 객체의 생성과 삭제
* API = Application Programming Interface, 응용 프로그래밍 인터페이스, 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 
있도록 만든 인터페이스

### 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보기
* 클래스를 통해 객체를 만드는 일반적인 방법은 public으로 선언된 생성자를 이용
* 클래스에 public으로 선언된 정적 팩터리 메서드를 추가하는 방법도 알아야한다 -> 이 방법을 사용했을 시 첫번째 장점으로는 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다는 것
* 생성자에 전달되는 인자(paratmeter) 들은 어떤 객체가 생성되는지를 설명하지 못하지만, 정적 팩터리 메서드는 이름을 잘 짓기만 한다면 클라이언트 코드의 가독성(readability) 도 높아진다
* 두번째 장점으로는 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다는 것
* 정적 팩터리 메서드는 사용하면 같은 객체를 반복해서 반환 할 수 있다
* 세 번째 장점은, 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환 할 수 있다
* public으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다
* 서비스 제공자 프레임워크는 세가지 핵심 컴포넌트로 구성 -> 서비스 인터페이스 (서비스 제공자가 구현), 제공자 등록 API (구현체를 시스템에 등혹하여 클라이언트가 쓸 수 있도록  구현) , 서비스 접근 API (클라이언트에세 실제 서비스 구현체를 제공)
* 정적 팩터리 메서드의 네번째 장점은 , 형인자 자료형(parameterized type) 객체를 만들 때 편하다는 점

* 정적 팩터리 메서드만 있는 클래스를 만들면 생기는 가장 큰 문제는, public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다
* 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는 다는 단점이 있다


* valueOf: 인자로 주어진 값과 같은 값을 갖는 객체를 반환한다는 뜻 (형변환 메서드) 더 간단하게 쓴다면 , of로 쓸 수 있다
* getInstance : 인자에 기술된 객체를 반환, 하지만 인자와 같은 값을 갖지 않을 수도 있다(싱글턴 패턴을 따를 경우, 이 메서드는 인자 없이 항상 같은 객체를 반환)
* newInstance: getInstance와 같지만, 호출할 때마다 다른 객체를 반환
* getTYPE: getInstance와 같지만 반환될 객체의 클래스와 다른 클래스에 팩터리 메서드가 있을 때 사용, TYPE은 팩터리 메서드가 반환할 객체의 자료형이다
* newTYPE: newInstance와 같지만, 반환될 객체의  클래스와 다른 클래스에 팩터리 메서드가 있을 때 사용, TYPE은 팩터리 메서드가 반환할 객체의 자료형이다

### 생성자 인자가 많을 때는 Builder 패턴 적용을 고려
* 점층적 생성자 패턴은 인자 수가 늘어나면 클라이언트 코드를 작성하기가 어려워진다
* 자바빈 패턴 = 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정 메서드들을 호출하여 필수 필드뿐 아니라 선택적 필드의 값들까지 체울 수 있다 => 하지만, 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성(consistency)이 일시적으로 깨질 수 있다, 또한 자바빈 패턴으로는 변경 불가능한 클래스를 만들 수 없다는 것이다
* 빌더 패턴 = 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달, 빌더 객체를 만든다, 그 후 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다, 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만든다 (빌더 클래스는 빌더가 만드는 객체 클래스의 정적 멤버 클래스로 정의)
* 생성자와 마찬가지로, 빌더 패턴을 사용하면 인자에 불변식을 적용할 수 있다, build 메서드 안에서 해당 불변식이 위반되었는지 검사할 수 있는 것이다(빌더 객체에서 실제 객체로 인자가 복사된 다음에 불변식들을 검사할 수 잇다는 것, 그리고 그 불변식을 빌더 객체의 필드가 아니라 실제 객체의 필드를 두고 검사할 수 잇다는 것이 중요)
* 여러 인자에 관련된 불변식을 강제하는 또 한 가지 방법은 불변식이 적용될 값 전부를 인자로 받는 설정자 메서드를 정의하는 것 (이 설정 메서드는 불변식이 만족되지 않으면 IllegalArgumentException을 던져야 한다)
* 빌더 패턴은 빌더 객체는 여러개의 varargs 인자를 받을 수 있고, 하나의 객체로 여러 객체를 만들 수 있다
* Class.newInstance는 컴파일 시점에 예외 검사가 가능해야 한다는 규칙을  깨트린다
* 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유용

### private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해야 한다
*  싱글턴 = 객체를 하나만 만들 수 잇는 클래스 (클래스를 싱글턴으로 만들면 클라이언트를 테스트하기 어려워 질 수 있다)
* 싱글턴 클래스를 직렬화 가능 클래스로 만들려면 모든 필드를 transient로 선언하고 readResolve 메서드를 추가해야 한다 (그렇지 않으면 serialize된 객체가 역직렬화deserialize 될 때마다 새로운 객체가 생성)
* 원소가 하나뿐인 enum 자료형이 싱글턴을 구한하는 가장 좋은 방법

### 객체 생성을 막을 때는 private 생성자를 사용
* 객체를 만들 수 없도록 하려고 클래스를 abstarct로 선언해 봤자 소용없다
* 기본 생성자는 클래스에 생성자가 없을 때 만들어지니까, private 생성자를 클래스에 넣어서 객체 생성을 방지할 수 있다 (하위 클래스도 만들 수 없다)

### 불필요한 객체는 만들지 말아라
* 동일한 객체를 필요할 때 만드는 것보다 재사용하는 편이 좋다 (변경 불가능 객체는 언제나 재사용 할 수 있다)
* 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않도록 유의해야 한다




