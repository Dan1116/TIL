# EFFECTIVE JAVA_6
# 람다와 스트림
* 자바 8에서 함수형 인터페이스, 람다, 메서드 참조라는 개념이 추가되면서 함수 객체를 더 쉽게 만들 수 있게 되었다
* 이와 함께 스트림 API까지 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하기 시작했다

## 익명 클래스보다는 람다를 사용하라
* 지금은 함수형 인터페이스라 부르는 이 인터페이스들의 인스턴스를 람다식(lambda expression, 혹은 짧게 람다)을 사용해 만들 수 있게 된 것이다
* 람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다
* 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하는게 좋다 (컴파일러가 타입을 알 수 없다는 오류를 낼 때만 해당 타입을 명시 하면 된다)
* 메서드나 클래스와 달리 람다는 이름이 없고 문서화도 못 한다, 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다
* 람다는 한 줄 일때가 가장 좋고, 길어야 세 줄 안에 끝내는 게 좋다
* 람다는 함수형 인터페이스에서만 쓰인다, 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니 익명 클래스를 써야 한다
* 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다
* 람다는 자신을 참조 할 수 없다, 람다에서의 this 키워드는 바깥 인스턴스를 가리킨다, 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다
* 람다를 직렬화하는 일은 극히 삼가야 한다(익명 클래스의 인스턴스도 마찬가지)
* 직렬화해야만 하는 함수 객체가 있다면 private 정적 중첩 클래스의 인스턴스를 사용해야한다

## 람다보다는 메서드 참조를 사용하라
* 람다가 익명 클래스보다 좋은 점 중에서 가장 큰 특징은 간결함 이다
* 람다보다 더 간결하게 만들 수 있는 건 메서드 참조(method reference) 이다
* merge 메서드는 키, 값, 함수를 인수로 받으며, 주어진 키가 맵 안에 아직 없다면 주어진 쌍을 그대로 저장한다 (반대로 키가 이미 있다면 (세 번째 인수로 받은) 함수를 현재 값과 주어진 값에 적용한 다음, 그 결과로 현재 값을 덮어쓴다)
* 때론 람다가 메서드 참조보다 간결할 때가 있다, 주로 메서드와 람다가 같은 클래스에 있을 때 그렇다
* 메서드 참조의 유형은 다섯 가지로, 가장 흔한 유형은 정적 메서드를 가리키는 메서드 참조이다
* 인스턴스 메서드를 참조하는 유형이 두 가지 있다, 그 중 하나는 수신 객체(receiving object 참조 대상 인스턴스)를 특정하는 한정적(bound) 인스턴스 메서드 참조이고, 다른 하나는 수신 객체를 특정하지 않는 비한정적(unbound) 인스턴스 메서드 참조이다
* 한정적 참조는 근본적으로 정적 참조와 비슷하고, 즉 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 똑같다
* 비한정적 참조에서는 함수 객체를 적용하는 시점에 수신 객체를 알려준다, 이를 위해 수신 객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따른다, 비한정적 참조는 주로 스트림 파이프 라인에서의 맵핑과 필터 함수에 쓰인다
* 클래스 생성자를 가리키는 메서드 참조와 배열 생성자를 가리키는 메서드 참조가 있다, 생성자 참조는 팩터리 객체로 사용한다

## 표준 함수형 인터페이스를 사용하라
* 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라 (API가 다루는 개념의 수가 줄어들어 익히기 더 쉬워진다), 또한 표준 함수형 인터페이스들은 유용한 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호 운용성도 좋아질 것이다
* 변형들 중 유일하게 Function의 변형만 매개변수화 됐다 (정확히는 반환 타입만 매개변수화 됐다)
* 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하면 안 된다
* 전용 함수형 인터페이스를 작성하기로 했다면, 자신이 작성하는 게 다른 것도 아닌 인터페이스임을 명심해야 한다
* 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용해야한다
* @FunctionalInterface = 해당 클래스의 코드나 설명 문서를 읽을 사람에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다, 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다, 그 결과 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다
* 함수형 인터페이스를 API에서 사용할 때의, 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안 된다

## 스트림은 주의해서 사용하라
* 스트림 API가 제공하는 추상 개념 중 핵심은 두 가지 -> 스트림은 데이터 원소로의 유한 혹은 무한 시퀀스(sequence)를 뜻한다, 두 번째인 스트림 파이프라인은 원소들로 수행하는 연산 단계를 표현하는 개념이다
* 스트림의 원소들은 어디로부터든 올 수 있다, 대표적으로는 컬렉션, 배열, 파일, 정규표현식 패턴 매치, 난수 생성기, 혹은 다른 스트림, 스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값이다 (int, long, double)
* 스트림 파이프라인은 소스 스트림에서 시작해 종단 연산(terminal operation)으로 끝나며, 그 사이에 하나 이상의 중간 연산(intermediate operation)이 있을 수 있다
* 각 중간 연산은 스트림을 어떠한 방식으로든지 변환한다 (각 원소에 함수를 적용하거나 특정 조건을 만족 못하는 원소를 거를 수 있다)
* 중간 연산들은 모두 한 스트림을 다른 스트림으로 변환하는데, 변환된 스트림의 원소 타입은 변환 전 스트림의 원소 타입과 같을 수도 있고 다를 수도 있다
* 종단 연산은 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다, 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력하는 식이다
* 스트림 파이프라인은 지연 평가 된다, 평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다, 이러한 지연 평가가 무한 스트림을 다룰 수 있게 해주는 열쇠다, 종단 연산이 없는 스트림 파이프라인은 아무 일도 하지 않는 명령어인 no-op와 같으니 종단 연산을 빼먹는 일은 없어야 한다
* 스트림 API는 메서드 연쇄를 지원하는 플루언트(fluent)  API이다, 즉 파이프라인 하나를 구성하는 모든 호출을 연결하여 단 하나의 표현식으로 완성할 수 있다 (파이프라인 여러 개를 연결해 표현식 하나로 만들 수도 있다)
* 기본적으로 스트림 파이프라인은 순차적으로 수행한다, 파이프라인을 병렬로 실행하려면, 파이프라인을 구성하는 스트림 중 하나에서 parallel 메서드를 호출해주기만 하면 되지만, 효과를 볼 수 있는 상황은 많지 않다
* 스트림 API는 다재다능하여 사실상 어떠한 계산이라도 해낼 수 있다, 하지만 잘못 사용하면 읽기 어렵고 유지보수도 힘들다
* 람다에서는 타입 이름을 자주 생략하므로 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다
* 도우미 메서드를 적절히 활용하는 일의 중요성은 일반 반복 코드에서보다 스트림 파이프라인에서 훨씬 크다
* char 값들을 처리할 때는 스트림을 삼가는 편이 좋다
* 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 좋아 보일 때만 반영하는게 좋다
* 원소들의 시퀀스를 일관되게 변환한다, 원소들의 시퀀스를 필터링한다, 원소들의 시퀀스를 하나의 연산을 사용해서 결합한다(더하기, 연결하기, 최소 값 구하기), 원소들의 시퀀스를 컬렉션에 모은다, 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다 -> 스트림이 적합하게 사용 될 수 있는 환경들이다

## 스트림에서는 부작용 없는 함수를 사용하라
* 스트림은 또 하나의 API가 아닌, 함수형 프로그래밍에 기초한 패러다임이다
* foreach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 곳 에는 사용하지 않는 편이 좋다
* 스트림 수집기의 역할은 해당 카테고리의 모든 원소를 담은 스트림으로부터 값을 생성하는 일이다
* toList, toSet, toMap, groupingBy, joining

## 반환 타입으로는 스트림보다 컬렉션이 낫다
* 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위 타입을 쓰는 게 일반적으로 좋다
* 단지 컬렉션을 반환한다는 이유로 덩치 큰 시퀀스를 메모리에 올려서는 안 된다
* AbstractCollection을 활용해서 Collection 구현체를 작성할 때는 Iterable용 메서드 외에 2개만 더 구현하면 된다, 바로 contains와 size 다
* 원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하기를 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있으므로 그것들을 떠올리고 양쪽을 다 만족시키려 노력하는게 좋다 (컬렉션을 반환할 수 있으면 그렇게 하자)
* 컬렉션을 반환하는 게 불가능하다면, 스트림과 Iterable 중 더 자연스러운 것을 반환하는게 좋다

## 스트림 병렬화는 주의해서 적용하라
* 환경이 아무리 좋더라도 데이터 소스가 Stream.iterate이거나 중간 연산으로 limit을 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다
* 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다 -> 이 자료구조들의 또 다른 중요한 공통점은 원소들을 순차적으로 실행할 때의 참조 지역성 (locality of reference)이 뛰어나다는 것이다
* 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 대부분 시간을 멍하니 보내게 된다
* 기본 타입의 배열이 참조 지역성이 가장 뛰어나다 (데이터 자체가 메모리에 연속해서 저장되기 때문이다)
* 스트림 파이프라인의 종단 연산의 동작 방식 역시 병렬 수행 효율에 영향을 준다, 종단 연산에서 수행하는 작업량이 파이프라인 전체 작업에서 많은 비중을 차지하면 순차적인 연산이라면 파이프라인 병렬 수행의 효과는 제한 될 수 밖에 없다
* 종단 연산 중 병렬화에 가장 적합한 것은 축소이다(reduction)
* 스트림을 잘못 병렬화하면 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상하지 못한 것들이 발생할 수 있다
* 조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 느낄 수 있다