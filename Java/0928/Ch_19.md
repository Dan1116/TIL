# Ch_19
### JVM 운영체제
* 운영체제가 JVM을 포함해서 모든 응용 프로그램에게 동일한 크기의 메모리 공간을 할당 할 수 있는 가상 메모리 기술에서 찾을 수 있다
* JVM은 운영체제로부터 할당받은 메모리 공간을 기반으로 자바 프로그램을 실행해야 한다

### 메소드 영역 (method area) -> 메소드의 바이트코드, static 변수
* 바이트코드: 자바 가상머신의 의해서 실행되는 코드
* 메소드의 자바 바이트코드는 JVM이 구분하는 메모리 공간 중에서 메소드 영영에 저장된다
* static으로 선언된 클래스 변수도 메소드 영역에 저장
* 클래스의 정보가 JVM의 메모리 공간에 Load 될 때 할당 및 초기화되는 대상은 메소드 영역에 할당

### 스택 영역 (stack area) -> 지역변수, 매개변수
* 매개변수, 지역변수가 할당되는 메모리 공간
* 프로그램이 실행되는 도중에 임시로 할당되었다가 바로 이어서 소멸되는 특징이 있는 변수가 할당
* 메소드의 실행을 위한 메모리 공간으로도 정의 가능

### 힙 영역(heap area) -> 인스턴스
* 인스턴스가 생성되는 메모리 공간
* JVM에 의한 메모리 공간의 정리(garbage collection)가 이뤄지는 공간
* 할당은 프로그래머가 소멸은 JVM
* 참조변수에 의한 참조가 전혀 이뤄지지 않는 인스턴스가 소멸의 대상 (JVM이 알아서)
* 메소드 내에서 인스턴스를 생성한다면 참조변수는 스택에 인스턴스는 힙에 저장

## object 클래스
* finalize 메소드 -> 인스턴스 소멸 시 호출되는 메소드 (완전히 소멸되기 직전 자동으로 호출되는 메소드), finalize 메소드는 호출되지 않을 수 있다, Garbage Collection이 실행되는 시기와 인스턴스의 완전한 소멸의 시기에는 차이가 날 수 있으므로
* GC -> 한 번도 발생하지 않을 수 있다, 발생하면, 소멸의 대상이 되는 인스턴스는 결정되지만 이것이 실제 소멸로 바로 이어지지는 않는다, 인스턴스의 실제 소멸로 이어지지 않은 상태에서 프로그램이 종료될 수도 있다( 종료되면 어차피 인스턴스는 소멸 되니까)
* 꼭 finalize 메소드가 반드시 호출되기를 원한다면 -> 
```
System.gc();
System.runFinalization();
```
* 대상 메소드에 대한 정보가 부족한 경우에는 오버라이딩 된 메소드도 호출이 되도록 오버라이딩을 해야 한다

* equals 메소드 -> 인스턴스간의 내용 비교를 목적으로 사용, 따라서 새로 정의되는 클래스의 내용 비교가 가능하도록 이 메소드를 오버라이딩 하는 것이 좋다