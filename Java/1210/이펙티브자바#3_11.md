#  이펙티브자바#3_11
## 동시성
* 스레드는 여러 활동을 동시에 수행할 수 있게 해준다 (하지만 동시성 프로그래밍은 단일 스레드 프로그래밍보다 어렵다)

### 공유 중인 가변 데이터는 동기화해서 사용하라
* synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드 씩 수행하도록 보장한다, 많은 프로그래머가 동기화를 배타적으로 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다
* 동기화를 제대로 사용하면 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없을 것이다
* 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다, 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다
* 언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다, 여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장한다는 뜻이다
* 동기화는 배타적 실행 뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다
* Thread.stop은 사용하지 말자
* 가변 데이터는 단일 스레드에서만 쓰도록 하자
* 한 스레드가 데이터를 다 수정한 후 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다

### 과도한 동기화는 피하라
* 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다
* 자바의 언어의 락은 재진입(reentrant)을 허용하므로 교착상태에 빠지지는 않는다, 하지만 응답 불가가 될 상황을 안전 실패(데이터 훼손)로 변모시킬 수도 있다 (외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 이 문제를 쉽게 해결할 수 있다, 또 다른 방법으로는 CopyOnWriteArrayList가 있다(수정할 일이 적고 순회만 빈번히 일어나는 관찰자 리스트 용도로는 최적))
* 동기화 영역 바깥에서 호출되는 외계인 메서드를 열린 호출 (open call)이라 한다 (열린 호출은 실패 방지 효과외에도 동시성 효율을 크게 개선해준다)
* 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다
* 여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화 해야 한다 (비 결정적 행동도 용인하는 클래스라면 상관없다)
* 교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자, 동기화 영역 안에서의 작업은 최소한으로 줄여야 한다

### 스레드보다는 실행자, 태스크, 스트림을 애용하라
* 실행자 서비스의 주요 기능들 ->
* 특정 태스크가 완료되기를 기다린다 (get 메서드)
* 태스크 모음 중 아무것 하나 (invokeAny 메서드) 혹은 모든 태스크 (invokeAll 메서드)가 완료되기를 기다린다
* 실행자 서비스가 종료하기를 기다린다 (awaitTermination 메서드)
* 완료된 태스크들의 결과를 차례로 받는다 (ExecutorCompletionService)
* 태스크를 특정 시간에 혹은 주기적으로 실행하게 된다 (ScheduledThread PoolExecutor 이용)

* 큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스 (스레드 풀)를 생성하면 된다 (스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수 있다)
* 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경할 수 있다

### wait 과 notify 보다는 동시성 유틸리티를 애용하라
* 동시성 컬렉션은 List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다, 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 수행한다, 따라서 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다
* Collections.synchronizedMap 보다는 ConcurrentHashMap을 사용하는 게 훨씬 좋다
* 시간 간격을 잴 때는 항상 System.currentTimeMillis가 아닌 System.nanoTime을 사용하자
* wait 메서드를 사용할 때는 반드시 대기 반복문 (wait loop) 관용구를 사용하라, 반복문 밖에서는 절대로 호출하지 말자, 일반적으로 notify 보다는 notifyAll을 사용하라 (코드를 새로 작성한다면 wait 와 notify를 쓸 이유가 없다)

### 스레드 안전성 수준을 문서화하라
* 메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈일 뿐 API에 속하지 않는다
* 멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다
* 불변 (immutable) : 이 클래스의 인스턴스는 마치 상수와 같아서 외부 동기화도 필요 없다 (String, Long, BibInteger가 태표적)
* 무조건적 스레드 안전 (unconditionally thread-safe) : 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다 (AtomicLong, ConcurrentHashMAp)이 여기서 속한다
* 조건부 스레드 안전 (conditionally thread-safe) : 무조건적 스레드 안전과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다
* 스레드 안전하지 않음 (not thread-safe) : 이 클래스의 인스턴스는 수정 될 수 있다, 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 한다 (ArrayList, HashMap)
* 스레드 적대적 (thread-hostile) : 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다, 이 수준의 클래스는 일반적으로 정적 데이터를 아무 동기화 없이 수정한다
* 락 필드는 항상 final로 선언해야 한다, 락이 교체되면 끔직한 결과로 이어진다
* 모든 클래스가 자신의 스레드 안전성 정보를 명확히 문서화해야 한다
* 조건부 스레드 안전 클래스는 메서드를 어떤 순서로 호출할 때 외부 동기화가 요구되고, 그때 어떤 락을 얻어야 하는지도 알려줘야 한다
* 무조건적 스레드 안전 클래스를 작성할 때는 synchronized 메서드가 아닌 비공개 락 객체를 사용하자 (이렇게 해야 클라이언트나 하위 클래스에서 동기화 메커니즘을 깨뜨리는 걸 예방할 수 있고, 필요하다면 다음에 더 정교한 동시성을 제어 메커니즘으로 재구현 할 여지가 생긴다

### 지연 초기화는 신중히 사용하라
* 지연 초기화 (lazy initialization) 는 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다 (그래서 값이 전혀 쓰이지 않으면 초기화도 결코 일어나지 않는다)
* 지연 초기화는 정적 필드와 인스턴스 필드 모두에 사용할 수 있다
* 지연 초기화는 주로 최적화 용도로 쓰이지만, 클래스와 인스턴스 초기화 때 발생하는 위험한 순환 문제를 해결하는 효과도 있다
* 클래스 혹은 인스턴스 생성 시의 초기화 비용은 줄지만, 그 대신 지연 초기화하는 필드에 접근하는 비용은 커진다 (양날의 검)
* 해당 클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율이 낮은 반면, 그 필드를 초기화하는 비용이 크다면 지연 초기화가 제 역할을 해줄 것이다
* 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 좋다
* 지연 초기화가 초기화 순환성 (initialization circularity) 을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자
* 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 (lazy initialization holder class) 관용구를 사용하자
* 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사 (double-check) 관용구를 사용하라 (이 관용구는 초기화 된 필드에 접근할 때의 동기화 비용을 없애준다)
* 반복해서 초기화해도 괜찮은 인스턴스 필드에는 단일검사 관용구도 고려해 봐야 한다

### 프로그램의 동작을 스레드 스케줄러에 기대지 마라
* 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다
* 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이 중요하다
* 스레드는 당장 처리해야 할 작업이 없다면 실행 돼서는 안 된다
* 스레드는 절대 바쁜 대기 (busy waiting) 상태가 되면 안 된다, 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안 된다는 뜻이다