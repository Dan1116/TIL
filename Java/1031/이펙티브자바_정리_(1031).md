# 이펙티브자바_정리_(1031)
## 질문
* 형변환 = cast
* 형 안정성 -> 타입에 대한 제약이 얼마나 강하냐, 
* hook -> 클래스 내부 동작에 개입할 수 있는 훅(hook)을 신중하게 고른 protected 메서드 형태로 제공해야 한다
* 믹스인 -> 인터페이스는 믹스인(mixin)을 정의하는데 이상적,  추상 클래스는 믹스인 정의에는 사용할 수 없다
* 상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다
* 중첩 클래스의 4가지 종류 -> 정적 멤버 클래스 , 비 정적 멤버 클래스 , 익명 클래스, 지역 클래스
* 멤버 클래스 앞에는 왜 되도록이면 static 을 붙여야 하는가 -> 정적클래스로 만들어야 하는 이유
* 형인자 자료형
* 무인자 자료형
* 제네릭 자료형
* 재귀적 자료형
* 와일드카드 자료형
* 자료형 토큰 = 컴파일 시간 자료형이나 실행시간 자료형 정보를 메서드들에 전달할 목적으로 class 리터럴을 이용하는 경우

* 정적 팩토리 -> 정적 팩터리를 사용하면 클라이언트는 새로운 객체를 만드는 대신 기존 객체들을 공유하게 되므로 메모리 요구량과 쓰레기 수집 비용이 줄어든다
* 동적 팩토리 = run time 

* 캐시 설명 = 변경 불가능 클래스는 자주 사용하는 객체를 캐시(cache)하여 이미 있는 객체가 거듭 생성되지 않도록 하는 정적 팩터리를 제공할 수 있다 -> 정적 팩터리를 사용하면 클라이언트는 새로운 객체를 만드는 대신 기존 객체들을 공유하게 되므로 메모리 요구량과 쓰레기 수집 비용이 줄어든
* 리플렉션 =클래스의 구조를 코딩으로 알 수 있고 값을 가져오거나 함수(메소드)를 콜 할수 있습니다.
* 리플렉션은 조합(Composition)과 함께 사용되어 다형성을 구현하는 강력한 도구, 조합을 사용하여 교체할 수 있는 위임 클래스를 리플랙션을 통해 동적/정적으로 생성하고 교체하는 방식으로 사용. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용되는 방식
* varargs = 가변인수는 컴파일러의 눈속임과 비슷하다. 파라미터의 앞에 ...을 붙여주면 컴파일러가 파라미터를 배열 형식으로 바꾸어버리고, 매개변수로 주어지는 변수들을 모아서 객체로 만들어버린다.
(varargs는 정말로 임의 개수의 인자를 처리할 수 있는 메서드를 만들어야 할 때만 사용)
* 객체 상태를 저장하는 변수들은 final로 선언 될 수 없다 (그 값을 initialize 메서드가 설정해야 하기 때문)
* 언어 명세서

### 이팩티브자바_복습
* 코드는 복사하는게 아니라 재사용해야 한다, 모듈 간 의존성은 가능한 줄여야 한다
* 클래스 멤버 = 필드, 메서드, 멤버 클래스, 멤버 인터페이스
* API = Application Programming Interface, 응용 프로그래밍 인터페이스, 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 
있도록 만든 인터페이스
* 자바빈 패턴 = 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정 메서드들을 호출하여 필수 필드뿐 아니라 선택적 필드의 값들까지 체울 수 있다 => 하지만, 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성(consistency)이 일시적으로 깨질 수 있다, 또한 자바빈 패턴으로는 변경 불가능한 클래스를 만들 수 없다는 것이다
* 빌더 패턴 = 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달, 빌더 객체를 만든다, 그 후 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다, 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만든다 (빌더 클래스는 빌더가 만드는 객체 클래스의 정적 멤버 클래스로 정의)
* 생성자와 마찬가지로, 빌더 패턴을 사용하면 인자에 불변식을 적용할 수 있다, build 메서드 안에서 해당 불변식이 위반되었는지 검사할 수 있는 것이다(빌더 객체에서 실제 객체로 인자가 복사된 다음에 불변식들을 검사할 수 잇다는 것, 그리고 그 불변식을 빌더 객체의 필드가 아니라 실제 객체의 필드를 두고 검사할 수 잇다는 것이 중요)
* private 생성자를 클래스에 넣어서 객체 생성을 방지할 수 있다 (하위 클래스도 만들 수 없다)
* 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의
* 종료자(finalizer) 는 예측 불가능하며, 대체로 위험하고 일반적으로 불필요하다, 종료자의 한 가지 단점은 즉시 실행되리라는 보장이 전혀 없다는 것이다 (따라서 긴급한 작업을 종료자 안에서 처리하면 안 된다)
*  동치 관계 = 반사율, 대칭률, 추이율이라는 특별한 세 가지 성질을 만족하는 관계를 말한다
* clone 메서드는 또 다른 형태의 생성자 -> 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식(invariant)도 제대로 만족시켜야 한다
* 객체 복제를 지원하는 좋은 방법은, 복사 생성자(copy constructor) 나 복사 팩터리 (copy factory)를 제공하는 것
*  변경 불가능 클래스는 자주 사용하는 객체를 캐시(cache)하여 이미 있는 객체가 거듭 생성되지 않도록 하는 정적 팩터리를 제공할 수 있다 -> 정적 팩터리를 사용하면 클라이언트는 새로운 객체를 만드는 대신 기존 객체들을 공유하게 되므로 메모리 요구량과 쓰레기 수집 비용이 줄어든다
*  계승을 허용하려면 반드시 따라야 할 제약사항이 있다 -> 생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안 된다는 것
* 제네릭을 사용하면 컬렉션에 넣는 객체의 자료형이 무엇인지 컴파일러에게 알릴 수 있다



### 클래스와 멤버의 접근 권한은 최소화
* 잘 설계된 모듈은 구현 세부사항을 전부 API 뒤쪽에 감춘다 -> 정보 은닉 ( information hiding), 캡슐화 (encapsulation) 
* 정보 은닉이 시스템을 구성하는 모듈 사이의 의존성을 낮춰서 각자 개별적으로 개발하고 , 시험하고, 최적화하고, 이해하고, 변경할 수 있도록 한다는 사실에 기초
* 정보 은닉 원칙은 소프트웨어의 재사용 가능성을 높인다 ( 모듈간 의존성이 낮아지므로)
* 각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들어야 한다

### equals를 재정의할 때는 반드시 hashCode도 재정의
* 많은 버그가 hashCode 메서드를 재정의하지 않아서 생긴다
* 같은 객체는 같은 해시 코드 값을 가져야 한다
* 중복 필드( redundant field)는 해시 코드 계산 과정에서 제외해도 된다
* 성능을 개선하려고 객체의 중요 부분을 해시 코드 계산 과정에서 생략하면 안 된다는 것이다

### 생성자 대신 정적 팩토리 메서드를 사용할 수 없는지 생각해보기
*  생성자와는 달리 정적 팩터리 메서드에 이름이 있다는 것
* 정적 팩터리 메서드는 이름을 잘 짓기만 한다면 클라이언트 코드의 가독성(readability) 도 높아진다
* 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다는 것, 정적 팩터리 메서드는 사용하면 같은 객체를 반복해서 반환 할 수 있다
* 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환 할 수 있다
* 형인자 자료형(parameterized type (List(String))) 객체를 만들 때 편하다는 점

### 정적 팩토리의 단점
* 정적 팩터리 메서드만 있는 클래스를 만들면 생기는 가장 큰 문제는, public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다
* 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는 다는 단점이 있다

### 추상 클래스 대신 인터페이스를 사용하라
* 추상 클래스는 구현된 메서드를 포함할 수 있지만, 인터페이스는 아니다
* 추상 클래스가 규정하는 자료형을 구현하기 위해서는 추상 클래스를 반드시 계승해야 한다
* 이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다
* 인터페이스는 믹스인(mixin)을 정의하는데 이상적
* 추상 클래스는 믹스인 정의에는 사용할 수 없다

### 멤버 클래스는 가능하면 static 으로 선언
* 중첩 클래스는 (nested class) 다른 클래스 안에 정의된 클래스다
* 중첩 클래스의 4가지 종류 -> 정적 멤버 클래스 , 비 정적 멤버 클래스 , 익명 클래스, 지역 클래스
* 정적 멤버 클래스 빼고는 전부 내부 클래스 (inner class)
* 정적 멤버 클래스는 바깥 클래스의 모든 멤버에( private로 선언된 것들도 ) 접근 가능, 정적 멤버 클래스를 private로 선언했다면 해당 중첩 클래스에 접근할 수 있는 것은 바깥 클래스 뿐이다
* 비 정적 멤버 클래스 객체는 바깥 클래스 객체와 자동적으로 연결, 비 정적 멤버 클래스 안에서는 바깥 클래스의 메서드를 호출할 수 있고, this 한정(qualified this)구문을 통해 바깥 객체에 대한 참조를 획득할 수 있다, 비 정적 멤버 클래스는 바깥 클래스 객체 없이는 존재할 수 없다
* 비 정적 멤버 클래스 객체와 바깥 객체와의 연결은 비 정적 멤버 클래스의 객체가 만들어지는 순간에 확립, 그 뒤에는 변경 할 수 없다
* 비 정적 멤버 클래스는 어댑터를 정의할 때 많이 쓰인다
* 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 때는 항상 선언문 앞에 static 을 붙여서 비 정적 멤버 클래스 대신 정적 멤버 클래스로 만들자
* private 정적 멤버 클래스는 바깥 클래스 객체의 컴포넌트를 표현하는데 많이 쓰인다
* 익명 클래스 = 멤버로 선언하지 않으며, 사용하는 순간에 선언하고 객체를 만든다, 비정적 문맥(nonstatic context) 안에서 사용될 때만 바깥 객체를 갖는다, 하지만 안에서 사용된다 해도 static 멤버를 가질 수는 없다
* 익명 클래스는 선언하는 그 순간에만 객체를 만들 수 있고, instanceof, 클래스 이름이 필요한 곳에는 사용할 수 없다
* 익명 클래스의 클라이언트는 상위 자료형에서 상속된 멤버만 호출할 수 있다
* 익명 클래스는 함수객체를 정의할 때 쓰인다
* 지역 클래스는 지역 변수가 선언될 수 있는 곳이라면 어디서든 선언 할 수 있으며 지역 변수와 동일한 유효범위 규칙을 따른다. 
* 지역 클래스는 멤버 클래스처럼 이름을 가지며, 반복적으로 사용될 수 있다, 익명 클래스처럼 비 정적 문맥에서 정의했을 때만 바깥 객체를 갖는다, static 멤버는 가질 수 없다

### 배열 대신 리스트를 써라
* 배열은 공변 자료형(covariant), 실제화 (reification) 이 되는 자료형 -> 배열의 각 원소의 자료형은 실행시간에 결정
* 제네릭은 불변 자료형(invariant), 실행 시간에 형인자 정보는 삭제  -> 자료형에 관계된 조건들을 컴파일 시점에만 적용, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다는 것
