# EFFECTIVE JAVA_4
# 제네릭
* 제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다
* 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 된다, 따라서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여 더 안전하고 명확한 프로그램을 만들어 준다

## 로(raw) 타입은 사용하지 마라
* 클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라고 한다
* 제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라 한다
* 각각의 제네릭 타입은 일련의 매개변수화 타입 (parameterized type)을 정의 한다, 먼저 클래스 (혹은 인터페이스) 이름이 나오고, 이어서 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다
* 제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의된다
* 로 타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않는 타입
* 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다
* List 같은 매개변수화 타입을 사용할 때와 달리 List 같은 로 타입을 사용하면 타입 안전성을 잃게 된다
* 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 ? 를 사용하자
* Set (null 외에는) 어떤 원소도 넣을 수 없다 
* class 리터럴에는 로 타입을 써야 한다 -> 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다
* 런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다, 그리고 로 타입이든 비한정적 와일드카드 타입이든 instanceof는 완전히 똑같이 동작한다
* 비한정적 와일드카드 타입의 꺾쇠괄호와 물음표는 아무런 역할 없이 코드만 지저분하게 만드므로, 차라리 로 타입을 쓰는 편이 깔끔하다
* 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안 된다, 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다

## 비검사 경고를 제거하라
* 가능한 모든 비검사 경고를 제거하라 -> 모두 제거한다면 그 코드는 타입 안전성이 보장 된다
* 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @Suppress Warnings(“unchecked”) 에너테이션을 달아 경고를 숨기자
* SuppressWarnings 에너테이션은 항상 가능한 한 좁은 범위에 적용하자 (보통은 변수 선언, 아주 짧은 메서드, 혹은 생성자) 이 에너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다

## 배열보다는 리스트를 사용하라
* 배열과 제네릭 타입에는 중요한 차이가 두 가지 있다
	1. 배열은 공변(covariant) -> Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다 (공변, 즉 함께 변한다는 듯) , 하지만 제네릭은 불공변(invariant) 즉 서로 다른 타입 Type1과 Type2가 있을 때, List 는 List 의 하위 타입도 상위 타입도 아니다
	2. 배열은 실체화(reify) 된다, 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인, 하지만 제네릭은 타입 정보가 런타임에는 소거(erasure) 된다, 원소 타입을 컴파일타임에만 검사하며 런타임에는 알수조차 없다
* 소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는  메커니즘으로, 자바 5가 제네릭으로 순조롭게 전환될 수 있도록 해줬다
* 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는 게 보통은 불가능하다, 또한 제네릭 타입과 가변인수 메서드(varargs method) 아이템을 함께 쓰면 해석하기 어려운 경고 메세지를 받게 된다

## 이왕이면 제네릭 타입으로 만들어라
* 일반 클래스를 제네릭 클래스로 만드는 첫 단계는 클래스 선언에 타입 매개변수를 추가하는 일이다
* 제네릭 배열 생성 오류를 해결하는 방법은 1.제네릭 배열 생성을 금지하는 제약을 대놓고 우회하는 방법(가독성이 좋다) -> 배열의 타입을 E[]로 선언하여 오직 E 타입 인스턴스만 받음을 확실히 어필, 코드도 더 짧다, 2. elements 필드의 타입을 E[]에서 object[]로 바꾸는 것
* 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다

## 되도록이면 제네릭 메서드로 만들어라
* 타입 매개변수들을 선언하는 타입 매개변수 목록은 메서드의 제한자와 반환 타입 사이에 온다
* 재귀적 타입 한정(recursive type bound) = 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정한다 (주로 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰인다)
* 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다, 타입과 마찬가지로, 메서드도 형변환 없이 사용할 수 있는 편이 좋으며, 많은 경우 그렇게 하려면 제네릭 메서드가 되어야 한다

## 한정적 와일드카드를 사용해 API 유연성을 높여라
* 매개변수화 타입은 불공변(invariant)
* 유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라
* 반환 타입에는 한정적 와일드카드 타입(?)을 사용하면 안 된다, 유연성을 높여주기는커녕 클라이언트 코드에서도 와일드카드 타입을 써야 하기 때문
* 클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 무슨 문제가 있을 가능성이 크다
* 일반적으로 Comparable보다는 Comparable<? super E>를 사용하는 편이 좋다, 또한 Comparator 보다는 Comparator<? super E>를 사용하는 편이 좋다, 일반화해서 말하면 Comparable 또는 Comparator 을 직접 구현하지 않고 직접 구현한 다른 타입을 확장한 타입을 지원하기 위해 와일드카드가 필요하다
* 메서드 선언에 타입 매개변수가 한 번만 나온다면 와일드카드로 대체하라 (비한정적 타입 매개변수라면 비한정적 와일드카드로, 한정적 타입 매개변수라면 한정적 와일드카드로)
* 조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다, PECS 공식을 기억 -> 생산자(producer) 는 extends를 소비자(consumer)는 super를 사용 (Comparable 과 Comparator 는 모두 소비자)

## 제네릭과 가변인수를 함께 쓸 때는 신중하라
* 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현 방식에는 허점이 있다, 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다, 그런데 내부로 감춰야 했을 이 배열을 클라이언트에 노출하는 문제가 생긴다, 그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생
* 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다
* @SafeVarargs 에너테이션은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치
* 제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다, 예외 2가지 -> 1. @SafeVarargs로 제대로 에노테이트된 또 다른 varargs 메서드에 넘기는 것은 안전 , 2. 이 배열 내용의 일부 함수를 호출만 하는 일반 메서드에 넘기는 것도 안전
* 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @SafeVarags를 달아야 한다
* varargs 매개변수 배열에 아무것도 저장하지 않는다, 그 배열(혹은 복제본)을 신뢰할 수 없은 코드에 노출하지 않는다
* 가변인수와 제네릭은 궁합이 좋지 않다, 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭의 타입 규칙이 서로 다르기 때문
* 제네릭 varargs 매개변수는 타입 안전하지는 않지만, 허용 , 메서드에 제네릭 varargs 매개변수를 사용하고자 한다면, 먼저 그 메서드가 타입 안전한지 확인한 다음 @SafeVarargs 에너테이션을 달아야 한다

## 타입 안전 이종 컨테이너를 고려하라
* 제네릭은 단일원소 컨테이너에도 흔히 쓰인다, 이런 모든 쓰임에서 매개변수화 되는 대상은 컨테이너 자신이다, 따라서 하나의 컨테이너에서 매개변수화 할 수 있는 타입의 수가 제한된다
* 이종 컨테이너 패턴(type safe heterogeneous container pattern) = 컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공 (이렇게 하면 제네릭 타입 시스템이 값의 타입이 키와 같다)
* 한정적 타입 토큰이란 단순히 한정적 타입 매개변수나 한정적 와일드카드를 사용하여 표현 가능한 타입을 제한하는 타입 토큰이다
* 에너테이션 API는 한정적 타입 토큰을 적극적으로 사용한다
* 컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정, 하지만 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있다
* 타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 한다, 또한 직접 구현한 키 타입도 쓸 수 있다 (데이터베이스의 행(컨테이너)을 표현한 DatabaseRow 타입에는 제네릭 타입인 Column를 키로 사용할 수 있다)