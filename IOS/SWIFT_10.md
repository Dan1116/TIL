# SWIFT_10
* 프로퍼티 = 클래스,구조체 또는 열거형 등에 관련된 값
* 메서드 = 특정 타입에 관련된 함수
* 프로퍼티의 종류는 크게 저장 프로퍼티 (Stored Properties), 연산 프로퍼티 (Computed Properties), 타입 프로퍼티 (Type Properties)로 나눌 수 있다
* 연산 프로퍼티 = 값을 저장한 것이 아니라 특정 연산을 실행한 결괏값을 의미, 클래스, 구조체, 열거형에 쓰일 수 있다
* 저장 프로퍼티는 구조체와 클래스에서만 사용할 수 있다
* 저장 프로퍼티와 연산 프로퍼티는 특정 타입의 인스턴스에 사용되는 것을 뜻하지만 특정 타입에 사용되는 프로퍼티도 존재한다, 이를 타입 프로퍼티라고 한다
* 인스턴스 변수는 저장 프로퍼티로, 클래스 변수는 타입 프로퍼티로 구분지을 수 있다
* 프로퍼티의 값이 변하는 것을 감시하는 프로퍼티 감시자 (Property Observers) 도 있다
* 프로퍼티 감시자는 프로퍼티의 값이 변할 때 값의 변화에 따른 특정 액션을 실행, 프로퍼티 감시자는 저장 프로퍼티에 적용할 수 있으며 부모클래스로부터 상속받을 수 있다
* 클래스 또는 구조체의 인스턴스와 연관된 값을 저장하는 가장 단순한 개념의 프로퍼티이다, 저장 프로퍼티는 var 키워드를 사용하여 변수 저장 프로퍼티가 될 수도 있으며 let 키워드를 사용하여 상수 저장 프로퍼티가 될 수도 있다
* 저장 프로퍼티를 정의할 때 프로퍼티 기본값을 지정할 수 있으며, 초기화할 때 초깃값을 지정해줄 수도 있다
* 구조체의 저장 프로퍼티가 옵셔널이 아니더라도, 구조체는 저장 프로퍼티를 모두 포함하는 이니셜라이저를 자동으로 생성한다, 하지만 클래스의 저장 프로퍼티는 옵셔널이 아니라면 프로퍼티 기본값을 지정해주거나 사용자정의 이니셜라이저를 통해 반드시 초기화해주어야 한다, 또 클래스 인스턴스의 상수 프로퍼티는 인스터스가 초기화 (이니셜라이즈) 될 때 한 번만 값을 할당할 수 있으며, 자식 클래스에서 이 초기화를 변경 할 수 없다
* 구조체는 프로퍼티에 맞는 이니셜라이저를 자동으로 제공하지만 클래스는 그렇지 않아서 클래스 인스턴스의 저장 프로퍼티를 사용하는 일은 좀 번거롭다, 하지만 클래스의 저장 프로퍼티에 초깃값을 지정해주면 따로 사용자정의 이니셜라이저를 구현해줄 필요가 없다
* 인스턴스를 생성할 때 이니셜라이저를 통해 초깃값을 보내야 하는 이유는 프로퍼티가 옵셔널이 아닌 값으로 선언되어 있기 때문, 그러므로 인스턴스는 생성할 때 프로퍼티에 값이 꼭 있는 상태여야 한다 (그런데 저장 프로퍼티의 값이 있어도 그만, 없어도 그만인 옵셔널이라면 굳이 초깃값을 넣어주지 않아도 된다)
* 지연 저장 프로퍼티 (Lazy Stored Properties) = 호출이 있어야 값을 초기화하며, 이때 lazy 키워드를 사용
* 상수는 인스턴스가 완전히 생성되기 전에 초기화해야 하므로 필요할 때 값을 할당하는 지연 저장 프로퍼티와는 맞지 않는다, 따라서 지연 저장 프로퍼티는 var 키워드를 사용하ㅁ여 변수로 정의
* 지연 저장 프로퍼티는 주로 복잡한 클래스나 구조체를 구현할 때 많이 사용, 클래스 인스턴스의 저장 프로퍼티로 다른 클래스 인스턴스나 구조체 인스턴스를 할당애햐 할 때
* 연산 프로퍼티는 실제 값을 저장하는 프로퍼티가 아니라, 특정 상태에 따른 값을 연산하는 프로퍼티이다, 인스턴스 내/외부의 값을 연산하여 적절한 값을 돌려주는 접근자 (getter)의 역할이나 은닉화된 내부의 프로퍼티 값을 간접적으로 설정하는 설정자 (Setter)의 역할을 할 수도 있다 (클래스, 구조체, 열거형에 연산 프로퍼티를 정의할 수 있다)
* 다만 연산 프로퍼티는 접근자인 get 메서드만 구현해둔 것 처럼 읽기 전용 상태로 구현하기 쉽지만, 쓰기 전용 상태로 구현할 수 없다는 단점이 있다
* 연산 프로퍼티를 사용하면 하나의 프로퍼티에 접근자와 설정자가 모두 모여있고, 해당 프로퍼티가 어떤 역할을 하는지 좀 더 명확하게 표현 가능하다, 인스턴스를 사용하는 입장에서도 마치 저장 프로퍼티인 것 처럼 편하게 사용할 수 있다
* 설정자의 매개변수로 원하는 이름을 소괄호 안에 명시해주면 set 메서드 내부에서 전닳받은 전달인자를 사용할 수 있다
* 프로퍼티 감시자 (Property Observers) 를 사용하면 프로퍼티의 값이 변경됨에 따라 적절한 액션을 취할 수 있다, 프로퍼티 감시자는 프로퍼티의 값이 새로 할당될 때마다 호출한다, 이때 변경되는 값이 현재의 값과 같더라도 호출한다
* 프로퍼티 감시자는 지연 저장 프로퍼티에 사용할 수 없으며, 오로지 일반 저장 프로퍼티에만 적용할 수 있다, 또한 프로퍼티 재정의를 통해 상속받은 저장 프로퍼티 또는 연산 프로퍼티에도 적용할 수 있다
* 상속받지 않은 연산 프로퍼티에는 프로퍼티 감시자를 사용할 필요가 없으며 할 수도 없다, 연산 프로퍼티의 접근자와 설정자를 통해 프로퍼티 감시자를 구현할 수 있기 때문, 연산 프로퍼티는 상속받았을 때만 프로퍼티 재정의를 통해 프로퍼티 감시자를 사용한다
* 프로퍼티 감시자에는 프로퍼티의 값이 변경되기 직전에 호출하는 willSet 메서드와 프로퍼티의 값이 변경된 직후에 호출하는 didSet 메서드가 있다
* willSet 메서드와 didSet 메서드에느 냄개변수가 하나 씩 있다, willSet 메서드에 전달되는 전달인자는 프로퍼티가 변경될 값이고, didSet 메서드에 전달되는 전달인자는 프로퍼티가 변경되기 전의 값이다, 그래서 매개변수의 이름을 따로 지정하지 않으면 willSet 메서드에는 newValue가, didSet 메서드에는 oldValue라는 매개변수 이름이 자동 지정된다
* 각각의 인스턴스가 아닌 타입 자체에 속하는 프로퍼티를 타입 프로퍼티라고 한다, 타입 프로퍼티는 타입 자체에 영향을 미치는 프로퍼티이다, 인스턴스 생성 여부와 상관없이 탕비 프로퍼티의 값은 하나며, 그 타입은 모든 인스턴스가 공통으로 사용하는 값, 모든 인스턴스에서 공용으로 접근하고 값을 변경할 수 있는 변수등의 정의할 때 유용
* 타입 프로퍼티는 두 가지인데 저장 타입 프로퍼티는 변수 또는 상수로 선언할 수 있으며, 연산 타입 프로퍼티는 변수로만 선언할 수 있다
* 저장 타입 프로퍼티는 반드시 초깃값을 설정해야 하며 지연 연상 된다, 지연 저장 프로퍼티와는 조금 다르게 다중 스레드 환경이라도 단 한 번만 초기화된다는 보장을 받는다, 지연 연산이 된다고 해서 lazy 키워드로 표시해 주지는 않는다
* 키 경로 (Key Path)를 활용하면 값을 바로 꺼내오는 것이 아니라 어떤 프로퍼티의 위치만 참조하도록 할 수 있다, 키 경로를 사용하여 간접적으로 특정 타입의 어떤 프로퍼티 값을 가리켜야 할지 미리 지정해두고 사용할 수 있다 (키 경로는 \와 . 경로로 구성)
* 키 경로를 잘 활용하면 프로토콜과 마찬가지로 타입 간의 의존성을 낮추는 데 많은 도움을 준다
* 구조체와 열거형이 메서드를 가질 수 있다는 것은 기존 프로그래밍 언어와 스위프트의 큰 차이점 중 하나 이다
* 인스턴스 메서드는 특정 타입의 인스턴스에 속한 함수를 뜻한다, 인스턴스 메서드는 함수와 달리 특정 타입 내부에 구현한다, 따라서 인스턴스가 존재할 때만 사용할 수 있다
* 모든 인스턴스는 암시적으로 생성된 self 프로퍼티를 갖는다, 자바의 this와 비슷하게 인스턴스 자기 자신을 가리키는 프로퍼티 이다, self 프로퍼티는 인스턴스를 더 명확히 지칭하고 싶을 때 사용
* 인스턴스 프로퍼티와 타입 프로퍼티가 있듯이 메서드에도 인스턴스 메서드와 타입 메서드가 있다, 타입 자체에 호출이 가능한 메서드를 타입 메서드라고 한다, 메서드 앞에 static 키워드를 사용하여 타입 메서드임을 나타낸다
* 클래스의 타입 메서드는 static 키워드와 class 키워드를 사용할 수 있는데 static 으로 정의하면 상속 후 메서드 재정의가 불가능하고 class로 정의하면 상속 후 메서드 재정의가 가능
* 타입 메서드는 인스턴스 메서드와는 달리 self 프로퍼티가 타입 그 자체를 가리킨다는 점이 다르다, 인스턴스 메서드에서는 self가 인스턴스를 가리킨다면 타입 메서드의 self는 타입을 가리킨다