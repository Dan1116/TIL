# SWIFT_4
* 스위프트는 타입에 굉장히 민감하고 엄격하다, 서로 다른 타입의 데이터 교환은 꼭 타입캐스팅을 거쳐야 한다
* 스위프트에서 값 타입의 데이터 교환은 엄밀히 말하면 타입캐스팅이 아닌 새로운 인스턴스를 생성하여 할당하는 것
* 스위프트가 컴파일 시 타입을 확인하는 것을 타입 확인이라고 한다, 타입 확인을 통해 여러 타입을 섞어 사용할 때 발생할 수 있는 런타임 오류를 피할 수 있다
* 튜플 = 타입의 이름이 따로 지정되어 있지 않은, 프로그래머 마음대로 만드는 타입, 지정된 데이터의 묶음이라고 표현할 수 있다
* 튜플은 타입 이름이 따로 없으므로 일정 타입의 나열만으로 튜플 타입을 생성해줄 수 있다, 튜플에 포함될 데이터 개수는 자유롭게 정할 수 있다
* 스위프트는 튜플 외에도 많은 수의 데이터를 묶어서 저장하고 관리할 수 있는 컬렉션 타입을 제공한다, 컬렉션 타입에는 배열, 딕셔너리, 세트 등이 있다
* 스위프트의 Array는 버퍼 이다, 필요에 따라 자동으로 버퍼의 크기를 조절해주므로 요소의 삽입 및 삭제가 자유롭다
* 배열은 각 요소의 인덱스를 통해 접근할 수 있다, 인덱스는 0부터 시작
* 중간에 요소를 삽입하고 싶다면 insert(_: at  :)  메서드를 사용, 삭제하고 싶다면 remove (_ : ) 메서드를 사용, 삭제된 후 반환
* 딕셔너리는 요소들이 순서 없이 키와 값의 쌍으로 구성되는 컬렉션 타입, 딕셔너리에 저장되는 값은 항상 키와 쌍을 이루게 되는데, 딕셔너리 안에는 키가 하나이거나 여러 개일 수 있다, 단 하나의 딕셔너리 안의 키는 같은 이름을 중복해서 사용할 수 없다
* 딕셔너리는 Dictionary 라는 키워드와 키의 타입과 값의 타입 이름의 조합으로 써준다, 대괄호로 키와 값의 타입 이름의 쌍을 묶어 딕셔너리 타입임을 표현한다
* 딕셔너리는 각 값에 키로 접근할 수 있다, 딕셔너리 내부에서 키는 유일해야 하며, 값은 유일하지 않다, 딕셔너리는 배열과 다르게 딕셔너리 내부에 없는 키로 접근해도 오류가 나지 않는다, 다만 nil을 반환할 뿐, 특정 키에 해당하는 값을 제거하려면 removeValue (forKey:) 메서드를 사용한다, 키에 해당하는 값이 제거된 후 반환
* 세트 = 같은 타입의 데이터를 순서 없이 하나의 묶음으로 저장하는 형태의 컬렉션 타입, 세트 내의 값은 모두 유일한 값, 즉 중복된 값이 존재하지 않는다
* 세트는 보통 순서가 중요하지 않거나 각 요소가 유일한 값이어야 하는 경우에 사용한다, 세트의 요소로는 해시 가능한 값이 들어와야 한다
* 세트는 Set 키워드와 타입 이름의 조합으로 써줍니다, 배열과 마찬가지로 대괄호로 값들을 묶어 세트 타입임을 표현
* 세트는 자신 내부의 값들이 모두 유일함을 보장하므로, 집합관계를 포함하고자 할 때 유용하게 쓰일 수 있으며, 두 세트의 교집합, 합집합 등을 연산하기에 매우 용이하다, 또한 sorted() 메서드를 통해서 정렬된 배열을 반환해줄 수도 있다
* 열거형 = 열거형은 연관된 항목들을 묶어서 표현할 수 있는 타입, 프로그래머가 정의해준 항목 값 외에는 추가/수정이 불가
* 열거형 => 제한된 선택지를 주고 싶을 때, 정해진 값 외에는 입력 받고 싶지 않을 때, 예상된 입력 값이 한정되어 있을 때
* 스위프트의 열거형은 각 열거형이 고유의 타입으로 인정되기 때문에 실수로 버그가 일어날 가능성이 없다, 물론 열거형 각 항목이 원시 값이라는 형태로 실제 값을 가질 수도 있습니다, 또는 연관 값 (Associated Values) 을 사용하여 다른 언어에서 공용체라고 불리는 값의 묶음도 구현할 수 있다
* 열거형의 각 항목은 자체로도 하나의 값이지만 항목의 원시 값 (Raw Value) 도 가질 수 있다, 특정 타입으로 지정된 값을 가질 수 있다는 뜻, 특정 타입의 값을 원시 값으로 가지고 싶다면 열거형 이름 오른쪽에 타입을 명시해주면 된다, 또 원시 값을 사용하고 싶다면 rawValue라는 프로퍼티를 통해 가져올 수 있다
* 스위프트의 열거형 각 항목이 연관 값을 가지게 되면, 기존 프로그래밍 언어의 공용체 형태를 띌 수도 있다, 열거형 내의 항목 (case) 이 자신과 연관된 값을 가질 수 있다, 연관 값은 각 항목 옆에 소괄호로 묶어 표현할 수 있다, 다른 항목이 연관 값을 갖는다고 모든 항목이 연관 값을 가질 필요는 없다
* 순환 열거형 = 열거형 항목의 연관 값이 열거형 자신의 값이고자 할 때 사용, 순환 열거형을 명시하고 싶다면 indirect 키워드를 사용하면 된다, 특정 항목에만 한정하고 싶다면 case 키워드 갚에 indirect를 붙이면 되고, 열거형 전체에 적용하고 싶다면 enum 키워드 앞에 indirect 키워드를 붙이면 된다