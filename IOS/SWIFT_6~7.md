# SWIFT_6~7
## 흐름제어
* 특정 명령어를 반복해서 실행해야할 때 조건문과 반복문을 사용한다

### 조건문
* if, switch, guard

### if구문
* 스위프트의 if 구문은 조건의 값이 꼭 Bool 타입이어야 한다
* else if 는 몇 개가 이어져도 상관없으며 else 블록은 없어도 상관없다

### switch 구문
* break 키워드 사용은 선택 사항, case 내부의 코드를 모두 실행하면 break 없이도 switch 구문이 종료된다
* 스위프트에서 switch 구문의 case를 연속 실행하려면 fallthrough 키워드를 사용해야 한다
* 스위프트에서는 switch 구문의 조건에 다양한 값이 들어갈 수 있다, 다만 각 case에 들어갈 비교 값은 입력 값과 데이터 타입이 같아야 한다, 또한 비교될 값이 명확히 한정적인 값 (열거형 값)이 아닐 때는 default를 꼭 작성해야 한다
* 각 case 에는 범위 연산자를 사용할 수도, where 절을 사용해 조건을 확장할 수도 있다
* switch 구문의 입력 값으로 숫자 표현이 아닌 문자, 문자열, 열거형, 튜플, 범위, 해턴이 적용된 타입 등 다양한 타입의 값도 사용이 가능하다
* case XXX: 다음에는 꼭 실행 가능한 코드가 위치해야 한다
* where 키워드를 사용하여 case 조건을 확장할 수 있다
* 만약 값에 대응하는 각 case를 구현하지 않는다면 default 는 필수이다

### 반복문
* 조건에 따라 실행되어야 하는 명령어를 조건문을 통해 분기한다면, 같거나 비슷한 명령을 반복 실행할 때는 반복문만큼 중요한 것이 없다, 특히나 배열과 같은 시퀀스, 순서가 있는 데이터는 반복문으로 더욱 편리하게 처리할 수 있다

### for-in 구문
* for-in 반복 구문은 반복적인 데이터나 시퀀스를 다룰 때 사용한다
* for-in 구문은 스위프트의 기본 컬렉션 타입에서도 유용하게 사용할 수 있다, 딕셔너리는 넘겨 받는 값의 타입이 튜플로 지정되어 넘어온다
* 함수형 패러다임을 이해하면 for-in 구문보다 map, filter, flatMap등을 더 많이 사용하게 된다

### while 구문
* 특정 조건이 성립하는 한 블록 내부의 코드를 반복해서 실행, Bool 타입으로 지정되어야 한다

### repeat-while 구문
* repeat-while => repeat 블록의 코드를 최초 1 회 실행한 후, while 다음의 조건이 성립하면 블록 내부의 코드를 반복 실행

### 구문 이름표
* 반복문 앞에 이름과 함께 콜론을 붙여 구문의 이름을 지정해주는 구문 이름표를 사용하면 보다 편리하게 반복문을 이용할 수 있다
* 이름이 지정된 구문을 제어하고자 할 때는 제어 키워드와 구문 이름을 함께 써주면 된다

## 함수
* 함수 대부분은 작업의 가장 작은 단위이자 하나의 작은 프로그램이라 할 수 있다
* 스위프트에서 함수는 일급 객체이기 때문에 하나의 값으로도 사용할 수 있다

### 함수와 메서드
* 함수와 메서드는 기본적으로 같다, 다만 상황이나 위치에 따라 다른 용어로 부르는 것 뿐이다
* 구조체, 클래스, 열거형 등 특정 타입에 연관되어 사용하는 함수를 메서드라 부른다
* 모듈 전체에서 전역적으로 사용할 수 있는 것을 함수라 부른다

### 함수의 정의와 호출 
* 조건문이나 반복문 같은 스위프트의 다른 문법과 달리 함수에서는 소괄호()를 생략할 수 없다
* 스위프트의 함수는 재정의 (오버라이드)와 중복 정의 (오버로드)를 모두 지원한다
* 매개변수의 타입이 다르면 같은 이름의 함수를 여러 개 만들 수 있고, 매개변수의 개수가 달라도 같은 이름의 함수를 만들 수 있다
* 이름이 같은 함수를 구현해도 오류가 발생하지 않는다

### 기본적인 함수의 정의와 호출
* 스위프트의 함수는 자유도가 굉장히 높은 문법 중 하나, 기본으로 함수의 이름과 매개변수 (parameter), 반환 타입 (Return Type)등을 사용하여 함수를 정의한다
* 함수를 정의하는 키워드는 func, 함수 이름을 지정해준 후 매개변수는 소괄호로 감싸고 반환 타입을 명시하기 전에는 - > 를 사용하여 어떤 타입이 반환 (return) 될 것인지 명시한다

### 매개변수
* 매개변수는 함수를 정의할 때 외부로 받아들이는 전달 값의 이름을 의미, 전달 인자 (Argument) 혹은 인자는 함수를 실제로 호출할 때 전달하는 값을 의미한다
* 함수에 매개변수가 필요 없다면 매개변수 위치를 공란으로 비워둔다
* 매개변수가 여러 개 필요한 함수를 정의할 때는 쉼표로 매개변수를 구분한다 (주의할 점은 함수를 호출할 때, 매개변수 이름을 붙여주고 콜론 : 을 적어준 후 전달인자를 보내준다)
* 호출 시에 매개변수에 붙이는 이름을 매개변수 이름이라고 한다

### 매개변수 이름과 전달인자 레이블
* 매개변수에 매개변수 이름과 전달인자 레이블을 지정해줄 수 있다, 전달인자 레이블을 매개변수 이름과 별도로 지정하면 함수 외부에서 매개변수의 역할을 좀 더 명확히 할 수 있다
* 전달인자 레이블을 사용하려면 함수 정의에서 매개변수 이름 앞에 한 칸을 띄운 후 전달인자 레이블을 지정한다
* func 함수 이름 (전달인자 레이블 매개변수 이름 : 매개변수 타입, 전달인자 레이블 매개변수 이름 : 매개변수 타입…) - > 반환 타입 { 실행 구문 return 반환 값 }
* 함수 내부에서 전달인자 레이블을 사용할 수 없으며, 함수를 호출할 때는 매개변수 이름을 사용할 수 없다
* 전달인자 레이블을 변경하면 함수의 이름 자체가 변경된다, 그러므로 전달인자 레이블만 다르게 써주더라도 함수 중복 정의 (오버로드)로 동작할 수 있다

### 매개변수 기본값
* 스위프트의 함수에서는 매개변수마다 기본값을 지정할 수 있다, 즉 매개변수가 전달되지 않으면 기본값을 사용, 매개변수 기본값이 있는 함수는 함수를 중복 정의한 것 처럼 사용 할 수 있다
* 기본값이 없는 매개변수를 기본값이 있는 매개변수 앞에 사용해야한다

### 가변 매개변수와 입출력 매개변수
* 매개변수로 몇 개의 값이 들어올지 모를 때, 가변 매개변수를 사용할 수 있다
* 가변 매개변수는 0개 이상의 값을 받아올 수 있으며, 가변 매개변수로 들어온 인자 값은 배열처럼 사용할 수 있다
* 함수마다 가변 매개변수는 하나만 가질 수 있다
* 함수의 전달인자로 값을 전달할 때는 보통 값을 복사해서 전달, 값이 아닌 참조를 전달하려면 입출력 매개변수를 사용, 값 타입 데이터의 참조를 전달인자로 보내면 함수 내부에서 참조하여 원래 값을 변경한다

#### 입출력 매개변수의 전달 순서 ->
	* 1. 함수를 호출할 때, 전달인자의 값을 복사한다
	* 2. 해당 전달인자의 값을 변경하면 1.에서 복사한 것을 함수 내부에서 변경한다
	* 3. 함수를 반환하는 시점에 2.에서 변경된 값을 원래의 매개변수에 할당한다

* 연산 프로퍼티 또는 감시자가 있는 프로퍼티가 입출력 매개변수로 전달된다면, 함수 호출 시점에 그 프로퍼티의 접근자가 호출되고 함수의 반환 시점에 프로퍼티의 설정자가 호출된다
* 참조는 inout 매개변수로 전달 될 변수 또는 상수 앞에 앰퍼샌드 (&)를 붙여서 표현한다
* 입출력 매개변수는 매개변수 기본값을 가질 수 없으며, 가변 매개변수로 사용될 수 없다, 또한 상수는 변경될 수 없으므로 입출력 매개변수의 전달인자로 사용될 수 없다

### 반환 타입
* 함수는 특정 연산을 실행한 후 결과값을 반환한다, 그러나 값의 반환이 굳이 필요하지 않은 함수도 있다, 그럴 때는 반환 값이 없는 함수를 만들어 줄 수 있다
* Void를 표기하거나 아예 반환 타입 표현을 생략해도 된다

### 데이터 타입으로서의 함수
* 스위프트의 함수는 일급 객체이므로 하나의 데이터 타입으로 사용할 수 있다, 각 함수는 매개변수 타입과 반환 타입으로 구성된 하나의 타입으로 사용할 수 있다
* 함수를 데이터 타입으로 사용할 수 있다는 것은 함수를 전달인자로 받을 수도, 반환 값으로 돌려줄 수도 있다는 의미, 상황에 맞는 함수를 전달인자로 넘겨 적절히 처리할 수도 있으며 상황에 맞는 함수를 반환해주는 것도 가능하다

### 중첩 함수
* 스위프트는 데이터 타입의 중첩이 자유롭다, 열거형 안에 또 하나의 열거형이 들어갈 수 있고 클래스 안에 또 다른 클래스가 들어올 수 있는 등 다른 프로그래밍 언어에서 생각하지 못했던 패턴을 자유롭게 만들 수 있다
* 함수가 하나의 반환 값으로 사용될 수 있으므로 중첩 함수를 담은 함수가 중첩 함수를 반환하면 밖에서도 사용할 수 있다

### 종료되지 않는 함수
* 스위프트에는 종료되지 않는 함수가 있다
* 정상적으로 종료되지 않는 함수 -> 비반환 함수, 비반환 메서드
* 비반환 함수는 오류를 던진다든가 중대한 시스템 오류를 보고하는 등의 일을 하고 프로세스를 종료해 버린다
* 비반환 함수는 어디서든 호출이 가능하고 guard 구문의 else 블록에서도 호출할 수 있다
* 비반환 메서드는 재정의는 할 수 있지만 비반환 타입이라는 것은 변경할 수 없다
* 비반환 함수는 반환 타입을 Never라고 명시해주면 된다

### 반환 값을 무시할 수 있는 함수
* @discardableResult => 함수의 반환 값을 무시해도 된다는 선언
* @discardableResult 선언 속성은 스위프트 표준 라이브러리 메서드에도 종종 사용한다