# SWIFT_1~5
## 스위프트
* 스위프트의 거의 모든 문법에서 소괄호는 사용하거나 생략해도 무방, 또한 세미콜론도 생략 가능, 다만 중괄호는 생략 불가 
* 스위프트의 언어 특징 => 1. 안전성, 2. 신속성, 3. 더 나은 표현성

### 객체지향
* 객체 지향 프로그래밍 패러다임 =  객체지향 프로그래밍은 프로그램을 유연하고 쉽게 변경할 수 있도록 작성할 수 있어 대규모 소규모 소프트웨어 개발에 많이 사용 된다, 소프트웨어 개발과 유지보수를 간편하게 할 수 있으며, 직관적으로 코드를 분석할 수 있다는 장점이 있다, 클래스 하나의 문제 해결을 위한 데이터와 메서드를 모아놓은 방식으로 응집력을 강화하고 각 클래스는 독립적이 되도록 디자인해 결합력을 약화할 수 있어서 좋다

### 함수형
* 함수형 프로그래밍 패러다임 = 대규모 병렬처리가 굉장히 쉽다, 프로그램이 상태의 변화 없이 데이터 처리를 수학적 함수 계산으로 취급하고자 하는 패러다임

* 수학적 함수는 순수하게 함수에 전달된 인자 값만 결과에 영향을 주므로 상태 값을 갖지 않고 순수하게 함수만으로 동작, 따라서 어떤 상황에서 프로그램을 실행하더라도 일정하게 같은 결과를 도출할 수 있다, 프로세스 혹은 스레드 별로 특정 값을 참조하기 위해 락을 걸거나 대기할 필요가 없기 때문, 또한 필요한 만큼 함수를 나누어 처리할 수 있도록 스케일업 할 수 있기 때문에 대규모 병렬처리에 큰 강점이 있다

#### 일급책체의 특징 
	* 1. 전달인자로 (Argument) 로 전달할 수 있어야 한다
	* 2. 동적 프로퍼티 할당이 가능 해야 한다
	* 3. 변수나 데이터 구조 안에 담을 수 있어야 한다
	* 4. 반환 값으로 사용할 수 있어야 한다
	* 5. 할당할 때 사용된 이름과 관계 없이 고유한 객체로 구별할 수 있어야 한다

#### 함수형 프로그래밍 패러다임으로만 프로그램을 작성한다면
	* 1. 여러 가지 연산 처리 작업이 동시에 일어나는 프로그램을 만들기 쉽다
	* 2. 멀티 코어 혹은 여러 개의 연산 프로세서를 사용하는 시스템에서 효율적인 프로그램을 만들기 쉽다
	* 3. 상태변화에 따른 부작용에서 자유로워지므로 순수하게 기능 구현에 초점을 맞추어 설계할 수 있다

### 프로토콜
* 스위프트의 프로토콜 = 참조 타입의 참조 문제에서 조금 더 자유로울 수 있고, 다중상속이 불가능한 한계를 뛰어넘을 수 있으며 더 나은 추상화 메커니즘을 구현할 수 있다

## 스위프트의 기본 명명 규칙
* Lower Camel Case : function, method, variable, constant
* Upper Camel Case: type (class, struct, enum, extension)
* 스위프트는 대소문자를 구분
* 함수, 메서드, 인스턴스 이름은 첫 글자를 소문자로 사용하는 소문자 카멜케이스를 사용
* 클래스, 구조체, 익스텐션, 프로토콜, 열거형 이름은 타입의 이름이기 때문에 첫 글자를 대문자로 사용하는 대문자 카멜케이스를 사용
* 로그 = 애플리케이션의 상태 또는 내부 로직의 흐름을 관찰할 수 있도록 출력한 정보
* 문자열 보간법 (String Interpolation) 은 변수 또는 상수 등의 값을 문자열 내에 나타내고 싶을 때 사용
* var [변수명] : [데이터 타입]  = [값], 변수를 생성할 때 데이터 타입은 생략할 수 있다
* let [상수명] : [데이터 타입] = [값], 변수 생성과 마찬가지로 상수 생성 때도 데이터 타입 생략 가능

## 스위프트의 데이터 타입 기본
* 스위프트의 기본 데이터 타입은 구조체를 타입의 기반으로 삼아 스위프트의 다양한 기능 (익스텐션, 제네릭) 을 두루 사용하여 구현되어 있다
* 스위프트의 모든 데이터 타입 이름은 첫 글자가 대문자로 시작하는 대문자 카멜케이스를 사용합니다
* AnyObject 는 Any 보다는 조금 한정된 의미로 클래스의 인스턴스만 할당할 수 있다

## 스위프트의 데이터 타입 고급
* 스위프트는 타입에 굉장히 민감하고 엄격하다, 서로 다른 타입의 데이터 교환은 꼭 타입캐스팅을 거쳐야 한다
* 스위프트가 컴파일 시 타입을 확인하는 것을 타입 확인이라고 한다, 타입 확인을 통해 여러 타입을 섞어 사용할 때 발생할 수 있는 런타임 오류를 피할 수 있다
* 튜플 = 타입의 이름이 따로 지정되어 있지 않은, 프로그래머 마음대로 만드는 타입, 지정된 데이터의 묶음이라고 표현할 수 있다
* 스위프트의 Array는 버퍼 이다, 필요에 따라 자동으로 버퍼의 크기를 조절해주므로 요소의 삽입 및 삭제가 자유롭다

### 딕셔너리
* 딕셔너리는 요소들이 순서 없이 키와 값의 쌍으로 구성되는 컬렉션 타입
* 딕셔너리에 저장되는 값은 항상 키와 쌍을 이루게 되는데, 딕셔너리 안에는 키가 하나이거나 여러 개일 수 있다, 단 하나의 딕셔너리 안의 키는 같은 이름을 중복해서 사용할 수 없다
* 딕셔너리는 각 값에 키로 접근할 수 있다, 딕셔너리 내부에서 키는 유일해야 하며, 값은 유일하지 않다, 딕셔너리는 배열과 다르게 딕셔너리 내부에 없는 키로 접근해도 오류가 나지 않는다, 다만 nil을 반환할 뿐, 특정 키에 해당하는 값을 제거하려면 removeValue (forKey:) 메서드를 사용한다, 키에 해당하는 값이 제거된 후 반환

### 세트
* 세트 = 같은 타입의 데이터를 순서 없이 하나의 묶음으로 저장하는 형태의 컬렉션 타입, 세트 내의 값은 모두 유일한 값, 즉 중복된 값이 존재하지 않는다
* 세트는 보통 순서가 중요하지 않거나 각 요소가 유일한 값이어야 하는 경우에 사용한다, 세트의 요소로는 해시 가능한 값이 들어와야 한다

### 열거형
* 열거형 = 열거형은 연관된 항목들을 묶어서 표현할 수 있는 타입, 프로그래머가 정의해준 항목 값 외에는 추가/수정이 불가
* 스위프트의 열거형은 각 열거형이 고유의 타입으로 인정되기 때문에 실수로 버그가 일어날 가능성이 없다, 물론 열거형 각 항목이 원시 값이라는 형태로 실제 값을 가질 수도 있습니다, 또는 연관 값 (Associated Values) 을 사용하여 다른 언어에서 공용체라고 불리는 값의 묶음도 구현할 수 있다
* 열거형의 각 항목은 자체로도 하나의 값이지만 항목의 원시 값 (Raw Value) 도 가질 수 있다, 특정 타입으로 지정된 값을 가질 수 있다는 뜻, 특정 타입의 값을 원시 값으로 가지고 싶다면 열거형 이름 오른쪽에 타입을 명시해주면 된다, 또 원시 값을 사용하고 싶다면 rawValue라는 프로퍼티를 통해 가져올 수 있다
* 순환 열거형 = 열거형 항목의 연관 값이 열거형 자신의 값이고자 할 때 사용, 순환 열거형을 명시하고 싶다면 indirect 키워드를 사용하면 된다, 특정 항목에만 한정하고 싶다면 case 키워드 갚에 indirect를 붙이면 되고, 열거형 전체에 적용하고 싶다면 enum 키워드 앞에 indirect 키워드를 붙이면 된다

## 연산자
* A === B -> 참조가 같다, A와 B가 참조 (레퍼런스) 타입일 때 A와 B가 같은 인스턴스를 가리키는지 비교하여 불리언 값을 반환한다
* A ~= B -> 패턴매치, A와 B의 패턴이 매치되는지 확인하여 불리언 값을 반환한다
* Question ? A : B -> 삼항 조건 연산자, Question (불리언 값)이 참이면 A, 거짓이면 B를 반환
* A…B -> A부터 B까지의 수를 묶어 범위를 표현 (A와 B 포함)
* A..<B -> A부터 B미만까지의 수를 묶어 범위를 표현 (A포함, B 불포함)
* A… -> A 이상의 수를 묶어 범위를 표현 (A 포함)
* …A -> A 이하의 수를 묶어 범위를 표현 (A 포함)
* .. < A -> A 미만의 수를 묶어 범위를 표현 (A 불포함)

#### 비트 연산자
*  ~A -> A의 비트를 반전한 결과를 반환
* A & B -> A와 B의 비트 AND 논리 연산을 실행
* A | B -> A와 B의 비트 OR 논리 연산을 실행
* A ^ B -> A와 B의 비트 XOR 논리 연산을 실행
* A >> B -> A의 비트를 B 만큼 비트를 시프트 (이동) 

* &+ -> 오버플로에 대비한 덧셈 연산
* &- -> 오버플로에 대비한 뺄셈 연산
* &* -> 오버플로에 대비한 곱셈 연산
* 오버플로 연산자를 사용하면 오버플로를 자동으로 처리한다

* A ?? B -> A가 nil이 아니면 A를 반환, A가 nil 이면 B를 반환
* -A -> A의 부호를 변경
* O! -> O (옵셔널 개체)의 값을 강제로 추출
* V? -> V (옵셔널 개체)를 안전하게 추출, V (데이터 값) 가 옵셔널임을 표현
* nil 병합 연산자는 옵셔널을 사용할 때 유용한 연산자