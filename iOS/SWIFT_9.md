# SWIFT_9
* 구조체와 클래스는 프로그래머가 데이터를 용도에 맞게 묶어 표현하고자 할 때 유용하다
* 구조체의 인스턴스는 값 타입이고, 클래스의 인스턴스는 참조 타입이다
* 스위프트의 데이터 타입과 열거형은 모두 값 타입이다
* 스위프트에는 소스파일 하나에 여러 개의 구조체와 여러 개의 클래스를 정의하고 구현해도 문제가 없다, 또한 중첩 함수와 마찬가지로 구조체 안에 구조체, 클래스 안에 클래스 등과 같이 중첩 타입의 정의 및 선언이 가능
* 구조체는 struct 키워드로 정의
* 구조체 또는 클래스를 정의한다는 것은 새로운 타입을 생성해주는 것과 마찬가지이므로 기본 타입 이름 (Int, String, Bool) 처럼 대문에 카멜 케이스를 사용하여 이름을 지어준다, 프로퍼티와 메서드는 소문자 카멜케이스를 사용하여 이름을 지어준다
* 구조체 정의를 마친 후, 인스턴스를 생성하고 초기화하고자 할 때는 기본적으로 생성되는 멤버와이즈 이니셜라이저를 사용한다, 구조체에 기본 생성된 이니셜라이저의 매개변수는 구조체의 프로퍼티 이름으로 자동 지정된다
* 인스턴스가 생성되고 초기화된 후 프로퍼티 값에 접근하고 싶다면 마침표(.) 를 사용하면 된다, 구조체를 let 으로 선언하면 인스턴스 내부의 프로퍼티 값을 변경할 수 없고, 변수 var로 선언하면 내부의 프로퍼티가 var로 선언된 경우에 값을 변경해줄 수 있다
* 스위프트의 클래스는 부모클래스가 없더라도 상속 없이 단독으로 정의가 가능하다
* 상속을 받을 때는 클래스 이름 뒤에 : 을 써주고 부모클래스 이름을 명시한다
* 클래스를 정의한 후, 인스턴스를 생성하고 초기화하고자 할 때는 기본적인 이니셜라이저를 사용한다
* 인스턴스가 생성되고 초기화된 후 (이니셜라이즈된 후 ) 프로퍼티 값에 접근하고 싶다면 마침표 (.)를 사용하면 된다, 구조체와는 다르게 클래스의 인스턴스는 참조 타입이므로 클래스의 인스턴스를 상수 let으로 선언해도 내부 프로퍼티 값을 변경할 수 있다
* 클래스의 인스턴스는 참조 타입이므로 더는 참조할 필요가 없을 때 메모리에서 해제 되는데 이 과정을 소멸이라고 한다, 소멸하기 직전 deinit라는 메서드가 호출된다
* 클래스 내부에 deinit 메서드를 구현해주면 소멸되기 직전 deist 메서드가 호출, 이렇게 호출되는 deist 메서드는 디이니셜라이저 (deinitializer) 라고 부릅니다
* deinit 메서드는 클래스당 하나만 구현할 수 있으며, 매개변수와 반환 값을 가질 수 없다, deist 메서드는 매개변수를 위한 소괄호도 적어주지 않는다
* 보통 deist 메서드에는 인스턴스가 메모리에서 해제되기 직전에 처리할 코드를 넣어준다, 인스턴스 소멸 전에 데이터를 저장한다거나 다른 객체에 인스턴스 소멸을 알려야 할 때는 특히 deinit 메서드를 구현해야 한다

#### 구조체와 클래스의 차이
* 공통점 ->
* 값을 저장하기 위해 프로퍼티를 정의할 수 있다
* 기능 실행을 위해 메서드를 정의할 수 있다
* 서브스크립트 문법을 통해 구조체 또는 클래스가 갖는 값 (프로퍼티)에 접근하도록 서브스크립트를 정의할 수 있다
* 초기화될 때의 상태를 지정하기 위해 이니셜라이저를 정의할 수 있다
* 초기구현과 더불어 새로운 기능 추가를 위해 익스텐션을 통해 확장할 수 있다
* 특정 기능을 실행하기 위해 특정 프로토콜을 준수할 수 있다

* 차이점 ->
* 구조체는 상속할 수 없다
* 타입캐스팅은 클래스의 인스턴스에만 허용
* 디이니셜라이저는 클래스의 인스턴스에만 활용할 수 있다
* 참조 횟수 계산 (Reference Counting) 은 클래스의 인스턴스에만 적용된다
* 이 두 타입을 구분 짓는 가장 큰 차이점은 값 타입과 참조 타입이라는 점

* 구조체는 값 타입이고 클래스는 참조 타입이다, 값 타입과 참조 타입의 가장 큰 차이는 무엇이 전달되느냐이다, 예를 들어 어떤 함수의 전달인자로 값 타입의 값을 넘긴다면 전달될 값이 복사되어 전달된다, 그러나 참조 타입이 전달인자로 전달될 때는 값을 복사하지 않고 참조 (주소) 가 전달 된다
* 함수의 전달인자로 넘길 때도 참조가 전달되며 다른 변수 또는 상수에 할당될 때도 마찬가지로 참조가 할당된다
* 값 타입의 데이터를 함수의 전달인자로 전달하면 메모리에 전달인자를 위한 인스턴스가 새로 생성된다, 생성된 새 인스턴스에는 전달하려는 값이 복사되어 들어간다
* 반면 참조 타입의 데이터는 전달인자로 전달할 때 기존 인스턴스의 참조를 전달하므로 새로운 인스턴스가 아닌 기존의 인스턴스 참조를 전달 한다, 함수의 전달인자뿐만 아니라 새로운 변수에 할당될 때 또한 마찬가지이다
* 클래스의 인스턴스끼리 참조가 같은지 확인할 때는 식별 연산자 (Identity Operatoers)를 사용한다
* 기본 데이터 타입은 모두 값 타입이다, 전달인자를 통해 데이터를 전달하면 모두 값이 복사되어 전달될 뿐, 함수 내부에서 아무리 전달된 값을 변경해도 기존의 변수나 상수에는 전혀 영향을 미치지 못한다

* 구조체를 사용하면 더 좋을 때 ->
* 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
* 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때
* 구조체에 저장된 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때
* 다른 타입으로부터 상속받거나 자신을 상속할 필요가 없을 때