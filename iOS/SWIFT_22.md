# SWIFT_22
## 제네릭
* 제네릭을 이용해 코드를 구현하면 어떤 타입에도 유연하게 대응할 수 있다
* 또한 제네릭으로 구현한 기능과 타입은 재사용하기도 쉽고, 코드의 중복을 줄일 수 있기에 깔끔하고 추상적인 표현이 가능하다
* Array, Dictionary, Set 등의 타입은 모두 제네릭 컬렉션이다
* Int, String 타입을 요소로 갖는 배열을 만들거나 그 외의 어떤 타입도 배열을 요소로 가질 수 있었던 것은 모두 제네릭 덕분이다
* Any 타입을 사용하면 어떤 값이 들어있을지 모를 수 있고 Any 타입의 inout 매개변수를 통해 전달될 전달인자의 타입은 무조건 Any로 전달되어야 하는 문제점이 발생한다

### 제네릭 함수
* swapTwoValue 와 같은 기능을 실행하는 더 안전한 함수인 swap 을 사용하는 것을 권한다, 이 함수를 사용하는 것이 따로 값 교환 함수를 구현하여 사용하는 것보다 안전하다
* 플레이스홀더 = T , 플레이스홀더는 타입의 종류를 알려주지 않지만 말 그대로 어떤 타입이라는 것은 알려준다, Int 타입의 변수가 전달인자로 전달되었다면 T는 Int로, String 타입이였다면 T는 String 이 된다
* T가 플레이스홀더로 사용되기 때문에 스위프트 컴파일러는 함수의 문법을 검사할 때, T의 실제 타입을 신경쓰지 않는다

### 제네릭 타입
* 제네릭 타입을 구현하면 상요자정의 타입인 구조체, 클래스, 열거형 등이 어떤 타입과도 동작할 수 있다
* Stack = 순서가 있는 값들의 모음, 컬렉션의 끝 부분에서만 요소를 추가하고 삭제할 수 있다, 추가를 Push, 삭제를 Pop

### 제네릭 타입 확장
* 익스텐션을 통해 제네릭을 사용하는 타입에 기능을 추가하고자 한다면 익스텐션 정의에 타입 매개변수를 명시하지 않아야 한다, 대신 원래의 제네릭 정의에 명시한 타입 매개변수를 익스텐션에서 사용할 수 있다
 
### 타입 제약
* 타입 매개변수 자리에 사용할 실제 타입이 특정 클래스를 상속 받은 타입이어야 한다든지, 특정 프로토콜을 준수하는 타입이어야 한다는 등의 제약을 둘 수 있다
* 타입 제약은 클래스 타입 또는 프로토콜로만 줄 수 있다, 즉 열거형, 구조체 등의 타입은 타입 제약의 타입으로 사용할 수 없다
* 제네릭 타입에 제약을 주고 싶으면 타입 매개변수 뒤에 콜론을 붙인 후 원하는 클래스 타입 또는 프로토콜을 명시하면 된다
* 여러 제약을 추가하고 싶다면 콤마로 구분하는 것이 아니라 where 절을 사용한다

### 프로토콜의 연관 타입
* 연관 타입은 프로토콜에서 사용할 수 있는 플레이스홀더 이름이다, 즉 제네릭에서는 어떤 타입이 들어올지 모를 때, 타입 매개변수를 통해 종류는 알 수 없지만, 어떤 타입이 여기에  쓰일 것이다 라고 표현해주었다면 연관 타입은 타입 매개변수의 그 역할을 프로토콜에서 실행할 수 있도록 만들어진 기능이다
* 프로토콜 연관 타입에 대응하여 실제 타입을 사용할 수도 있지만, 제네릭 타입에서는 연관 타입과 타입 매개변수를 대응시킬 수도 있다

### 제네릭 서브스크립트
* 제네릭 함수를 구현할 수 있었던 것처럼 서브스크립트도 제네릭을 활용하여 타입에 큰 제한 없이 유연하게 구현할 수 있다, 물론 타입 제약을 사용하여 제네릭을 활용하는 타입에 제약을 줄 수도 있다