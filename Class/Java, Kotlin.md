# Java, Kotlin
## 블록
* 장점 : 불필요한 CPU를 점유하지 않는다 
* 단점: 이벤트가 발생하기 전까지 아무것도 수행할 수 없다
* 블록 논 블록의 차이는 이벤트에 대해 스레드나 프로세스가 잠을 자는지 안 자는지의 차이

## 동기  
* 자신이 직접 수행한다, 함수의 반환 값이나 완료를 통해 그 시점을 알 수 있다 
* 순서 제어가 쉽다

## 비동기 
* 별도의 스레드나 프로세스를 통해 일을 처리한다
* 완료 시점을 알 수 없다 그러므로 콜백을 써야한다
* 차이 : 순서를 알 수 없다
* 장점 : 병행성

* 대부분의 코드는 call by value 로 변경해야 한다
* intptr_t
* detach => 사용하지 않으면 누수가 발생할 수 있다
* 스레드가 관여하는 것들은 mutex 를 꼭 해줘야한다

* DTO = Data Transfer Object
* DO = Data Object
* VO = Value Object
* DAO = Database Access Object
* => Model
* 데이터를 교환하거나 저장하기 위한 목적의 클래스

* OR Mapping => Object Relational - DAO
* overhead 가 있어서 사용할 수 없었다
* 인터페이스나 추상 클래스에 의존 하는 것이 약한 결합
* 특정한 객체에 의존 하는 것이 강한 결합

### 데이터를 담고 있는 클래스의 3가지 특징
1. toString()
2. 비교 (equals)
3. Map (HashMap) - HashCode

### Heap 에 해시코드 값이 저장된다
* 해시 - 버킷의 크기가 무한정하지 않다 -> 다른 값이여도 동일한 해시 값이 나올 수 있다 -> 충돌 
* 해시코드를 사용할려면 해시코드와 이퀄스를 둘다 오버라이드 해줘야한다

### 해결 방법
* 선형 탐색법
* 이중 해시법
* 연결법 (가장 많이 쓰인다) 

### 타입 체크 하는 2가지 방법
* instanceOf - is-a 관계
* class 타입 비교 - 오로지 타입만 비교

* 레퍼런스 비교 => equals
* 프리미티브 비교 => ==

* null point exception 을 항상 고려해야한다

* Objects.equals() => null을 체크하는 메소드

* Lombok 

* Treemap -> comparable , compare 을 사용해야 한다

* Json => 문자열 형식의 데이터이다, 로깅하기가 좋다, 하지만 비효율적인 측면이 있다

### 프로토콜버퍼 => Protocol Buffers (Google)
* 다양한 언어를 지원한다

* snappy

* gRPC  (Remote Procedure Call) -> 모든 언어
* RMI (Remote Method Invoke) -> 자바에서만 쓸 수 있다

* proxy <-> stub (실제 기능을 가지고 있는 )

### 코틀린의 3가지 장점
* 간결성 : 자바 언어의 보일러플레이트를 효과적으로 제거한다
* 안전성 : Null 참조로 인한 문제 , Nullable : Null 체크를 컴파일러가 체크한다
* 상호운용성 : Java <-> Kotlin, Java의 모든 기능을 코틀린에서 아무런 설정없이 사용할 수 있다

* 코틀린은 전역 함수를 지원한다
* 코틀린은 함수형 언어이다
* 순수 함수이다 => 입력이 동일하면 결과도 동일하다
* 암묵적으로 타입을 지정해준다
* 모든 타입은 객체다
* is 는 스마트 캐스트를 허용, reflection 은 불가능하다
* private - internal - protected - public
* 코틀린의 모든 클래스와 메소드는 final이다 (오버라이딩이 불가능하다)
* open 클래스만 상속과 오버라이딩을 가능하게 만들어 준다
* 상속을 할 때는 부모의 인자를 그대로 받아야 한다
* interface 는 동작적인 부분에 포커스를 맞춘다, 하지만 새로운 기능을 추가하기는 어렵다
* abstract 는 공통적인 속성이나 동작을 미리 정해놓는다
* field 를 사용하려면 초기화 부분을 신경 써야 한다
* 캐스팅 할 때는 as 키워드를 사용해야 한다
* 코틀린은 중첩 클래스가 기본이다
* inner 클래스를 만들기 위해서는 inner 키워드가 필수이다
* Nested Class : static class Memento : Inner Class 보다는 Nested Class를 만들어야 한다
* Inner Class : class Memento : 외부 클래스의 모든 필드와 메소드에 접근할 수 있다, 외부 클래스(외부 객체)의 참조가 암묵적으로 존재한다
* when 은 자바의 switch 를 대체한다
* 봉인된 클래스 : 라이브러리 설계자 이외에 상속을 사용할 수 없도록 하고 싶다
* sealed : 봉인된 클래스, 같은 파일에서만 상속을 허용한다, 소프트 키워드
* 객체를 생성하는 것은 비용이 크다, 참조를 비교하는 것은 비교적 훨씬 쉽다
* Buffer 와 build 의 차이점 : 동기화는 개발자가 하게 만들어야 한다

### 상수
* Runtime 상수 : 메모리가 존재하지만 runtime 시에 다른 것을 가리키지 못하도록 하는것 (변수가 잡혀있다) readonly (C#), const (C++), cal (Kotlin)
* Compile 상수 : const (C#), const, constexpr (C++), const val (Kotlin)

### when 과 switch 의 차이점
* Statment (문) vs Expression (식)
* 문 : 결과가 존재하지 않는다
* 식 : 결과가 존재한다
* if 나 when을 코틀린에서는 식으로 표현한다
* if 보다는 when 을 사용하는게 좋다

### 확장 함수
* 상속은 깨지기 쉬운 기반 클래스의 문제가 있다. 부모의 구현을 물려받기 때문에 부모구현 변경이 자식 클래스에도 영향을 끼친다. 그래서 설계를 제대로 하거나 상속을 금지해야 한다 
* 수직 확장: 상속을 통한 확장
* 수평 확장: 확장 함수, 프로퍼티
* 확장 함수는 코틀린의 라이브러리를 이루는 핵심이다. C#, Swift, Obj-c에도 있다
* 확장 함수는 철저한 팀 간의 합의에 의해서 되어야 한다. 전체적인 영향을 미치기 때문에확장 함수를 프라이빗으로 만들어야 한다. 그 파일에서만 접근 가능하도록 하기 위해서이다

* 전역 함수는 전역의 네임스페이스를 더럽힌다. (심볼이 전역적으로 하나만 존재해야 하기 때문에) 그래서 자바는 없다
* 자바는 컴파일 타임에 타입 체크만 한다. 컬렉션 자체가 Any 타입으로 되어 있다. 코드를 생성하는 것이 아니다, 그래서 자바에서는 제네릭을 추상적으로 사용했을 때의 이점(라이브러리로서 누리는)을 쓸 수 없었다. 코틀린에서는 레이파이드 문법을 만들어서 이걸 할 수 있게 한다
