# 0628 수업
* 함수를 인자로 받는 함수를 사용하는 이유 -> 변하지 않는 알고리즘에서 변해야 하는 정책을 인자로 분리하는 설계 방식

### 함수를 반환하는 함수
* 함수를 생성하는 목적으로 사용한다
* 함수를 실행 시간에 만들 수 있다
* 정적 = 컴파일 타임
* 동적 = 런타임
* 함수형 프로그래밍은 레고와 같다 다양한 결과를 만들어 낼 수 있다
* 다른 함수의 인자(변수)를 암묵적으로 사용할 수 있는 것 => 클로저
* 람다
* 람다와 클로저를 잘 사용하면 함수를 더 짧고 간결하게 만들 수 있다

### 확장 함수
* 문법 설탕 : 편리하게 만드는 기능, 더 직관적인 표현이 가능하게 만들어 주는 것
* 기존 클래스의 코드를 수정하지 않고 새로운 기능을 추가하는 기능
* 동일한 시그니처를 가진 동일한 함수는 공존이 불가능하다 (이름 충돌) -> 패키지가 분리되면 상관이 없다
* 일반 함수를 메소드처럼 사용하게 만들어 주는 방법
* 가독성을 높히기 위해 사용한다
* 코틀린 라이브러리의 핵심 , 모든 라이브러리는 확장함수로 되어있다
* 상속을 통해 기능을 확장하는 것이 아니라 인터페이스의 부분을 확장하는 기법

* 수직 확장 : 상속을 이용한 기능의 확장, 상속에 대한 문제점을 가지고 있다 상속을 위해 만든게 아니라면 잘 작동하지 않는다
* 수직 확장 = 부모의 문제가 자식한테도 연결이 될 수도 있어서 문제가 발생 할 수 있다
* 수평 확장 = extension, 범용적이지 않은 기능도 포함한다면 좋지 않다, 범용적인 기능만 포함해야 한다

### 함수와 메소드의 차이점
* 메소드 : 특정한 객체의 첫번째 this를 암묵적으로 전달한다
* 내가 원하는 타입을 하나로 묶어둔 타입 : 캡슐화
* C ++ 은 메소드 부분을 thiscall이라 부른다

* 문자열에 관해서 트림(trim)이라는 부분을 체크해줘야한다
* isBlank

### 중위 함수
* 인자가 하나인 메소드에 대해서, 중위 표현을 허용하는 문법
* infix function

### 커링
* 다중 인수를 받는 함수를 단일 인수를 갖는 함수들의 함수열로 바꾸는 것을 의미한다
* 함수 실행을 지연할 수 있다
* 부분 적용 - 특정 인자를 특정 값으로 고정할 수 있다
* 연산자 - > 는 오른쪽 부터 연산이 되므로 ()를 생략할 수 있다

### 로깅
* 기록하는 것
* 링 버퍼 = 버퍼의 용량이 초과되면 처음부터 다시 쓰는 것

### 함수 합성
* 기존 함수를 합성해서 새로운 함수를 만드는 기법
* bind : 어떠한 타입이 될지 이미 결정된 것