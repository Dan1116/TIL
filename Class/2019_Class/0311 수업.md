# 0311 수업
## goto
1. 중첩 루프를 빠져나갈 때
2. 에러 로직의 중복을 없앨 수 있다

## 포인터 
* Call by reference
* 함수에서 전달받은 인자의 값을 변경 할 수 없어서 사용한다
* 주소를 담을 수 있는 타입

* Call by value => 전달 받은 인자의 값을 변경할 수 없다
* C 언어는 인자를 전달할 때, 복사를 수행한다
* -> 값을 전달하지 말고, 주소를 전달해서 주소의 값을 변경하면 된다

## 함수 포인터
* 함수를 가르키는 포인터

### 함수의 타입
* 함수의 시그니쳐에 의해서 결정된다.
* 함수의 인자의 개수와 인자의 타입과 반환 타입으로 결정된다.

### 변수: 런타임에 변경되는 값.
* 실행 시간에 어떤 함수를 호출할지 결정하고 싶다.
* 함수의 이름은 함수 포인터로 해석된다.
* add => &add
* sub => &sub

## C 언어의 배열
* 제약: 배열은 배열의 첫번째 원소의 시작 주소로 전달하기 때문에,
* 함수에서 배열의 크기를 알 수 없다.
* => 배열을 전달하는 함수를 설계할 때, 배열의 길이를 추가적으로 전달해야 한다.

* int[3][4]
* => arr은 3개 짜리 배열이다.
* => 하나의 원소가 int[4]인…

* arr: 배열의 이름은 배열의 첫번째 원소의 시작 주소로 해석된다.
* &arr[0]
* arr[0]: int[4]
* &arr[0]: int(*)[4]

### 포인터를 배열의 연산으로 다룰 수 있다.
* arr[N]
* => *(arr + [N])
* &arr[0]
* => &*(arr + 0)
* => &*: 상쇄
* => (arr + 0)
* => arr

### C 언어에서 타입을 보는 방법
* int i;
* => 이름을 뺀 나머지가 타입이다.
* => int

* int arr[3]
* => int[3]
* => 배열의 이름은 배열의 첫번째 원소의 시작 주소로 해석된다.

### Decay
* => Decay 예외
* 1) sizeof 연산
* 2) & 연산

## void 포인터 
* void*: offset 정보가 없다.
* arr + size * i

* GCC는 void* 에 대한 연산을 char*로 취급해준다.
* => 1 바이트 연산을 지원한다.
* +/- 연산에 대해서만 지원한다.