# 0313 수업
* malloc / free => Java 에서는 new
* 더미 노드를 사용하면 코드를 일반화 시킬 수 있다
* 컴파일 하면 오브젝트 파일이 생성, 모든 오브젝트 파일을 링킹하면 실행 파일이 완성된다
* 라이브러리는 무조건 앞에 lib를 붙여야 한다
* C 언어는 void*를 다른 타입으로 암묵적인 변환을 허용한다.

* 일반적으로 gcc 컴파일 할때, C 언어 표준 라이브러리에 대한 암묵적인 링킹이 수행된다
* => printf, scanf …
* math 라이브러리는 암묵적인 링킹이 수행되지 않는다.
* => 명시적인 링킹을 수행해야 한다.

* libadd.so => 위의 파일 안에서 add 함수를 찾아서 호출하는 기법.

## 라이브러리
### 정적 라이브러리
* Linux: .a
* Windows: .lib
* : 실행 파일안에 함수의 구현이 포함된다.
* 장점 : 추가적인 로드가 필요없다.
* 단점 :실행 파일의 크기가 커진다, 라이브러리가 변경되면, 컴파일을 다시 해야 한다, 배포가 쉽다
* $ ar rcv libadd.a add.o …
* $ gcc main.o -ladd -L.

### 동적 라이브러리
* Linux: .so(shared object)
* Windows: .dll(dynamic loading library)
* : 실행 중에 필요한 라이브러리를 동적으로 메모리에 로드해서 사용한다.
* => 실행 파일안에 함수의 구현이 존재하지 않는다.
* 장점 : 실행 파일의 크기가 크지 않다, 라이브러리가 변경되어도 다시 컴파일 할 필요가 없다, 실행 중에 동적라이브러리를 로드할 수 있다.
* 단점 : 추가적인 로드가 필요하다
* $ gcc add.o -shared -fpic -o libadd.so
* $ LD_LIBRARY_PATH=. ./a.out

## 선형 자료구조
### 배열 - 연속적인 메모리
* 장점 : 임의접근이 용이하다 (RandomAccess)
* 단점 : 중간 삽입과 삭제시 처리가 힘들다

### 연결 리스트 
* 장점 : 삽입 삭제 시 시간이 동일하다
* 단점 : 임의 접근이 불가능하다

## 노드
* 데이터와 노드가 별도로 존재하면, 관리하기 어렵다
* head를 포인터로 처리하지 말고, node 로 처리하자
* head를 함수에서 바로 접근해서 처리하도록 만들면, 프로그램 안에서 오직 하나의 리스트만 만들 수 있다
* 연결 리스트의 끝을 NULL로 표현한다면, NullPointer 참조로 인해 프로그램이 비정상 종료할 수 있다
* 해드와 테일을 동시에 => 환형 연결리스트
* 지역 변수도 연결리스트로 전역 변수도 연결리스트로 엮어 있어야 한다 => 메모리의 할당 로직을 삽입로직에서 분리해야 한다

## 해더 파일
* 중복 포함을 방지해야 한다
* 라이브러리의 설계자는 반드시 제공하는 모든 함수에 대한 선언을 제공해야 한다 => 헤더 파일

## Storage Class (기억 부류)
### data 
* => 실행 파일의 용량이 커진다. 
* 전역 변수, 내부 정적 변수 => 프로그램 종료까지 유효한 영역

###  stack 
* 지역 변수 => 함수가 시작할때 생성 종료할때 사라진다, 메모리 할당과 혜지의 비용이 0

### heap
* 개발자가 원하는 시점에 생성하고, 파괴할 수 있다 =>  malloc / free
* => 할당과 해지의 비용이 크다 