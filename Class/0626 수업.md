# 0626 수업
* 익명 함수
* 함수의 이름 앞에 on이라는게 붙으면 콜백의 의미를 가진다
* 콜백 함수 = 원래는 메소드를 능동적으로 호출하지만, 자동으로 메소드를 호출하는 함수
* Nullable 타입은 사용하기 전에 반드시 null 체크를 해야한다
* var, val 을 잘 활용해야 한다
* 간결한 널 참조 연산을 제공한다 (ex)  activity?.close() )
* 트렌스 파일링 : 자바로 번역 하는 것
* 항상 호출에 대한 순서는 위에서부터 아래로 작동 한다

### 위임
* 재사용 
* 1. 상속 : 편하다, 부모의 것들을 자유롭게 사용할 수 있다, 단점은 부모가 변경 될 경우 자식이 영향을 받을 수 있다
* 2. 포함 (위임) : by 키워드로 위임이 가능하다
* 재사용은 상속보다 포함이 좋다

### by 위임
1. 클래스 위임 
2. 프로퍼티 위임 

* 프로퍼티 : 접근자 메소드를 자동으로 생성하는 기능
* 프로퍼티의 위임 getter setter 다른 객체가 대신 처리해 준다
* val : getter만 생성
* var : getter setter 둘 다 생성
* 배킹 필드 : 값을 저장한다면 생성된다
* 알고리즘은 동일한테 타입만 다를경우 제네릭으로 만들어야 한다
* 제네릭 : 타입을 인자로 받는 함수, 타입 파라미터
* 옵저버 : 관찰자 , 값에 대한 정보를 통보 받을 때 쓴다
* pull 모델 : 데이터를 능동적으로 꺼내 간다, 계속해서 주기적으로 확인한다 (불필요한 리소스, CPU를 사용한다)
* 옵저버, 관찰자 패턴 (push) : 내 값이 변경되면 변경되었다고 알려주는 형식 
* wildcard 문법 : *
* operator : 연산자 오버로딩에 대한 키워드 (자바는 존재하지 않는다), 사용하기 어렵지만 잘 사용하면 훨씬 더 직관적인 코드를 만들 수 있다
* 연산자 오버로딩 : 약속된 연산자를 객체에 대해서 수행하였을 경우, 호출되는 메소드를 정의하는 방법 -> [] 
* 구조 분해 선언 문법

## 함수형 프로그래밍
* 함수형 프로그래밍 언어 : Haskell, Lisp, Erlang 
* 코틀린은 함수형 프로그래밍을 지원한다 -> 함수를 일급 시민(First citizen)으로 취급한다

### 일급 시민
* 함수를 변수에 담을 수 있어야 한다
* 함수를 인자로 전달할 수 있어야 한다
* 함수를 반환할 수 있어야 한다
* 함수를 실행 시간에 생성할 수 있어야 한다
* 익명으로 함수를 생성할 수 있어야 한다

* 단일 표현식 함수 : 타입 추론이 가능하다
* 함수의 타입 : 인자와 반환 타입에 의해 결정된다 ( 함수의 시그니처에 의해 결정된다 )
* 시그니처 : 함수의 인자와 타입과 개수, 반환 타입
* KFunction은 이제 사용할 수 없다
* (Int, String ) -> Unit 이런 표현식을 사용한다
* typealias 
* 널러블 타입일때는 invoke 를 호출해야 한다

### 고차 함수
* 함수를 인자로 받거나 함수를 반환하는 함수
* High Order Function
* 함수를 인자로 받는 함수를 왜 사용하는가?

### List
* Immutable - List
* Mutable - MutableList

### Map
* Immutable - Map
* Mutable - MutableMap

* 동작 파라미터화 : 정책을 담은 인터페이스를 만드는 방법
* object 선언 : 객체를 하나를 공유하도록 생성할 수 있다, 매번 선언 할 필요가 없어진다
* 람다 - 실행 가능한 코드 블록을 참조하는 기술
* 타입 추론이 가능하다
* 함수의 마지막 인자가 함수인 경우, 람다 블록을 인자 괄호의 밖에 작성할 수 있다
* it 은 유용하지만 좋은 표현은 아니다 , 중첩된 it은 가릴 수 있으므로 확실한 상황이 아니라면 사용하지 않는 게 좋다
* 자바는 인터페이스중에 하나의 추상 메소드를 가지고 있는 경우 람다로 표현할 수 있다