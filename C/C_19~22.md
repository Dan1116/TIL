# C_19~22
## 다차원배열
* 2차원 배열과 3차원 배열, 이 둘을 가리켜 다차원 배열이라 한다
* 2차원 배열도 메모리 공간에서는 1차원의 구조를 갖는다
* 2차원 배열은 길이가 동일한 1차원 배열을 둘 이상 묶어놓은 것이다
* 배열의 이름은 시작위치를 의미하고, 인덱스 값을 이용해서 시작위치로부터 떨어져 있는 거리를 계산하게 된다

### 2차원 배열의 초기화
	* 1.하나의 중괄호 안에 초기화 리스트를 구성하는 방식
	* 2. 행 단위 초기화 방식
	* 3. 배열의 길이 생략

## 배열을 함수의 인자로 전달
* 배열의 주소 값을 전달할 뿐이다
* 매개변수로 배열이 선언되는 것은 허용되지 않는다
* 문자열은 상수의 형태로 메모리 공간에 할당이 되고, 할당된 메모리 공간의 주소 값이 전달 될 뿐이다
* 매개변수 선언에서는 배열의 길이를 나타내는 숫자만 생략하면 된다
* 매개변수의 이름을 배열의 이름처럼 사용할 수 있다
* const 키워드는 선언된 변수에 저장된 값을 변경하지 않겠다는 것을 표현하는 키워드이다
* 함수 안에서는 인자로 전달된 배열의 주소 값만 가지고, 배열의 길이를 계산할 수 없다
* 함수의 인자로 배열의 주소 값을 전달할 때에는 배열의 길이도 미리 계산해서 더불어 전달해야 한다

### 2차원 배열을 함수에 전달하기
* 2차원 배열의 매개변수 선언에 있어서 세로의 길이는 중요한 요소가 아니다, 중요한 것은 가로의 길이다
* 배열 요소를 이루는 변수의 자료형과 가로의 길이에 따라서 매개변수의 선언방식이 결정되기 때문이다
* 함수 내에서는 인자로 전달된 배열의 크기 계산이 불가능하므로 배열의 가로, 세로 길이도 당연히 계산할 수 없다
* 2차원 배열의 매개변수 선언 시 반드시 가로의 길이를 명시해서 선언해야 한다, 가로의 길이를 명시하면 몇 바이트가 증가하는지 알 수 있으므로 명시해야 한다
* sizeof 연산자를 이용해서 배열의 길이를 계산하는 이유는 배열의 길이에 상관없이 함수의 호출문장을 구성할 수 있기 때문이다

### 3차원 배열을 함수에 전달하기
* 2차원 배열을 함수에 전달하는 방법과 별반 다르지 않다, 가장 첫 번째 인덱스 값만 생략 하면 된다

## 포인터
* 포인터는 주소 값을 담고 있는 변수 또는 상수 이다
* 포인터 변수도 변수이기 때문에 값의 변경이 가능하다 (포인터가 가리키는 대상이 바뀌었을 뿐이다)

### 메모리의 주소체계
* 하나의 주소 값은 1바이트 크기의 메모리 공간을 표현한다
* 메모리 공간의 크기에 따라서 주소 값의 바이트 수가 결정된다, 주소 값의 바이트 수가 크면 클수록 보다 넓은 메모리 공간에 주소 값을 부여할 수 있다
* 메모리 공간을 실제로 활용하는 주체는 운영체제이다, 그리고 운영체제는 메모리 공간을 관리하기 위해서 주소 값을 할당한다

### 포인터 변수 선언하기
* 주소 값의 저장을 위해 선언되는 변수를 가리켜 포인터 변수라 한다
* 변수의 주소 값을 저장하기 위한 포인터 변수의 선언은 *하나만 중간에 추가해주면 된다
	* 예) TYPE * ptr, TYPE* ptr, TYPE *ptr
* 다양한 형태의 포인터의 크기는 모두 4바이트로 동일하다, 상수이건 변수이건 항상 4바이트이다

### 주소 값을 얻기 위해 사용되는 & 연산자
* & 연산자가 단항 연산자로 사용이 되면, 피연산자의 주소 값을 반환하는 기능의 연산자가 된다

### 포인터 형 (Type) 과 * 연산자
* int * => int 형 포인터
* char * => char 형 포인터
* double * => double 형 포인터

### 포인터와 함께 사용되는 * 연산자 (간접 참조 연산자)
* 연산자의 의미는 피연산자에 따라서 결정된다
* 이항 연산자로 사용하면 * 은 곱셈을 의미하지만, 단항 연산자로 사용 되면 포인터가 가리키는 메모리 공간의 접근을 의미한다

### int형 변수에 주소 값을 저장하면 안 되는 이유
* int 형 포인터를 통해서 포인터가 가리키는 변수에 값을 저장할 때는 무조건 4바이트 정수의 형태로 저장이 된다
* 포인터의 형은 포인터가 가리키는 메모리 공간의 데이터 저장 및 참조 방식을 결정한다
* 포인터가 가리키는 대상이 무엇이던 간에 포인터를 이용해서 값을 저장할 때는 포인터 형에 따라서 저장 방식이 결정된다
* int 형 변수에는 해당 주소의 메모리 공간에 대한 정보가 없기 때문에 메모리 참조를 위한 * 연산이 불가하다

### 초기화되지 않은 포인터가 어디를 가리킬지는 아무도 모른다
* 지역변수는 선언과 동시에 초기화하지 않으면 쓰레기 값으로 초기화 된다, 포인터 변수도 지역변수의 형태로 선언하고 초기화하지 않으면 쓰레기 값으로 초기화 된다
* 문제는 이 쓰레기 값을 주소 값으로 인식해서 연산하는 경우에 발생한다

### 널 (NULL) 포인터
* 변수는 이후의 필요를 예측해서 미리 선언해 두기도 한다, 이는 포인터 변수도 마찬가지인데, 이러한 포인터 변수는 0으로 초기화를 시켜두는 것이 좋다
* 0은 특별한 의미를 담고 있는 주소 값이기 때문이다
* 아무 곳에 대한 주소 값도 가지고 있지 않다, 아무 곳도 가리키고 있지 않다 라는 뜻이다

### & 연산을 통해 얻은 주소 값은 단순한 숫자가 아니다
* & 연산의 결과를 통해서 얻은 주소 값은 그 자체로도 포인터이다, 즉 상수 형태의 포인터로 인식을 해야한다
* 포인터는 주소 값을 지니며, 더불어 참조하는 대상의 자료형 정보도 지니는 변수나 상수를 의미한다

### 포인터의 형 변환
* 포인터의 형 변환은 대부분 자동으로 이뤄지지만, 필요하다면 형 변환 연산자를 이용해서 강제로 변환을 할 수도 있다

### 문자열 배열과 문자열을 참조하는 포인터
* C 언어에서 문자열을 표현하는 방식은 크게 두 가지로 나뉜다
	* 1. 변수 형태로 표현하는 방식
	* 2. 상수 형태로 표현하는 방식
* 상수 형태로 문자열을 표현하는 방식은 char형 포인터와도 관계가 깊다
* 배열을 이용해서 선언하는 문자열은 변수 형태의 문자열이다
* 포인터를 이용해서 상수 형태의 문자열을 참조하는 것도 가능하다
* 포인터를 이용해서 문자열을 상수화 하는 것도 가능하다