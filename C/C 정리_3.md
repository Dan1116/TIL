# C 정리_3
# 포인터의 개념
## 주소값의 이해
* 데이터의 주소값이란 해당 데이터가 저장된 메모리의 시작 주소를 의미합니다.
* C언어에서는 이러한 주소값을 1바이트 크기의 메모리 공간으로 나누어 표현합니다.
* 예를 들어, int형 데이터는 4바이트의 크기를 가지지만, int형 데이터의 주소값은 시작 주소 1바이트만을 가리킵니다.
 
![](C%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5_3/img_c_address.png)

## 포인터
* C언어에서 포인터(pointer)란 메모리의 주소값을 저장하는 변수이며, 포인터 변수라고도 부릅니다.
* char형 변수가 문자를 저장하고, int형 변수가 정수를 저장하는 것처럼포인터는 주소값을 저장합니다.

![](C%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5_3/img_c_pointer_memory.png)

## 주소 연산자(&)
* 주소 연산자는 변수의 이름 앞에 사용하여, 해당 변수의 주소값을 반환합니다.
* ‘&’기호는 앰퍼샌드(ampersand)라고 읽으며, 번지 연산자라고도 불립니다.

## 참조 연산자(*)
* 참조 연산자는 포인터의 이름이나 주소 앞에 사용하여, 포인터에 가리키는 주소에 저장된값을 반환합니다.
* C언어에서 ‘*’기호는 사용하는 위치에 따라 다양한 용도로 사용됩니다.
* 이항 연산자로 사용하면 곱셈 연산으로 사용되며, 포인터의 선언시나 메모리에 접근할 때도 사용됩니다.

## 포인터의 선언
* C언어에서 포인터는 다음 문법에 따라 선언합니다.
* 문법 => 타입 * 포인터 이름;
* 타입이란 포인터가 가리키고자 하는 변수의 타입을 명시합니다.
* 포인터 이름은 포인터가 선언된 후에 포인터에 접근하기 위해 사용됩니다.
* 포인터를 선언한 후참조 연산자(*)를 사용하기 전에 포인터는 반드시 먼저 초기화되어야 합니다, 그렇지 않으면 의도하지 않은 메모리의 값을 변경하게 되기 때문입니다.
* 따라서 C 컴파일러는 초기화하지 않은 포인터에 참조 연산자를 사용하면오류를 발생시킵니다.
* 문법 => 타입*포인터이름=&변수이름;
* 또는
* 타입*포인터이름=주소값;

* int x=7;    변수의 선언
* int*ptr=&x;  포인터의 선언
* int*pptr=&ptr; 포인터의 참조

![](C%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5_3/img_c_pointer_reference.png)

## 포인터 연산
* 포인터는 값을 증가시키거나 감소시키는 등의 제한된 연산만을 할 수 있습니다.
* C언어의 포인터 연산에는 다음과 같은 규칙이 있습니다.
	1. 포인터끼리의 덧셈, 곱셈, 나눗셈은 아무런 의미가 없습니다.
	2. 포인터끼리의 뺄셈은 두 포인터 사이의 상대적 거리를 나타냅니다.
	3. 포인터에 정수를 더하거나 뺄 수는 있지만, 실수와의 연산은 허용하지 않습니다.
	4. 포인터끼리 대입하거나 비교할 수 있습니다.

## 인수 전달 방법
* 함수를 호출할 때에는 함수에 필요한 데이터를 인수(argument)로 전달해 줄 수 있습니다.
* 이렇게 함수에 인수를 전달하는 방법에는 크게 다음과 같이 두 가지 방법이 있습니다.
	1. 값에 의한 전달(call by value)
	2. 참조에 의한 전달(call by reference)

### 값에 의한 전달(call by value)
* 값에 의한 전달 방법은 인수로 전달되는 변수가 가지고 있는 값을 함수 내의 매개변수에 복사하는 방식입니다.
* 이렇게 복사된 값으로 초기화된 매개변수는 인수로 전달된 변수와는 완전히 별개의 변수가 됩니다.
* 따라서 함수 내에서의 매개변수 조작은 인수로 전달되는 변수에 아무런 영향을 미치지 않습니다.

### 참조에 의한 전달(call by reference)
* 참조에 의한 전달 방법은 인수로 변수의 값을 전달하는 것이 아닌, 해당 변수의 주소값을 전달합니다.
* 즉 함수의 매개변수에 인수로 전달된 변수의 원래 주소값을 저장하는 것입니다.
* 이 방식을 사용하면 인수로 전달된 변수의 값을 함수 내에서 변경할 수 있게 됩니다.

### 포인터의 포인터
* 포인터의 포인터란 포인터 변수를 가리키는 포인터를 의미합니다.
* 참조 연산자(*)를 두 번 사용하여 표현하며, 이중 포인터라고도 부릅니다.
* 다음 그림은 포인터와 포인터의 포인터와의 동작 상 차이점을 보여주고 있습니다.

![](C%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5_3/img_c_pointer_memory.png)![](C%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5_3/img_c_pointer_reference.png)

## void 포인터
* void 포인터는 일반적인 포인트 변수와는 달리 대상이 되는 데이터의 타입을 명시하지 않은 포인터입니다.
* 따라서 변수, 함수, 포인터 등 어떠한 값도 가리킬 수 있지만, 포인터 연산이나 메모리 참조와 같은 작업은 할 수 없습니다.
* 즉 void 포인터는 주소값을 저장하는 것 이외에는 아무것도 할 수 없는 포인터입니다.
* 또한, void 포인터를 사용할 때에는 반드시 먼저 사용하고자 하는 타입으로 명시적 타입 변환 작업을 거친 후에 사용해야 합니다.

## 함수 포인터(function pointer)
* 프로그램에서 정의된 함수는 프로그램이 실행될 때 모두 메인 메모리에 올라가게 됩니다.
* 이때 함수의 이름은 메모리에 올라간 함수의 시작 주소를 가리키는 포인터 상수(constant pointer)가 됩니다.
* 이렇게 함수의 시작 주소를 가리키는 포인터 상수를 함수 포인터(function pointer)라고 부릅니다.
* 함수 포인터의 포인터 타입은 함수의 반환값과 매개변수에 의해 결정됩니다.
* 즉 함수의 원형을 알아야만 해당함수에 맞는 함수 포인터를 만들 수 있습니다.
* 함수 포인터 사용시 연산자의 우선순위 때문에 반드시 *ptr_func부분을 괄호(())로 둘러싸야 합니다.

## 포인터와 배열의 관계
* 포인터와 배열은 매우 긴밀한 관계를 맺고 있으며, 어떤 부분에서는 서로를 대체할 수도 있습니다.
* 배열의 이름은 그 값을 변경할 수 없는 상수라는 점을 제외하면 포인터와 같습니다.
* 따라서 배열의 이름은 포인터 상수(constant pointer)입니다.
* 포인터 상수(constant pointer)란 포인터 변수가 가리키고 있는 주소 값을 변경할 수 없는 포인터를 의미하며, 상수 포인터(pointer to constant)란 상수를 가르키는 포인터를 의미합니다.

* arr이 배열의 이름이거나 포인터이고 n이 정수일 때, arr[n]==*(arr+n)
* 배열에 관계된 연산을 할 때는 언제나 배열의 크기를 넘어서는 접근을 하지 않도록 주의해야 합니다.
* 포인터 연산을 이용하여 계산하다가 배열의 크기를 넘어서는 접근을 하는 경우, C컴파일러는 어떠한 오류도 발생시키지 않습니다.
* 다만 잘못된 결과만을 반환하므로 C언어로 프로그래밍할 때에는 언제나 배열의 크기에도 주의해야 합니다.

## 포인터 배열
* 포인터 배열이란 배열요소로 포인터 변수를 가지는 배열을 의미합니다.
* 즉, 포인터 변수를 저장할 수 있는 배열을 의미합니다.

## 배열 포인터
* 배열 포인터란 배열을 가리킬 수 있는 포인터를 의미합니다.
* 앞서 배열의 이름은 그 값을 변경할 수 없는 상수라는 점을 제외하면 포인터와 같다고 했습니다.
* 이렇게 배열이름이 있는데도 따로 배열 포인터를 정의하여사용하는 이유는 2차원 이상의 배열을 가리킬 때 포인터를 통해 배열과 같은 인덱싱을 할 수 있도록 하기 위함입니다.
* 즉, 포인터를 배열처럼 사용하기 위해서 배열 포인터를 정의하여 사용합니다.
* 따라서 배열 포인터는 1차원 배열에서는 아무런 의미가 없으며, 2차원 이상의 배열에서만 의미를 가집니다.

## 포인터 배열과 배열 포인터의 구분
	1. int(*pArr)[3];
	2. int*pArr[3];

* 위의 예제 중에서 첫 번째는 int형 데이터를 저장할 수 있는 2차원 배열을 가리키는 배열 포인터입니다.
* 하지만 두 번째는 int형 데이터를 가리킬 수 있는 포인터 변수를 모아 놓은 배열을 가리키는 포인터 배열이 됩니다.
* 따라서 괄호의 유무가 중요하며, 포인터 배열과 배열 포인터 사이의 차이점을 정확히 이해하고 넘어가야 합니다.

### main() 함수의 인수 전달
* main() 함수는 프로그램이 실행되면 제일 먼저 자동으로 호출되는 함수입니다.
* 이러한 main() 함수도 함수이기 때문에 인수를 전달받을 수도 있고, 반환값을 가질 수도 있습니다.
* C언어의 main() 함수의첫 번째 인수는 int형 변수인 argc로 main() 함수에 인수로 전달되는 문자열의 개수를 명시합니다.
* 두 번째 인수는 char형 포인터 배열인 argv로 main() 함수에 인수로 전달된 각각의 문자열이 저장된 배열을 가리킵니다.

## 메모리의 구조
	1. 코드(code) 영역
	2. 데이터(data) 영역
	3. 스택(stack) 영역
	4. 힙(heap) 영역

![](C%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5_3/img_c_memory_structure.png)

## 코드(code) 영역
* 메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.
* CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

## 데이터(data) 영역
* 메모리의 데이터(data)영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.
* 데이터영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

## 스택(stack) 영역
* 메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.
* 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.
* 이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.
* 스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.
* 이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.
* 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.

## 힙(heap) 영역
* 메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’메모리 영역입니다.
* 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.
* 힙 영역은 메모리의 낮은주소에서 높은주소의 방향으로 할당됩니다.

## 스택 프레임(stack frame)
* 메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.
* 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.
* 함수가 호출되면 스택에는 함수의 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소값, 함수에서 선언된 지역 변수 등이 저장됩니다.
* 이렇게 스택 영역에 차례대로 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.
* 이러한 스택 프레임 덕분에 함수의 호출이 모두 끝난 뒤에, 해당 함수가 호출되기 이전 상태로 되돌아갈 수 있습니다.

# 메모리의 동적 할당(dynamic allocation)
* 데이터 영역과 스택 영역에 할당되는 메모리의 크기는 컴파일 타임(compile time)에 미리 결정됩니다.
* 하지만 힙 영역의 크기는프로그램이 실행되는 도중인 런 타임(run time)에 사용자가 직접 결정하게 됩니다.
* 이렇게 런 타임에 메모리를 할당받는 것을 메모리의 동적 할당(dynamic allocation)이라고 합니다.

## malloc( ) 함수
* malloc( ) 함수는 프로그램이 실행 중일 때 사용자가 직접 힙 영역에 메모리를 할당할 수 있게 해줍니다.
* malloc( ) 함수는 인수로 할당받고자 하는 메모리의 크기를 바이트 단위로 전달받습니다.
* 이 함수는 전달받은 메모리 크기에 맞고, 아직 할당되지 않은 적당한 블록을 찾습니다.
* 이렇게 찾은블록의 첫 번째 바이트를 가리키는주소값을 반환합니다.
* 힙 영역에 할당할 수 있는 적당한 블록이 없을 때에는 널 포인터를 반환합니다.
* 주소값을 반환받기 때문에힙 영역에 할당된 메모리 공간으로접근하려면 포인터를 사용해야 합니다.

## free( ) 함수
* free( ) 함수는 힙 영역에 할당받은 메모리 공간을 다시 운영체제로 반환해 주는 함수입니다.
* 데이터 영역이나 스택 영역에 할당되는 메모리의 크기는 컴파일 타임에 결정되어, 프로그램이 실행되는 내내 고정됩니다.
* 하지만 메모리의 동적 할당으로 힙 영역에 생성되는 메모리의 크기는 런 타임 내내 변화됩니다.
* 따라서 free( ) 함수를 사용하여 다 사용한 메모리를 해제해 주지 않으면, 메모리가 부족해지는 현상이 발생할 수 있습니다.
* 이처럼 사용이 끝난 메모리를 해제하지 않아서 메모리가 부족해지는 현상을 메모리 누수(memory leak)라고 합니다.
* free( ) 함수는 인수로 해제하고자 하는 메모리 공간을 가리키는 포인터를 전달받습니다.
인수의 타입이 void형 포인터로 선언되어 있으므로, 어떠한 타입의 포인터라도 인수로 전달될 수 있습니다.

## calloc( ) 함수
* calloc() 함수는 malloc( ) 함수와 마찬가지로 힙 영역에 메모리를 동적으로 할당해주는 함수입니다.
* 이 함수가 malloc( ) 함수와 다른 점은 할당하고자 하는 메모리의 크기를 두 개의 인수로 나누어 전달 받는 점입니다.
* 또한, calloc() 함수는 메모리를 할당받은 후에 해당 메모리의 모든 비트값을 전부 0으로 초기화해 줍니다.
* calloc( ) 함수도malloc()  함수와 마찬가지로 free( ) 함수를 통해 할당받은 메모리를 해제해 주어야 합니다.
* calloc() 함수의 첫 번째 인수는 메모리 블록의 개수를 나타내며, 두 번째 인수는 각 블록의 바이트 수를 나타냅니다. 

## realloc( ) 함수
* realloc( ) 함수는 이미 할당된 메모리의 크기를 바꾸어 재할당할 때 사용하는 함수입니다.
* realloc( ) 함수의 첫 번째 인수는 크기를 바꾸고자 하는 메모리 공간을 가리키는 포인터를 전달받습니다.
* 두 번째 인수로는 해당 메모리 공간에 재할당할 크기를 전달합니다.
* 따라서 첫 번째 인수로 NULL이 전달되면, malloc( ) 함수와 정확히 같은 동작을 하게 됩니다.
* realloc( ) 함수는 만약 기존의 메모리 위치에 충분한 공간이 있다면 바로 이어서 추가 메모리 공간을 할당해 줍니다.
* 하지만 기존의 메모리 위치에 충분한 공간이 없으면 메모리의 다른 공간에 기존의 데이터를 복사한 후, 이어서 추가 메모리 공간을 할당하게 됩니다.