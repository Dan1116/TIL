# C 정리
* - c 는 컴파일만, gcc 는 링킹까지 모두 
* 변하지 않는 전체 알고리즘에서 변해야 하는 정책만 분리해야 한다.
* C 언어는 void*를 다른 타입으로 암묵적인 변환을 허용한다.
* 일반적으로 gcc 컴파일 할때, C 언어 표준 라이브러리에 대한 암묵적인 링킹이 수행된다 (printf, scanf)
* math 라이브러리는 암묵적인 링킹이 수행되지 않는다 => 명시적인 링킹을 수행해야한다

1. stdin  -> keyboard(0) : <
2. stdout -> monitor(1) : >
3. stderr -> monitor(2) : 2>

* 아스키 코드 => 코드 페이지
* A = 65
* a = 97
* 0 = 48

## 타입
* Built in Type
* User Defined Type => struct, enum, union
* char = 1
* 자바의 char 타입은 2 바이트 => 유니코드를 지원하고 있기 때문에
* short = 2
* int = 4
* long = Linux 8, Windows 4
* long long = 8

### 부동 소수점 타입
* 오차가 있는 타입이다, 절대 ==, != 를 사용하면 안 된다
* 두 값의 차의 절대값이 특정 범위에 들어오는지 확인해야 한다
* float = 4
* double = 8
* long double = 16

## 연산자 우선순위
* * && 가 || 보다 우선 순위가 높다
* 우선순위는 연산의 수행을 의미하는 것이 아니라 연산의 결합을 의미한다
* &&와 ||을 같이 사용하는 경우 괄호를 사용해야 한다

## 함수 포인터
* 함수를 가리키는 포인터
* 변수 : 런타임에 변경되는 값, 실행 시간에 어떤 함수를 호출할지 결정하고 싶다
* 함수의 이름은 함수 포인터로 해석된다
* ex) add => &add, sub => &sub

## 함수의 타입
* 함수의 시그니쳐에 의해서 결정된다
* 함수의 인자의 개수와 인자의 타입과 반환 타입으로 결정된다

## 포인터
* 포인터를 사용하는 이유는 함수에서 전달 받은 인자의 값을 변경할 수 없기 때문에
* => Call by Reference
* 포인터는 주소를 담을 수 있는 타입
* const * : 포인터가 가르키는 대상체를 변경할 수 없다.
* * const : 포인터 변수가 다른 대상체를 가르킬 수 없다.

## Call by Value
* C 언어는 인자를 전달할 때 복사를 수행한다
* Call by Value는 전달 받은 인자의 값을 변경할 수 없다
* 값을 전달하지 말고 주소를 전달해서 주소의 값을 변경하면 된다

## 배열
* C 언어는 배열을 다루는 방법이 일반 타입과 조금 다르다
* 배열은 배열의 첫 번째 원소의 시작 주소로 전달하기 때문에 함수에서 배열의 크기를 알 수 없다
* 배열을 전달하는 함수를 설계할 때, 배열의 길이를 추가적으로 전달해야 한다
* 배열의 이름은 배열의 첫 번째 원소의 시작 주소로 해석된다 (Decay)

* int arr [3] [4] => arr은 하나의 원소가 int [4]인 3개 짜리 배열

### Decay 예외
* sizeof 연산
* & 연산

## 포인터를 배열의 연산으로 다룰 수 있다
* arr [N] =>  * (arr + [N])
* &arr[0] => &*(arr + 0) => (arr + 0) => arr

## C 언어에서 타입을 보는 방법
* 이름을 뺀 나머지가 타입이다
* ex) int i => int , int arr[3] => int [3]

## qsort
* 모든 배열 타입에 대해서 정렬할 수 있어야 한다 => void *
* void * => offset 정보가 없다
* GCC는 void * 에 대한 연산을 char * 로 취급해준다
* => 1 바이트 연산을 지원한다, +/- 연산에 대해서만 지원한다

## ftell
* ftell은 파일의 크기를 구하는 목적으로 사용할 수 있다

## getchar ( ) gets ( ) fletcher ( )
* 반환타입이 int인 이유는 -> 0xFF 를 EOF로 인식하는 문제가 발생할 수 있다

## macro
* # : 전처리기 => 텍스트 처리를 C 언어 문법과 상관없이 할 수 있다, 코드를 생성하는 기술, 매크로 함수
* 전처리 문법은 컴파일 이전에 코드를 반환하므로, 문제가 발생하였을 때 찾기 어렵다

## fopen
* r = 파일이 존재하지 않으면, NULL 을 반환한다
* w = 파일이 존재하지 않으면 새로운 파일을 생성한다, 파일의 내용을 지운다 (TRUNCATE) 
* Windows = CreateFile
* Linux = open

## 표준 입출력
* C
* OS : Unix => Linux
* 모든 것은 파일이다, OS의 자원을 파일의 인터페이스를 통해 다룰 수 있다

### 운영체제 역할
* 자원을 관리한다
* 자원
1. 물리적인 자원 => CPU, RAM, HDD, SSD, Network, Device
2. 추상적인 자원 => Process, Thread, Page, File

* 16bit OS => 비디오 메모리에 직접 쓴다
* 32/ 64 bit OS  => 보호 모드 운영체제
* 보호모드 운영체제 = 운영체제가 제공하는 API를 통해서 자원에 접근할 수 있다

## FILE
* 열린 파일의 정보를 가지고 있다

### File Descriptor
* 버퍼링을 한다
* printf -> fprintf(stdout, …) -> write
*        User Process                 Kernel

### User Process
* User mode 에서는 커널 영역에 일반적으로 접근할 수 없다.
* User mode 에서 커널 모드로 접근하기 위해서는, Context Switching이 필요하다 (Trap)

## 버퍼링
* 버퍼링을 하는 이유는 User mode 와 Kernel mode의 문맥 교환을 자주 일어나지 않도록 하기 위해서 사용한다
* 버퍼링을 비우는 표준 라이브러리 함수 => fflush, fclose  => 프로세스가 종료하면, 프로세스가 연 파일을 스스로 정리한다 
* stdin에 대해서는 fflush 를 사용할 수 없다

1. 풀 버퍼링 = 버퍼가 가득차면, 비운다 -> 일반 파일
2. 라인 버퍼링 = 엔터가 나오거나 버퍼가 가득차면 비운다 -> stdout, stdin
3. 노 버퍼링 = 버퍼링을 하지 않는다 -> stderr

## EOF
* EOF를 통해 입출력 처리를 해야한다
* ^D : EOF를 키보드를 통해 입력할 수 있다

* <: 파일의 내용을 키보드로 리다이렉션해준다.
* >: 프로세스의 출력을 파일로 리다이렉션해준다.

* 파일을 변환하는 방법은 2가지 있다
1. 모든 파일의 내용을 읽어서, 변환하고 다시 저장한다.
2. 파일을 처음부터 읽어서 변환한 내용을 파일에 저장한다. - Stream

## 구조체
* 구조체의 크기가 크면, 함수의 인자를 복사하는데 시간이 걸린다
* 포인터를 인자로 전달할 때 수정되지 않아야 한다면 const를 사용해야 한다

### 구조체 정렬
* CPU가 구조체를 처리할 때, 최선의 성능을 낼 수 있도록 각 필드를 배치하는 방법
* 구조체의 필드 중에서 가장 큰 크기를 갖는 필드의 배수로 떨어지도록 한다
* 구조체의 네트워크 교환용으로 사용할 때는 1 바이트 단위로 패킹이 필요하다 => 컴파일러 확장 명령

## 선언
* 컴파일러에게 변수의 정보만을 준다, 실제 메모리를 사용하지 않는다

## 정의
* 컴파일러에게 실제 변수를 생성하도록 하고 실제 메모리를 사용함

## 헤더 파일
* 헤더 파일을 만들 때 주의할 점은 중복 포함을 방지해야 한다
* 라이브러리의 설계자는 반드시 제공하는 모든 함수에 대한 선언을 제공해야한다

## Storage Class (기억 부류)
### data 
* 실행 파일의 용량이 커진다
* 전역 변수, 내부 정적 변수
* 프로그램 종료 대까지 유효한 영역

### stack
* 지역 변수
* 함수가 시작할 때 생성되고 함수가 종료될 때 사라진다
* 메모리 할당과 해지의 비용이 0

### heap
* 개발자가 원하는 시점에 생성하고 파괴할 수 있다
* malloc / free (Java : new)
* 할당과 해지의 비용이 크다

## 라이브러리
### 정적 라이브러리
* Linux : .a
* Windows : .lib
* 실행 파일 안에 함수의 구현이 포함된다
* 장점 : 추가적인 로드가 필요없다, 배포가 쉽다
* 단점 : 실행 파일의 크기가 커진다, 라이브러리가 변경되면 컴파일을 다시 해야한다

### 동적 라이브러리
* Linux : .so (shared object)
* Windows : .dll (dynamic loading library)
* 실행 중에 필요한 라이브러리를 동적으로 메모리에 로드해서 사용한다
* 실행 파일 안에 함수의 구현이 존재하지 않는다
* 장점 : 실행 파일의 크기가 크지 않다, 라이브러리가 변경되어도 다시 컴파일 할 필요가 없다
* 단점 : 추가적인 로드가 필요하다

## 선형 자료구조
### 배열
* 연속적인 메모리
* 장점 : 임의접근이 용이하다 (RandomAccess)
* 단점 : 중간 삽입과 삭제 시 처리가 힘들다

### 연결 리스트
* 연속적인 메모리가 아닌 논리적으로 연속적인 형태
* 크기가 고정되어 있지 않다
* 연결리스트의 끝을 NULL로 표현하면 NULLPointer 참조로 인해 프로그램이 비정상 종료할 수 있다
* 장점 : 삽입 삭제 시 시간이 동일하다
* 단점 : 임의 접근이 불가능하다

## 노드
* 메모리 공간
* 헤드 노드 : 단일 연결 리스트의 기준점, 데이터를 저장하지 않음
* 지역 변수도 연결리스트로 엮고 전역 변수도 연결리스트로 엮어 있을려면 메모리의 할당 로직을 삽입로직에서 분리해야 한다

### 연결 리스트에서 노드를 추가하는 규칙
1. 노드에 메모리 할당
2. next 멤버에 다음 노드의 메모리 주소 저장
3. data 멤버에 데이터 저장
4. 마지막 노드라면 NULL