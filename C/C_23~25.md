# C_23~25
## 포인터의 포인터
* 포인터 변수도 변수의 한 형태이기 때문에 선언 시 메모리 영역에 4바이트의 메모리 공간 할당이 이뤄진다, 따라서 포인터 변수에 대한 주소 값도 당연히 존재한다
* 포인터 변수도 변수이니 당연히 주소 값을 & 연산자를 사용하면 얻을 수 있다
* TYPE형 포인터 (TYPE **) 변수의 주소 값 저장을 위한 포인터 변수는 => TYPE 형 포인터의 포인터 (TYPE ***)  변수

## 포인터 배열
* 포인터 변수도 일반적인 변수로 인식해야 하고 포인터를 이용해서 배열을 선언하는 것도 이상하게 생각하면 안 된다
* 포인터 배열은 포인터 변수로 이뤄진 배열을 의미한다

## 제한된 형태의 포인터 연산
* 포인터를 가지고 덧셈과 뺄셈이 가능하다
* 포인터 연산이라는 것은 포인터를 피연산자로 하는 연산 전부를 의미한다
* * 메모리 참조
* & 주소 값 반환
* 포인터는 데이터의 첫 번째 바이트를 가리킨다
* 포인터 연산을 통해서 배열 요소의 전부를 참조하는 것이 가능하다

## 배열의 이름은 상수 형태의 포인터
* 포인터가 되기 위해서는 두 가지 조건을 갖춰야 한다
	* 1. 주소 값을 지닌다
	* 2. 주소 값이 가리키는 대상에 대한 자료형 정보를 지닌다
* 배열의 이름도 포인터이다
* TYPE 1차원 배열의 이름은 TYPE형 포인터이다

### 배열 이름 관점에서도 포인터 관점에서도 arr[i]와 *(arr+i)는 동일한 연산문이다

### int arr[] 유형의 선언은 매개변수 선언에서만 사용이 가능하다
* C언어에서 [ ]를 이용한 반환형의 선언은 허용되지 않는다

## 다차원 배열 이름의 포인터 형
* 2차원 배열 이름의 포인터 형은 배열 요소의 자료형이 동일하더라도 달라질 수 있다
* 2차원 배열은 행의 길이에 따라서 포인터 연산의 계산 결과가 달라지니 행의 길이도 포인터 형을 결정짓는 중요한 요소이다
* 2차원 배열 이름의 포인터 형을 결정짓는 정보는 두 가지 이다
	* 1. 배열 요소를 구성하는 변수의 자료형
	* 2. 배열의 가로 길이

## Call By Value, Call By Reference
### 포인터를 이용하면 함수 내에서 외부에 있는 변수에 직접 접근이 가능하다
* 값에 의한 호출 Call By Value 는 값을 복사해서 넘긴다
* 참조에 의한 호출 Call By Reference, 주소 값을 전달하는 형태의 함수 호출, 참조란 포인터를 의미한다, 포인터는 변수를 참조할 수 있는 매개체이기 떄문이다 따라서 Call By Pointer로 부르기도 한다

### 잘못 정의된 Swap 함수, Call By Value 버전
* 값을 교환한 대상이 매개변수이기 때문에 매개변수에 저장된 값이 변경될 뿐, main 함수 내에 저장된 값은 변경되지 않는다

### 제대로 정의된 Swap 함수, Call By Reference
* 교환의 대상이 되는 변수는 매개변수가 아닌 main 함수에 선언된 지역변수이다

### scanf 함수 호출 시 변수의 이름 앞에 & 연산자를 붙여서 변수의 주소 값을 전달하는 이유
* scanf 함수는 키보드로부터 입력된 데이터를 미리 선언된 변수에 채워준다, 결과적으로 scanf 함수 내에서 외부에 선언된 변수에 값을 채우는 모양을 형성하므로, scanf 함수에서 필요로 하는 것은 값이 채워질 변수의 참조, 즉 주소 값이다

## 자료형에 이름을 부여하는 typedef 키워드
* typedef 키워드를 이용해서 자료형에 새 이름을 부여한다
* 예) typedef TYPE NAME, 자료형 TYPE 에게 NAME 이라는 이름을 부여한다
* TYPE 위치에 올 수 있는 자료형의 이름들 
	* 1. int
	* 2. unsigned int
	* 3. unsigned int *
	* 4. const unsigned int *
* 자료형에 붙여지는 새로운 이름은 하나의 단어로 구성이 되어야 한다
* 둘 이상의 단어로 구성된 이름들은 새로운 이름으로 사용이 불가능하다

### typedef 와 관련하여 되는 것과 안 되는 것
* typedef 선언으로 만들어진 새로운 이름의 자료형은 그 자체로 독립적인 형태의 자료형이다, 따라서 typedef 선언으로 만들어진 이름을 다른 자료형의 이름 전체 중 일부로 사용하는  것은 불가능하다
* 포인터 선언에는 언제든지 사용할 수 있으며, 변수에 특성을 부여하는 const, volatile, restrict와 같은 키워드의 사용에는 제한을 받지 않는다
* 한정자 = const, volatile, restrict 
* 배열 선언 앞에 typedef를 붙여주면 배열의 이름이 typedef에 의해 선언된 자료형의 이름으로 인식된다

### 배열 포인터의 typedef 선언
* typedef int (*I2ARR3) [3] ; => I2ARR3은 자료형 (포인터 형) 이름이 된다 가로 길이가 3인 int 형 2차원 배열을 가리킬 수 있는 포인터 형의 이름이 된다

### 모든 프로젝트에서는 typedef로 자료형을 정의하는 것이 일반적이다
* 어느 시스템에서나 그 크기가 동일해야 하는 변수를 선언할 경우에 typedef를 유용하게 사용할 수 있다

## 메모리 공간의 동적 할당
* 메모리 구조
* 코드 영역 : 실행할 프로그램의 코드를 올려 놓을 공간
* 데이터 영역: 프로그램이 종료될 때까지 유지해야 할 데이터를 저장할 공간
* 스택 영역: 아주 잠깐 사용하고 삭제할 데이터의 저장공간
* 힙 영역: 프로그래머가 원하는 형태로 쓸 수 있는 공간
* 전역변수는 데이터 영역에 할당 되어 프로그램이 종료될 때까지 남아있는 변수이고 지역변수는 스택에 할당 되었다가 해당 변수를 선언한 함수가 종료되면 소멸 되는 변수이다

### 배열을 힙 영역에 할당하는 이유
* 지역변수와 전역변수가 갖는 한계 때문에 배열을 힙 영역에 할당해야 한다
* 함수 내에서 할당이 이뤄지고, 함수를 빠져나간 다음에도 할당된 메모리 공간이 소멸되지 않아야 배열을 만들어서 제공하는 함수로서의 역할을 할 수 있지만 배열을 스택에 할당하면 불가하다
* 힙을 이용하면 할당된 메모리 공간의 특성을 우리가 부여한다 그러므로 배열을 힙 영역에 할당해야 한다
* 힙에 한번 할당이 된 메모리는 결코 자동으로 소멸되지 않으므로 꼭 해제를 시켜주어야 한다
* 힙 영역에 메모리를 할당하는 것을 동적 할당이라 한다, 프로그램이 실행되면서 할당될 메모리 공간의 크기를 결정하는 형태이기 때문이다

### 힙 영역에 메모리 공간을 할당할 때 사용하는 함수는 malloc 이다
* malloc 함수는 헤더 파일 stdlib.h 에 선언되어 있으므로 호출을 위해서는 이 헤더파일을 반드시 포함시켜야 한다
* malloc 함수는 숫자의 크기만큼 바이트 단위로 힙 영역에 메모리 공간을 할당한다, 그리고 할당된 메모리 공간의 주소 값을 반환한다
* 할당된 힙 영역에 접근하기 위해서는 어쩔 수 없이 포인터 연산을 해야만 한다
* malloc 함수는 메모리 할당에 실패할 경우 NULL 포인터의 반환여부를 확인하는 것이 코드의 안전성을 위해 좋다
* malloc 함수는 반환되는 주소 값의 포인터 형을 결정하지 못한다
* malloc 함수는 포인터 형이 결정되지 않은 주소 값만을 반환할 수 있다, 이러한 값의 반환을 위해서 정의한 포인터가 바로 void 형 포인터 (void *) 이다 (말만 포인터이지 주소 값 정보만 담을 수 있는 변수에 지나지 않는다)

###  free 힙을 사용하는데 있어서 주의해야 할 사항
* malloc 함수의 호출을 통해서 할당한 메모리 공간을 해제해주지 않으면, 그만큼 메모리 공간의 낭비가 발생하게 된다 
* malloc 함수의 호출을 통해 할당된 메모리 공간은 직접 해제해야 하며, 이 떄 사용하는 함수가 바로 free 함수이다
* free 함수의 전달인자는 반드시 malloc 함수의 반환 값이어야 한다
* free 함수로 해제된 메모리의 포인터는 NULL로 초기화하는 것이 좋다

### malloc 함수와 유사한 calloc 함수
* 힙 영역에 메모리 공간을 할당하는 기능을 제공한다, 다만 할당하는 방식과 초기화 방식에서 차이가 조금 있을 뿐이다
* calloc 함수는 할당된 메모리 공간의 모든 비트를 0으로 초기화시킨다
* calloc 함수의 호출로 할당된 메모리 공간을 해제할 때에는 malloc 함수와 마찬가지로 free 함수를 사용하면 된다

### 힙에 할당된 메모리의 확장 시 호출하는 realloc 함수
* 영역이 힙이고 realloc 함수를 이용하면 할당되어버린 배열의 길이를 늘릴 수 있다
* 함수 호출의 성공 시에는 새로 할당된 메모리의 주소 값이 반환되고, 실패 시에는 NULL이 반환된다
* realloc 함수는 필요에 따라서 요구하는 크기의 메모리 공간을 별도로 할당하여, 기존 메모리 공간에 저장된 값을 복사하기도 한다, 때문에 새로 할당된 메모리의 주소 값을 반환하는 것이다